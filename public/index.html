<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="FastMeet - Ultra low latency video conferencing with high quality">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <title>FastMeet - Ultra Low Latency Video Conferencing</title>
    <style>
        /* Google Meet inspired styles */
        body {
            font-family: 'Google Sans', 'Roboto', sans-serif;
            background: #202124;
            color: #fff;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }
        
        .meet-controls {
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 32px;
            padding: 8px;
            gap: 8px;
        }

        .meet-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #3c4043;
            color: #fff;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .meet-button:hover {
            background: #5f6368;
        }

        .meet-button.leave {
            background: #ea4335;
            position: relative;
            overflow: visible;
        }
        
        .meet-button.leave::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            background: transparent;
            border: 2px solid #ea4335;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .meet-button.leave:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .meet-button.leave:hover::before {
            opacity: 0.5;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }
            70% {
                transform: scale(1.1);
                opacity: 0;
            }
            100% {
                transform: scale(1.1);
                opacity: 0;
            }
        }

        .meet-button.active {
            background: #ea4335;
        }

        .meet-info {
            position: fixed;
            top: 24px;
            left: 24px;
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 16px;
            color: #fff;
            z-index: 100;
        }

        .status-text {
            position: fixed;
            top: 24px;
            right: 24px;
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 16px;
            color: #fff;
            z-index: 100;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
            min-height: 20px;
            box-sizing: border-box;
        }

        .status-text::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: block;
        }

        .status-text.status-good::before {
            background: #34a853;
        }

        .status-text.status-warning::before {
            background: #fbbc04;
        }

        .status-text.status-bad::before {
            background: #ea4335;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 8px;
            padding: 16px;
            height: calc(100vh - 100px);
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
                height: calc(100vh - 120px);
                padding: 8px;
            }
            
            .meet-controls {
                padding: 6px;
                gap: 4px;
            }
            
            .meet-button {
                width: 36px;
                height: 36px;
            }
            
            .status-text {
                top: 12px;
                right: 12px;
                font-size: 12px;
                min-width: 150px;
                padding: 10px;
            }
            
            .meet-info {
                top: 12px;
                left: 12px;
                padding: 10px;
                font-size: 12px;
                max-width: calc(50% - 24px);
            }
            
            .meet-info .flex {
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .meet-info code {
                max-width: 100%;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            #copyRoomId {
                padding: 4px 8px;
                margin-top: 4px;
                min-height: 30px;
                min-width: 50px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }
            
            #copyRoomId:active {
                transform: scale(0.95);
            }
            
            /* Add a mobile-specific room ID tooltip */
            @media (max-width: 480px) {
                .meet-info code:active {
                    white-space: normal;
                    word-break: break-all;
                    background: rgba(255, 255, 255, 0.2);
                }
                
                #copyRoomId:active {
                    background: rgba(138, 180, 248, 0.4);
                }
            }
            
            h1.text-2xl {
                font-size: 1.25rem;
            }
            
            .join-form {
                width: 90%;
                max-width: 320px;
            }
            
            .meet-input {
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            .video-grid {
                grid-template-columns: 1fr;
                padding: 4px;
                gap: 4px;
            }
            
            .meet-controls {
                bottom: 4px;
                padding: 4px;
                gap: 2px;
            }
            
            .meet-button {
                width: 32px;
                height: 32px;
            }
            
            .meet-button svg {
                width: 20px;
                height: 20px;
            }
            
            .video-overlay {
                bottom: 8px;
                left: 8px;
                font-size: 11px;
            }
            
            .status-text, .meet-info {
                padding: 8px;
                font-size: 11px;
            }
            
            .meet-info {
                max-width: calc(60% - 16px);
            }
            
            .meet-info .flex {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }
            
            #copyRoomId {
                margin-top: 2px;
                padding: 4px 8px;
                background: rgba(138, 180, 248, 0.2);
                border-radius: 4px;
                width: 100%;
                text-align: center;
            }
        }
        
        @media (orientation: landscape) and (max-height: 480px) {
            .video-grid {
                height: calc(100vh - 60px);
            }
            
            .meet-controls {
                bottom: 2px;
            }
            
            .video-wrapper {
                height: calc(100vh - 70px);
                aspect-ratio: auto;
            }
        }

        /* Portrait orientation for mobile */
        @media (orientation: portrait) and (max-width: 480px) {
            .camera-overlay {
                width: 80px;
                height: 120px;
                bottom: 70px;
                right: 8px;
            }
        }
        
        .video-wrapper {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: #3c4043;
            aspect-ratio: 16/9;
        }
        
        .video-wrapper.local {
            border: 2px solid #8ab4f8;
        }
        
        .video-wrapper video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-overlay {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(32, 33, 36, 0.6);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            color: #fff;
            z-index: 10;
        }

        .video-overlay.stats {
            bottom: 56px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            min-height: 18px;
            min-width: 120px;
            padding: 4px 8px;
            box-sizing: border-box;
        }

        .video-overlay.stats::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #34a853;
            border-radius: 50%;
            display: block;
        }

        .status-indicator {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #34a853;
        }

        .join-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100%;
            background: #202124;
            gap: 24px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        .join-form {
            background: rgba(60, 64, 67, 0.3);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }

        .meet-input {
            width: 100%;
            padding: 12px;
            background: rgba(32, 33, 36, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: #fff;
            margin-bottom: 16px;
        }

        .meet-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .join-button {
            width: 100%;
            padding: 12px;
            background: #1a73e8;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .join-button:hover {
            background: #1557b0;
        }

        /* Keep existing animation styles */
        @keyframes ping {
            75%, 100% {
                transform: scale(2);
            opacity: 0;
            }
        }
        
        @keyframes fadeScale {
            from {
                opacity: 0;
                transform: scale(0.98);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .fade-scale {
            animation: fadeScale 0.5s ease-out forwards;
        }

        .video-wrapper.screen-sharing {
            position: relative;
        }

        .video-wrapper.screen-sharing video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .camera-overlay {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid #8ab4f8;
            z-index: 1000;
            background: #3c4043;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            justify-content: center;
            transform: scale(1);
        }
        
        .camera-overlay.active {
            display: flex;
        }

        .camera-overlay video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            min-width: 100%;
            min-height: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .camera-overlay:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }

        .camera-overlay .video-overlay {
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 2;
        }
        
        /* Comprehensive responsive camera overlay styles */
        /* Large tablets and small desktops */
        @media (max-width: 1200px) {
            .camera-overlay {
                width: 160px;
                height: 160px;
                bottom: 24px;
                right: 24px;
            }
        }
        
        /* Tablets */
        @media (max-width: 992px) {
            .camera-overlay {
                width: 140px;
                height: 140px;
                bottom: 24px;
                right: 20px;
            }
        }
        
        /* Small tablets */
        @media (max-width: 768px) {
            .camera-overlay {
                width: 120px;
                height: 120px;
                bottom: 65px;
                right: 15px;
            }
        }
        
        /* Large phones */
        @media (max-width: 576px) {
            .camera-overlay {
                width: 100px;
                height: 100px;
                bottom: 60px;
                right: 10px;
                border-width: 2px;
            }
            
            .camera-overlay .video-overlay {
                font-size: 10px;
                padding: 3px 6px;
            }
        }
        
        /* Small phones */
        @media (max-width: 480px) {
            .camera-overlay {
                width: 80px;
                height: 80px;
                bottom: 55px;
                right: 8px;
            }
            
            /* Make buttons more touch-friendly on small screens */
            .meet-button {
                touch-action: manipulation;
                min-width: 44px; /* Minimum touch target size */
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Optimize join form for mobile */
            .join-form {
                padding: 16px;
            }
            
            .meet-input {
                padding: 10px;
                font-size: 14px;
                height: 44px; /* Minimum touch target height */
            }
            
            .join-button {
                padding: 10px;
                height: 44px; /* Minimum touch target height */
            }
            
            /* Fix video grid layout on very small screens */
            .video-grid {
                grid-template-columns: 1fr;
            }
            
            /* Improve notification positioning */
            .notification {
                width: 90%;
                max-width: 300px;
                padding: 8px;
                font-size: 12px;
            }
        }
        
        /* Portrait orientation-specific adjustments */
        @media (orientation: portrait) {
            /* Medium to large phones in portrait */
            @media (max-width: 576px) and (min-width: 481px) {
                .camera-overlay {
                    width: 90px;
                    height: 90px;
                    bottom: 65px;
                }
            }
            
            /* Small phones in portrait */
            @media (max-width: 480px) {
                .camera-overlay {
                    width: 70px;
                    height: 70px;
                    border-width: 2px;
                }
            }
        }
        
        /* Landscape orientation-specific adjustments */
        @media (orientation: landscape) {
            /* Regular landscape mode */
            .camera-overlay {
                bottom: 65px;
            }
            
            /* Small landscape mode (like phones) */
            @media (max-height: 480px) {
                .camera-overlay {
                    width: 70px;
                    height: 70px;
                    bottom: 55px;
                    right: 10px;
                    border-width: 2px;
                }
                
                .camera-overlay .video-overlay {
                    font-size: 9px;
                    padding: 2px 4px;
                    bottom: 4px;
                }
                
                /* Join form adjustments for landscape */
                .join-screen {
                    padding: 10px;
                }
                
                .join-form {
                    padding: 12px;
                    max-width: 350px;
                }
                
                .meet-input, .join-button {
                    margin-bottom: 8px;
                    height: 40px;
                }
            }
            
            /* Very small height (like iPhone in landscape) */
            @media (max-height: 380px) {
                .camera-overlay {
                    width: 60px;
                    height: 60px;
                    bottom: 45px;
                    right: 8px;
                }
            }
        }
        
        /* Ensure camera-overlay doesn't block controls on very small screens */
        @media (max-width: 480px) and (max-height: 480px) {
            .camera-overlay {
                bottom: 50px;
            }
        }

        .remote-camera-overlay {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid #8ab4f8;
            background: #3c4043;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remote-camera-overlay video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            min-width: 100%;
            min-height: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .remote-camera-overlay .video-overlay {
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 2;
        }

        /* Styles for disabled camera during screen sharing */
        .camera-overlay.camera-disabled::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }
        
        .camera-overlay.camera-disabled::after {
            content: 'Camera Off';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            z-index: 6;
            text-align: center;
            width: 100%;
        }
        
        /* Add style for remote camera disabled as well */
        .remote-camera-overlay.camera-disabled::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }
        
        .remote-camera-overlay.camera-disabled::after {
            content: 'Camera Off';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            z-index: 6;
            text-align: center;
            width: 100%;
        }

        /* Add CSS to improve transitions */
        .video-wrapper {
            transition: all 0.3s ease-out;
        }
        .video-overlay {
            transition: background-color 0.3s ease-out, color 0.3s ease-out;
        }
        .status-indicator {
            transition: background-color 0.3s ease-out;
        }
        .status-text {
            transition: background-color 0.3s ease-out, color 0.3s ease-out;
        }

        /* Animations for participant removal */
        @keyframes participant-leave {
            0% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(0.9) rotate(-2deg);
                filter: brightness(0.8);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) rotate(-5deg);
                filter: brightness(0.5);
            }
        }

        .video-wrapper.leaving {
            animation: participant-leave 0.6s ease-out forwards;
            pointer-events: none;
        }

        /* Animation for room closure */
        @keyframes room-closure {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(0.95);
            }
            100% {
                opacity: 0;
                transform: scale(0.9);
            }
        }

        .video-container-closing {
            animation: room-closure 0.8s ease-out forwards;
        }

        /* Message animation */
        .meeting-end-message {
                position: fixed;
            top: 50%;
                left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.4s ease-out;
        }

        .meeting-end-message.visible {
            opacity: 1;
        }

        /* Add CSS for participant entry animation as well */
        @keyframes participant-enter {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(10px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .video-wrapper.entering {
            animation: participant-enter 0.6s ease-out forwards;
        }

        /* Add function to show participant notifications */
        .participant-notification {
            position: fixed;
            top: 80px;
            right: 24px;
            background: rgba(32, 33, 36, 0.95);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .participant-notification.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        .participant-notification.leave {
            border-left: 4px solid #ea4335;
        }
        
        .participant-notification.join {
            border-left: 4px solid #34a853;
        }

        /* Add CSS for disconnected state */
        .video-wrapper.disconnected {
            position: relative;
            opacity: 0.7;
            filter: grayscale(0.5) brightness(0.8);
        }
        
        .video-wrapper.disconnected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 5;
            border-radius: 8px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        
        .video-wrapper.disconnected .status-indicator {
            background: #fbbc04;
            animation: pulse 1.5s infinite;
        }
        
        /* Improve notification styles */
        .participant-notification.warning {
            border-left: 4px solid #fbbc04;
        }
        
        .participant-notification.message {
            border-left: 4px solid #8ab4f8;
        }
        
        .participant-notification.info {
            border-left: 4px solid #8ab4f8;
        }
        
        /* Add transition for smoother UI changes */
        .video-wrapper, .video-overlay, .status-indicator, .status-text {
            transition: all 0.3s ease-out;
        }
        
        /* Optimize animations for better performance */
        @keyframes participant-leave {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
                filter: brightness(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(10px);
                filter: brightness(0.5);
            }
        }
        
        /* Add loading indicator for reconnection */
        .reconnecting-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: #fff;
            animation: spin 1s linear infinite;
            z-index: 10;
            display: none;
        }
        
        .video-wrapper.disconnected .reconnecting-indicator {
            display: block;
        }
        
        @keyframes spin {
            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
        
        /* Add styles for clean exit animation */
        .exiting {
            animation: exit-fade 0.5s ease-out forwards;
        }
        
        @keyframes exit-fade {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.95);
            }
        }
        
        /* Add styles for clean entry animation */
        .entering {
            animation: enter-fade 0.5s ease-out forwards;
        }
        
        @keyframes enter-fade {
            0% {
                opacity: 0;
                transform: scale(0.95);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Improve the fade-scale animation */
        @keyframes fadeScale {
            from {
                opacity: 0;
                transform: scale(0.98);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Animation for setup screen entry and exit */
        .fade-scale {
            animation: fadeScale 0.5s ease-out forwards;
        }

        /* Ensure conference screen transitions smoothly */
        #conferenceScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            z-index: 500;
        }

        #conferenceScreen.exiting {
            opacity: 0;
            transform: scale(0.95);
        }

        /* Add a transition utility class for screens */
        .screen-transition {
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        /* Add fixed positioning to screens to prevent layout shifts */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
            transition: all 0.3s ease-out;
            font-weight: 400;
            width: 400px;
            max-width: 90%;
        }
        
        /* Mobile notification adjustments */
        @media (max-width: 768px) {
            .notification {
                width: 90%;
                max-width: 400px;
                top: 60px;
                padding: 10px 14px;
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            .notification {
                width: 85%;
                max-width: 320px;
                top: 50px;
                padding: 8px 12px;
                font-size: 13px;
                gap: 8px;
            }
        }
        
        .notification.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Port notification adjustments */
        @media (orientation: portrait) and (max-width: 480px) {
            .camera-overlay {
                width: 80px;
                height: 120px;
                bottom: 70px;
                right: 8px;
            }
        }
        
        /* Room ID styles */
        .meet-info code {
            max-width: 160px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            transition: all 0.2s ease;
        }
        
        #copyRoomId {
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Responsive styles for remote camera overlay */
        @media (max-width: 1200px) {
            .remote-camera-overlay {
                width: 160px;
                height: 160px;
            }
        }
        
        @media (max-width: 992px) {
            .remote-camera-overlay {
                width: 140px;
                height: 140px;
            }
        }
        
        @media (max-width: 768px) {
            .remote-camera-overlay {
                width: 120px;
                height: 120px;
                bottom: 20px;
                right: 20px;
            }
        }
        
        @media (max-width: 576px) {
            .remote-camera-overlay {
                width: 100px;
                height: 100px;
                bottom: 16px;
                right: 16px;
                border-width: 2px;
            }
            
            .remote-camera-overlay .video-overlay {
                font-size: 10px;
                padding: 3px 6px;
            }
        }
        
        @media (max-width: 480px) {
            .remote-camera-overlay {
                width: 80px;
                height: 80px;
                bottom: 12px;
                right: 12px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 480px) {
            .remote-camera-overlay {
                width: 70px;
                height: 70px;
                bottom: 10px;
                right: 10px;
                border-width: 2px;
            }
            
            .remote-camera-overlay .video-overlay {
                font-size: 9px;
                padding: 2px 4px;
                bottom: 4px;
            }
        }
        
        @media (max-width: 576px) {
            .camera-overlay.camera-disabled::after,
            .remote-camera-overlay.camera-disabled::after {
                font-size: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .camera-overlay.camera-disabled::after,
            .remote-camera-overlay.camera-disabled::after {
                font-size: 10px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 380px) {
            .camera-overlay.camera-disabled::after,
            .remote-camera-overlay.camera-disabled::after {
                font-size: 9px;
            }
        }

        /* Enhanced remote camera positioning for screen sharing */
        .video-wrapper.screen-sharing .remote-camera-overlay {
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            z-index: 20;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .video-wrapper.screen-sharing .remote-camera-overlay video {
            object-fit: cover;
            min-width: 100%;
            min-height: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
        }
        
        /* Fix remote camera positioning on different screen sizes during screen sharing */
        @media (max-width: 576px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 100px;
                height: 100px;
                bottom: 16px;
                right: 16px;
                border-width: 2px;
            }
        }
        
        @media (max-width: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 70px;
                height: 70px;
                bottom: 12px;
                right: 12px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 65px;
                height: 65px;
                bottom: 10px;
                right: 10px;
                border-width: 2px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 380px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 55px;
                height: 55px;
                bottom: 8px;
                right: 8px;
            }
        }
        
        .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 5;
            font-size: 12px;
            padding: 3px 6px;
            background: rgba(0, 0, 0, 0.7);
        }
        
        /* Adjust text size for small screens */
        @media (max-width: 576px) {
            .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
                font-size: 10px;
                padding: 2px 4px;
            }
        }
        
        @media (max-width: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
                font-size: 9px;
                padding: 2px 3px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
                font-size: 8px;
                padding: 1px 3px;
                bottom: 4px;
            }
        }

        /* Camera off state during screen sharing */
        .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 6;
        }
        
        .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::after {
            content: 'Camera Off';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 7;
            text-align: center;
            width: 100%;
            font-size: 12px;
        }
        
        @media (max-width: 576px) {
            .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::after {
                font-size: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::after {
                font-size: 8px;
            }
        }

        /* Ensure remote camera overlay is visible when rejoining during screen share */
        .video-wrapper.screen-sharing {
            position: relative;
        }
        
        /* Fix for rejoining during screen share - ensure camera overlay is visible */
        .video-wrapper.screen-sharing:not(.has-remote-camera)::after {
            content: '';
            position: absolute;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .video-wrapper.screen-sharing.has-remote-camera .remote-camera-overlay {
            visibility: visible;
            opacity: 1;
        }
        
        /* Ensure the remote camera overlay has proper initial visibility */
        .remote-camera-overlay {
            visibility: visible;
            opacity: 1;
            transition: visibility 0.3s ease, opacity 0.3s ease;
        }

        /* Android Chrome specific fixes */
        @supports (-webkit-touch-callout: none) and (not (translate: none)) {
            /* Target Android Chrome */
            .meet-controls {
                position: fixed !important;
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
                z-index: 2000 !important;
                bottom: 50px !important; /* Higher position to ensure reachability */
                left: 50% !important;
                transform: translateX(-50%) !important;
                background: rgba(32, 33, 36, 0.95) !important;
                backdrop-filter: blur(30px) !important;
                border-radius: 32px !important;
                padding: 8px !important;
                gap: 8px !important;
                width: auto !important;
                min-width: 200px !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
            }
            
            .meet-button {
                width: 48px !important; /* Larger touch target */
                height: 48px !important; /* Larger touch target */
                min-width: 48px !important;
                min-height: 48px !important;
                border-radius: 50% !important;
                background-color: #3c4043 !important;
                color: #fff !important;
                border: none !important;
                cursor: pointer !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                margin: 0 4px !important;
                opacity: 1 !important;
                transition: background-color 0.2s ease !important;
                -webkit-tap-highlight-color: transparent !important;
            }
            
            /* Fix for the active state of buttons on Android */
            .meet-button.active {
                background-color: #ea4335 !important;
            }
            
            .meet-button.leave {
                background: #ea4335 !important;
            }
            
            .meet-button svg {
                width: 24px !important;
                height: 24px !important;
                stroke: currentColor !important;
                stroke-width: 2 !important;
                display: block !important;
                opacity: 1 !important;
            }
        }
        
        /* Alternative Android Chrome fix using user agent detection */
        @media screen and (-webkit-min-device-pixel-ratio:0) {
            @supports (not (-webkit-touch-callout:inherit)) {
                /* Target Android browsers, but not iOS */
                .meet-controls {
                    position: fixed !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    bottom: 50px !important; /* Higher position to ensure reachability */
                }
                
                .meet-button {
                    position: relative !important;
                    display: flex !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    width: 48px !important; /* Larger touch target */
                    height: 48px !important; /* Larger touch target */
                    -webkit-tap-highlight-color: transparent !important;
                }
                
                .meet-button.active {
                    background-color: #ea4335 !important;
                }
            }
        }
        
        /* Additional Android SVG fixes */
        @media screen and (max-width: 768px) {
            /* Fix for Android Chrome SVG visibility issues */
            button.meet-button svg {
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                fill: none !important;
                stroke: currentColor !important;
                stroke-width: 2px !important;
                min-width: 24px !important;
                min-height: 24px !important;
            }
            
            /* Add background color to SVG parent to ensure visibility */
            button.meet-button {
                position: relative !important;
                background-color: #3c4043 !important;
                border-radius: 50% !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                width: 48px !important; /* Larger size for better tap target */
                height: 48px !important; /* Larger size for better tap target */
                margin: 0 6px !important; /* Increase space between buttons */
                overflow: visible !important;
                -webkit-tap-highlight-color: transparent !important;
            }
            
            /* Add active state for touch devices */
            button.meet-button.active {
                background-color: #ea4335 !important;
            }
            
            /* Specific style for the leave button */
            button.meet-button.leave {
                background-color: #ea4335 !important;
            }
            
            /* Increase tap target for mobile and move higher for better reachability */
            .meet-controls {
                padding: 10px 12px !important;
                bottom: 50px !important; /* Higher position to ensure reachability */
                gap: 6px !important;
            }
        }
        
        /* Ensure controls are always visible */
        #meetControls {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 2000 !important;
        }

        /* Additional styles for touch feedback */
        .meet-button.touch-active {
            transform: scale(0.95) !important;
            opacity: 0.9 !important;
        }

        /* Fix for camera-overlay positioning when controls are higher */
        @media (max-width: 576px) {
            .camera-overlay {
                bottom: 120px !important; /* Move up to prevent overlap with raised controls */
            }
        }

        /* Add touch-specific active state for buttons */
        @media (hover: none) {
            /* Target touch devices specifically */
            .meet-button:active, 
            .meet-button.active, 
            .meet-button.touch-active {
                background-color: #ea4335 !important;
                transform: scale(0.95) !important;
                transition: transform 0.1s ease-out, background-color 0.1s ease-out !important;
            }
            
            /* Make sure leave button stays red and just changes opacity on touch */
            .meet-button.leave:active,
            .meet-button.leave.touch-active {
                opacity: 0.8 !important;
                transform: scale(0.95) !important;
            }
            
            /* Fix active state rendering for buttons */
            button.meet-button.active svg,
            button.meet-button:active svg {
                opacity: 1 !important;
                visibility: visible !important;
            }
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            z-index: 9999;
            background: rgba(32, 33, 36, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            max-width: 90%;
            width: auto;
            text-align: center;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .notification.showing {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .notification-content {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-info {
            border-left: 4px solid #4285f4;
        }

        .notification-warning {
            border-left: 4px solid #fbbc05;
        }

        .notification-error {
            border-left: 4px solid #ea4335;
        }

        /* Mobile-specific styles for screen sharing button */
        @media (max-width: 768px) {
            /* Hide screen share button on iOS since it's not supported */
            html.ios #shareScreen {
                display: none !important;
            }
            
            /* Special styling for Android screen share button to indicate it might not work everywhere */
            html.android #shareScreen {
                position: relative;
            }
            
            html.android #shareScreen::after {
                content: "?";
                position: absolute;
                top: -5px;
                right: -5px;
                background: #fbbc05;
                color: #000;
                border-radius: 50%;
                width: 16px;
                height: 16px;
                font-size: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
            }
        }
    </style>
</head>
<body>
    <div id="setupScreen" class="join-screen screen screen-transition">
        <h1 class="text-2xl font-medium mb-2">FastMeet</h1>
        <form id="joinRoomForm" class="join-form">
            <input type="text" id="roomIdInput" placeholder="Enter room ID or leave blank to create a new room" class="meet-input">
            <input type="text" id="userNameInput" placeholder="Your name" required class="meet-input">
            <button type="submit" class="join-button">Join meeting</button>
            </form>
        </div>

    <div id="conferenceScreen" class="screen screen-transition fade-scale" style="display: none;">
        <div class="meet-info">
            <div class="flex items-center gap-4">
                <span class="text-sm">Room ID:</span>
                <code id="currentRoomId" class="text-sm bg-[rgba(255,255,255,0.1)] px-2 py-1 rounded text-ellipsis overflow-hidden"></code>
                <button id="copyRoomId" class="text-sm text-[#8ab4f8] hover:text-white flex items-center justify-center">
                    <span>Copy</span>
                </button>
            </div>
            </div>

        <div id="statusText" class="status-text">
            Initializing...
            </div>

        <div id="videoContainer" class="video-grid">
            <div class="video-wrapper local">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-overlay">You</div>
                <div class="status-indicator"></div>
                <div id="localStats" class="video-overlay stats">Connecting...</div>
            </div>
        </div>

        <div id="meetControls" class="fixed bottom-8 left-1/2 transform -translate-x-1/2 meet-controls flex items-center" style="z-index: 2000; display: flex !important;">
            <button id="toggleAudio" class="meet-button" type="button" aria-label="Toggle microphone">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: block;">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
            </button>
            <button id="toggleVideo" class="meet-button" type="button" aria-label="Toggle camera">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: block;">
                        <polygon points="23 7 16 12 23 17 23 7"></polygon>
                        <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                    </svg>
            </button>
            <button id="shareScreen" class="meet-button" type="button" aria-label="Share screen">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: block;">
                        <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                        <line x1="8" y1="21" x2="16" y2="21"></line>
                        <line x1="12" y1="17" x2="12" y2="21"></line>
                    </svg>
            </button>
            <button id="leaveCall" class="meet-button leave" type="button" aria-label="Leave call">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: block;">
                        <path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path>
                        <line x1="1" y1="1" x2="23" y2="23"></line>
                    </svg>
            </button>
        </div>
    </div>

    <script>
        // Advanced configuration for WebRTC with ultra-low latency settings
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ],
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 10,
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan'
        };

        // Media constraints optimized for low latency
        const mediaConstraints = {
            video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                frameRate: { ideal: 30, max: 60 }
            },
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                latency: 0.01 // Request lowest possible latency
            }
        };

        // Variables to track state
        let localStream;
        let roomId;
        let userName;
        let peerConnections = {};
        let currentRoom;
        let statsInterval;
        let isScreenSharing = false;
        
        // DOM elements
        const setupScreen = document.getElementById('setupScreen');
        const conferenceScreen = document.getElementById('conferenceScreen');
        const joinRoomForm = document.getElementById('joinRoomForm');
        const roomIdInput = document.getElementById('roomIdInput');
        const userNameInput = document.getElementById('userNameInput');
        const currentRoomIdSpan = document.getElementById('currentRoomId');
        const copyRoomIdButton = document.getElementById('copyRoomId');
        let localVideo = document.getElementById('localVideo');
        const videoContainer = document.getElementById('videoContainer');
        const toggleAudioButton = document.getElementById('toggleAudio');
        const toggleVideoButton = document.getElementById('toggleVideo');
        const shareScreenButton = document.getElementById('shareScreen');
        const leaveCallButton = document.getElementById('leaveCall');
        const statusText = document.getElementById('statusText');
        let localStats = document.getElementById('localStats');

        // WebSocket-based signaling implementation
        class WebSocketSignaling {
            constructor(userName) {
                this.userName = userName;
                this.listeners = {};
                this.isConnecting = false;
                this.reconnectAttempts = 0;
                this.maxReconnectDelay = 5000;
                this.pendingMessages = [];
                this.isHost = false; // Track if this user is the host
                this.connectionState = 'disconnected'; // Track connection state
                
                // Start connection
                this.connect();
            }

            connect() {
                if (this.isConnecting) return;
                this.isConnecting = true;
                this.connectionState = 'connecting';
                
                // Use secure WebSocket if the page is served over HTTPS
                const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${location.host}`;
                
                console.log('Connecting to WebSocket server at:', wsUrl);
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket connected successfully');
                    this.isConnecting = false;
                    this.reconnectAttempts = 0;
                    this.connectionState = 'connected';
                    
                    // Send any pending messages
                    while (this.pendingMessages.length > 0) {
                        const message = this.pendingMessages.shift();
                        this.send(message);
                    }
                    
                    // Rejoin room if we were previously in one
                    if (this.roomId && this.userId) {
                        console.log('Rejoining room:', this.roomId);
                        
                        // When reconnecting, send special reconnect request to verify room still exists
                        this.send({
                            type: 'reconnect',
                            roomId: this.roomId,
                            userId: this.userId,
                            userName: this.userName,
                            isHost: this.isHost
                        });
                    }
                    
                    // Trigger connected event for UI updates
                    this.triggerEvent('connection-state-changed', { state: 'connected' });
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const signal = JSON.parse(event.data);
                        
                        // Add special handling for room-closed and reconnection errors
                        if (signal.type === 'error') {
                            console.error('Received error from server:', signal.error, signal.message);
                            
                            // Handle specific error cases
                            if (signal.error === 'room-closed' || signal.error === 'room-not-found') {
                                console.log('Error with room:', signal.error);
                                handleRoomClosure(signal.message);
                                return;
                            }
                            
                            // Handle session expired
                            if (signal.error === 'session-expired') {
                                alert(signal.message);
                                leaveCall();
                                return;
                            }
                        }
                        
                        // Handle room closed event
                        if (signal.type === 'room-closed') {
                            console.log(`Room ${signal.roomId} was closed by the host ${signal.hostName || signal.hostId}`);
                            handleRoomClosure(`This meeting has been ended by ${signal.hostName || 'the host'}`);
                            return;
                        }
                        
                        // Handle server shutdown
                        if (signal.type === 'server-shutdown') {
                            console.log('Server is shutting down:', signal.message);
                            handleRoomClosure('The server is shutting down. Please try again later.');
                            return;
                        }
                        
                        // Dispatch to registered listeners
                        if (this.listeners[signal.type]) {
                            this.listeners[signal.type].forEach(callback => callback(signal));
                        }
                        
                        // Handle room-joined events to improve reconnection handling
                        if (signal.type === 'room-joined' || signal.type === 'room-rejoined') {
                            console.log(`Successfully ${signal.type === 'room-joined' ? 'joined' : 'rejoined'} room ${signal.roomId}`);
                            
                            // Dispatch a custom roomJoined event for the application to handle
                            const roomJoinedEvent = new CustomEvent('roomJoined', {
                                detail: {
                                    roomId: signal.roomId,
                                    userId: signal.userId,
                                    isRejoin: signal.type === 'room-rejoined'
                                }
                            });
                            window.dispatchEvent(roomJoinedEvent);
                            
                            // Force a delay and then check for screen share overlays
                            setTimeout(() => {
                                if (typeof checkAndRestoreScreenShareOverlays === 'function') {
                                    checkAndRestoreScreenShareOverlays();
                                }
                            }, 1500);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.isConnecting = false;
                    this.connectionState = 'error';
                    this.triggerEvent('connection-state-changed', { state: 'error', error });
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket connection closed');
                    this.isConnecting = false;
                    this.connectionState = 'disconnected';
                    
                    // Check if we should try to reconnect
                    if (this.roomId) {
                        // If we were in a room, attempt to reconnect
                        // Implement exponential backoff for reconnection
                        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), this.maxReconnectDelay);
                        this.reconnectAttempts++;
                        
                        if (this.reconnectAttempts <= 5) { // Limit reconnection attempts
                            console.log(`Attempting to reconnect in ${delay}ms... (Attempt ${this.reconnectAttempts})`);
                            
                            // Show reconnection status if we're in the conference
                            if (conferenceScreen.style.display !== 'none') {
                                statusText.textContent = `Reconnecting... (${this.reconnectAttempts}/5)`;
                                statusText.className = 'status-text status-warning';
                            }
                            
                            setTimeout(() => this.connect(), delay);
                        } else {
                            // Failed to reconnect after 5 attempts
                            this.connectionState = 'failed';
                            this.triggerEvent('connection-state-changed', { state: 'failed' });
                            
                            alert('Unable to reconnect to the meeting. Please try joining again.');
                            
                            // Reset room state
                            this.roomId = null;
                            this.userId = null;
                            this.isHost = false;
                            
                            // Return to join screen
                            if (conferenceScreen.style.display !== 'none') {
                                leaveCall();
                            }
                        }
                    } else {
                        this.triggerEvent('connection-state-changed', { state: 'disconnected' });
                    }
                };
            }

            send(signal) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(signal));
                    return true;
                } else {
                    console.log('WebSocket not connected, queueing message');
                    this.pendingMessages.push(signal);
                    if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
                        this.connect();
                    }
                    return false;
                }
            }

            joinRoom(roomId, isNewRoom = false) {
                this.roomId = roomId;
                const userId = this.generateUserId();
                this.userId = userId;
                
                this.isHost = isNewRoom; // Set host flag if creating new room
                
                this.send({
                    type: 'join',
                    roomId: roomId,
                    userId: userId,
                    userName: this.userName,
                    isHost: this.isHost // Send host status to server
                });
                
                return userId;
            }

            sendOffer(targetUserId, offer) {
                return this.send({
                    type: 'offer',
                    offer: offer,
                    targetUserId: targetUserId,
                    roomId: this.roomId
                });
            }

            sendAnswer(targetUserId, answer) {
                return this.send({
                    type: 'answer',
                    answer: answer,
                    targetUserId: targetUserId,
                    roomId: this.roomId
                });
            }

            sendIceCandidate(targetUserId, candidate) {
                return this.send({
                    type: 'ice-candidate',
                    candidate: candidate,
                    targetUserId: targetUserId,
                    roomId: this.roomId
                });
            }

            leaveRoom() {
                console.log('leaveRoom called, isHost:', this.isHost, 'WebSocket state:', this.ws?.readyState);
                
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    console.warn('WebSocket not open, cannot send leave message');
                    // Reset state anyway
                    const wasInRoom = !!this.roomId;
                    this.roomId = null;
                    this.userId = null;
                    this.isHost = false;
                    return false;
                }
                
                // If host is leaving, close the room for everyone
                if (this.isHost) {
                    console.log('Host is leaving, closing room for everyone');
                    const result = this.closeRoom();
                    console.log('closeRoom result:', result);
                    return result;
                } else {
                    // Regular leave for non-hosts
                    console.log('Regular participant leaving, sending leave message');
                    const userName = this.userName; // Capture for notification
                    
                    try {
                        const result = this.send({
                            type: 'leave',
                            userId: this.userId,
                            userName: this.userName,
                            roomId: this.roomId
                        });
                        
                        // Trigger a leave event locally too
                        this.triggerEvent('user-left', {
                            userId: this.userId,
                            userName: this.userName,
                            roomId: this.roomId,
                            isLocalUser: true
                        });
                        
                        // Reset state regardless of send success
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;
                        
                        return result;
                    } catch (error) {
                        console.error('Error sending leave message:', error);
                        
                        // Reset state anyway
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;
                        
                        return false;
                    }
                }
            }

            on(eventType, callback) {
                if (!this.listeners[eventType]) {
                    this.listeners[eventType] = [];
                }
                this.listeners[eventType].push(callback);
            }
            
            off(eventType, callback) {
                if (this.listeners[eventType]) {
                    this.listeners[eventType] = this.listeners[eventType].filter(cb => cb !== callback);
                }
            }
            
            triggerEvent(eventType, data) {
                if (this.listeners[eventType]) {
                    this.listeners[eventType].forEach(callback => callback(data));
                }
            }

            generateUserId() {
                return 'user_' + Math.random().toString(36).substr(2, 9);
            }

            // Add method to close the room (only host can do this)
            closeRoom() {
                console.log('closeRoom called, isHost:', this.isHost);
                
                if (!this.isHost) {
                    console.warn('Attempt to close room by non-host');
                    return false;
                }
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    console.log('Sending close-room signal to server');
                    
                    try {
                        // First, trigger local room-closed event for immediate UI update
                        this.triggerEvent('room-closed', {
                            roomId: this.roomId,
                            hostId: this.userId,
                            hostName: this.userName,
                            isLocalClose: true
                        });
                        
                        // Then send the close request to server
                        const result = this.send({
                            type: 'close-room',
                            roomId: this.roomId,
                            userId: this.userId,
                            userName: this.userName
                        });
                        
                        // Reset state regardless of send success
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;
                        
                        return result;
                    } catch (error) {
                        console.error('Error sending close-room message:', error);
                        
                        // Reset state anyway
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;
                        
                        return false;
                    }
                } else {
                    console.error('WebSocket not open, cannot close room');
                    
                    // Reset state anyway
                    this.roomId = null;
                    this.userId = null;
                    this.isHost = false;
                    
                    return false;
                }
            }
            
            // Add method to send chat messages
            sendChatMessage(message, isPrivate = false, targetUserId = null) {
                return this.send({
                    type: 'message',
                    roomId: this.roomId,
                    message: message,
                    isPrivate: isPrivate,
                    targetUserId: targetUserId
                });
            }
            
            // Add method to get connection state
            getConnectionState() {
                return this.connectionState;
            }
            
            // Add method to disconnect cleanly
            disconnect() {
                if (this.ws) {
                    // First leave any room we're in
                    if (this.roomId) {
                        this.leaveRoom();
                    }
                    
                    // Then close the connection
                    if (this.ws.readyState === WebSocket.OPEN) {
                        this.ws.close(1000, "User disconnected");
                    }
                }
                
                // Reset all state
                this.roomId = null;
                this.userId = null;
                this.isHost = false;
                this.pendingMessages = [];
                this.reconnectAttempts = 0;
                this.connectionState = 'disconnected';
            }
        }

        // Function to ensure clean join process
        function cleanJoinProcess() {
            // Reset any lingering UI states
            setupScreen.classList.remove('fade-scale');
            conferenceScreen.classList.remove('exiting');
            
            // Ensure clean slate for conference screen
            if (videoContainer) {
                // Keep only local video wrapper
                const localWrapper = document.querySelector('.video-wrapper.local');
                if (!localWrapper) {
                    videoContainer.innerHTML = `
                        <div class="video-wrapper local">
                            <video id="localVideo" autoplay muted playsinline></video>
                            <div class="video-overlay">You</div>
                            <div class="status-indicator"></div>
                            <div id="localStats" class="video-overlay stats">Connecting...</div>
                        </div>
                    `;
                }
            }
            
            // Clear any lingering messages or notifications
            document.querySelectorAll('.participant-notification').forEach(el => el.remove());
            const meetingEndMessage = document.getElementById('meetingEndMessage');
            if (meetingEndMessage) {
                meetingEndMessage.remove();
            }
            
            // Reset any screen or room handling flags
            window.isHandlingRoomClosure = false;
            
            // Make sure all buttons are enabled
            if (leaveCallButton) leaveCallButton.disabled = false;
            if (toggleAudioButton) toggleAudioButton.classList.remove('active');
            if (toggleVideoButton) toggleVideoButton.classList.remove('active');
            if (shareScreenButton) shareScreenButton.classList.remove('active');
        }

        async function joinRoom(event) {
            event.preventDefault();
            
            // Ensure clean join process
            cleanJoinProcess();
            
            userName = userNameInput.value.trim();
            if (!userName) {
                alert('Please enter your name');
                return;
            }

            // Initialize WebSocket signaling
            const signaling = new WebSocketSignaling(userName);
            
            // Get room ID or generate a new one
            roomId = roomIdInput.value.trim();
            const isNewRoom = !roomId; // Flag to track if this is a new room
            if (isNewRoom) {
                roomId = generateRoomId();
            }
            
            // Display room ID
            currentRoomIdSpan.textContent = roomId;
            
            try {
                // Show a loading indicator
                statusText.textContent = 'Initializing...';
                statusText.className = 'status-text status-warning';
                
                localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                await applyLowLatencySettings(localStream);
                
                // Handle localVideo reference
                // First try to get the current element if it exists
                const localVideoElement = document.getElementById('localVideo');
                if (localVideoElement) {
                    // Update the srcObject of the existing element
                    localVideoElement.srcObject = localStream;
                } else if (localVideo) {
                    // If the localVideo variable is defined but element doesn't exist in DOM
                    localVideo.srcObject = localStream;
                }
                
                // Apply proper transition from join to conference screen
                setupScreen.classList.remove('fade-scale');
                setupScreen.style.display = 'none';
                
                // Make sure conference screen is visible with animation
                conferenceScreen.style.display = 'block';
                conferenceScreen.classList.add('fade-scale');
                
                // Explicitly remove any properties that might interfere
                conferenceScreen.style.position = '';
                conferenceScreen.style.top = '';
                conferenceScreen.style.left = '';
                
                // Pass isNewRoom flag to identify the host
                const userId = signaling.joinRoom(roomId, isNewRoom);
                setupSignalingListeners(signaling);
                window.signaling = signaling;
                
                // Update the UI to show host status
                if (isNewRoom) {
                    document.querySelector('.video-wrapper.local .video-overlay').textContent = 'You (Host)';
                }
                
                // Ensure references are up to date with new DOM elements
                if (window.domReferences) {
                    window.domReferences.ensureReferences();
                }
                
                startNetworkMonitoring();
                
            } catch (error) {
                console.error('Error accessing media devices:', error);
                alert('Could not access camera and microphone. Please check permissions.');
                
                // Reset UI on error
                setupScreen.style.display = 'flex';
                conferenceScreen.style.display = 'none';
                statusText.textContent = 'Ready to join';
                statusText.className = 'status-text';
            }
        }

        // Apply low latency encoding settings to the stream
        async function applyLowLatencySettings(stream) {
            const videoTrack = stream.getVideoTracks()[0];
            
            if (videoTrack && typeof videoTrack.getConstraints === 'function') {
                // Log current video settings
                    const settings = videoTrack.getSettings();
                    console.log('Current video settings:', settings);
                
                // Try to set encoding parameters if supported
                if (RTCRtpSender.getCapabilities && RTCRtpSender.getCapabilities('video')) {
                    const capabilities = RTCRtpSender.getCapabilities('video');
                    console.log('Video encoding capabilities:', capabilities);
                    
                    // Find the best codec for low latency
                    const preferredCodecs = ['VP9', 'H264', 'VP8'];
                    let selectedCodec = null;
                    
                    for (const preferred of preferredCodecs) {
                        const codec = capabilities.codecs.find(c => 
                            c.mimeType.toLowerCase().includes(preferred.toLowerCase()));
                        if (codec) {
                            selectedCodec = codec;
                            break;
                        }
                    }
                    
                    if (selectedCodec) {
                        console.log('Selected codec for low latency:', selectedCodec);
                    }
                }
                
                // Apply optimal constraints for low latency
                const constraints = {
                    width: { ideal: settings.width || 1280 },
                    height: { ideal: settings.height || 720 },
                    frameRate: { ideal: 30, max: 60 },
                    aspectRatio: { ideal: settings.aspectRatio || 16/9 },
                    deviceId: { exact: settings.deviceId }
                };
                
                try {
                    await videoTrack.applyConstraints(constraints);
                    console.log('Successfully applied video constraints:', constraints);
                    
                    // Verify the applied settings
                    const newSettings = videoTrack.getSettings();
                    console.log('New video settings after constraints:', newSettings);
                } catch (e) {
                    console.error('Error applying video constraints:', e);
                    // Fallback to less strict constraints if exact constraints fail
                    try {
                        const fallbackConstraints = {
                            ...constraints,
                            deviceId: { ideal: settings.deviceId }
                        };
                        await videoTrack.applyConstraints(fallbackConstraints);
                        console.log('Applied fallback video constraints:', fallbackConstraints);
                    } catch (fallbackError) {
                        console.error('Error applying fallback video constraints:', fallbackError);
                    }
                }
            }
            
            // Apply audio optimizations
            const audioTrack = stream.getAudioTracks()[0];
            if (audioTrack) {
                try {
                    await audioTrack.applyConstraints({
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        latency: { ideal: 0.01 }
                    });
                    console.log('Successfully applied audio constraints');
                } catch (e) {
                    console.error('Error applying audio constraints:', e);
                }
            }
        }

        // Generate a random room ID
        function generateRoomId() {
            return 'room_' + Math.random().toString(36).substr(2, 9);
        }

        // Copy room ID to clipboard
        function copyRoomId() {
            navigator.clipboard.writeText(roomId).then(() => {
                const originalText = copyRoomIdButton.textContent;
                copyRoomIdButton.textContent = 'Copied!';
                setTimeout(() => {
                    copyRoomIdButton.textContent = originalText;
                }, 2000);
            });
        }

        // Toggle audio
        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    toggleAudioButton.classList.toggle('active');
                }
            }
        }

        // Toggle video
        function toggleVideo() {
            if (localStream) {
                if (isScreenSharing) {
                    // When screen sharing, toggle the camera overlay instead
                    if (window.originalCameraTrack) {
                        window.originalCameraTrack.enabled = !window.originalCameraTrack.enabled;
                        
                        // Update the camera overlay visibility to match the enabled state
                        const cameraOverlay = document.getElementById('cameraOverlay');
                        if (cameraOverlay) {
                            if (!window.originalCameraTrack.enabled) {
                                cameraOverlay.classList.add('camera-disabled');
                            } else {
                                cameraOverlay.classList.remove('camera-disabled');
                            }
                        }
                        
                        // Also update other peers to see your camera disabled
                        Object.values(peerConnections).forEach(pc => {
                            const senders = pc.getSenders();
                            const cameraSender = senders.find(sender => 
                                sender.track && sender.track.kind === 'video' && 
                                sender.track.label === window.originalCameraTrack.label);
                            
                            if (cameraSender && cameraSender.track) {
                                cameraSender.track.enabled = window.originalCameraTrack.enabled;
                            }
                        });
                        
                        toggleVideoButton.classList.toggle('active');
                    }
                } else {
                    // Normal mode - toggle the main video track
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        toggleVideoButton.classList.toggle('active');
                    }
                }
            }
        }

        // Function to detect mobile devices
        function isMobileDevice() {
            return (
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /Mobi|Android/i.test(navigator.userAgent))
            );
        }

        // Function to detect iOS devices specifically
        function isIOSDevice() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // Function to detect Android devices specifically
        function isAndroidDevice() {
            return /Android/i.test(navigator.userAgent);
        }

        // Function to show a notification
        function showNotification(message, type = 'info', duration = 5000) {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `<div class="notification-content">${message}</div>`;
            
            document.body.appendChild(notification);
            
            // Add showing class for animation
            setTimeout(() => {
                notification.classList.add('showing');
            }, 10);
            
            // Auto dismiss after duration
            setTimeout(() => {
                notification.classList.remove('showing');
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, duration);
        }

        // Toggle screen sharing with mobile device support
        async function toggleScreenShare() {
            try {
                if (!isScreenSharing) {
                    // Check if on mobile device
                    if (isMobileDevice()) {
                        // Special handling for iOS (not supported)
                        if (isIOSDevice()) {
                            showNotification('Screen sharing is not supported on iOS browsers. Please use a desktop browser for this feature.', 'warning', 5000);
                            return;
                        }
                        
                        // Special handling for Android
                        if (isAndroidDevice()) {
                            // Show guidance for Android users
                            showNotification('On Android, you may need to enable screen sharing in your browser settings. Look for "Site settings" > "Screen sharing" or similar options.', 'info', 8000);
                            
                            // Different options for Android
                            const screenConstraints = {
                                video: {
                                    displaySurface: 'window',
                                    logicalSurface: true,
                                    cursor: 'never'
                                }
                            };
                            
                            try {
                                const screenStream = await navigator.mediaDevices.getDisplayMedia(screenConstraints);
                                handleScreenShareSuccess(screenStream);
                            } catch (err) {
                                console.error('Error accessing screen on Android:', err);
                                showNotification('Unable to access screen. This feature may not be supported on your device or browser version.', 'error');
                            }
                            return;
                        }
                    }
                    
                    // Default desktop handling
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { cursor: 'always' }
                    });
                    
                    handleScreenShareSuccess(screenStream);
                } else {
                    await stopScreenShare();
                }
            } catch (error) {
                console.error('Error sharing screen:', error);
                showNotification('Could not share screen. Please check permissions.', 'error');
                isScreenSharing = false;
                shareScreenButton.classList.remove('active');
            }
        }

        // Handle successful screen share acquisition
        function handleScreenShareSuccess(screenStream) {
            const screenTrack = screenStream.getVideoTracks()[0];
            window.originalCameraTrack = localStream.getVideoTracks()[0];
            
            // Create a new stream with both screen share and camera tracks
            const combinedStream = new MediaStream();
            combinedStream.addTrack(screenTrack);
            combinedStream.addTrack(window.originalCameraTrack);
            
            // Replace tracks in all peer connections
            Promise.all(Object.values(peerConnections).map(async pc => {
                // First, find and remove any existing video senders
                const senders = pc.getSenders();
                const videoSenders = senders.filter(sender => 
                    sender.track && sender.track.kind === 'video');
                
                // Remove existing video tracks
                for (const sender of videoSenders) {
                    pc.removeTrack(sender);
                }
                
                // Add both screen share and camera tracks
                pc.addTrack(screenTrack, combinedStream);
                pc.addTrack(window.originalCameraTrack, combinedStream);
            }));
            
            // Update local video to show screen share
            localStream.removeTrack(window.originalCameraTrack);
            localStream.addTrack(screenTrack);
            localVideo.srcObject = localStream;
            
            // Create camera overlay with the original camera feed
            createCameraOverlay();
            
            screenTrack.onended = async () => {
                await stopScreenShare();
            };
            
            isScreenSharing = true;
            shareScreenButton.classList.add('active');
        }

        // Function to create camera overlay for screen sharing
        function createCameraOverlay() {
            // Create camera overlay if it doesn't exist
            let cameraOverlay = document.getElementById('cameraOverlay');
            if (!cameraOverlay) {
                cameraOverlay = document.createElement('div');
                cameraOverlay.id = 'cameraOverlay';
                cameraOverlay.className = 'camera-overlay';
                
                const cameraVideo = document.createElement('video');
                cameraVideo.id = 'cameraVideo';
                cameraVideo.autoplay = true;
                cameraVideo.muted = true;
                cameraVideo.playsInline = true;
                
                const nameOverlay = document.createElement('div');
                nameOverlay.className = 'video-overlay';
                nameOverlay.textContent = 'You';
                
                cameraOverlay.appendChild(cameraVideo);
                cameraOverlay.appendChild(nameOverlay);
                document.body.appendChild(cameraOverlay);
            }
            
            // Create a new stream with the original camera track for the overlay
            const cameraStream = new MediaStream([window.originalCameraTrack]);
            document.getElementById('cameraVideo').srcObject = cameraStream;
            
            // Show the camera overlay
            cameraOverlay.classList.add('active');
            
            // Make the local video wrapper show the screen share properly
            document.querySelector('.video-wrapper.local').classList.add('screen-sharing');
        }

        // Update stopScreenShare function to properly handle both tracks
        async function stopScreenShare() {
            try {
                if (!window.originalCameraTrack) {
                    const cameraStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                    window.originalCameraTrack = cameraStream.getVideoTracks()[0];
                }
                
                // Replace tracks in all peer connections
                await Promise.all(Object.values(peerConnections).map(async pc => {
                    // First, find and remove any existing video senders
                const senders = pc.getSenders();
                    const videoSenders = senders.filter(sender => 
                        sender.track && sender.track.kind === 'video');
                    
                    // Remove existing video tracks
                    for (const sender of videoSenders) {
                        pc.removeTrack(sender);
                    }
                    
                    // Add back only the camera track
                    pc.addTrack(window.originalCameraTrack, localStream);
                }));
                
                // Stop all screen share tracks
                localStream.getVideoTracks().forEach(track => {
                    if (track.label !== window.originalCameraTrack.label) {
                        track.stop();
                    }
                });
                
                // Update local video
                const audioTrack = localStream.getAudioTracks()[0];
                localStream = new MediaStream([window.originalCameraTrack]);
                if (audioTrack) {
                    localStream.addTrack(audioTrack);
                }
                localVideo.srcObject = localStream;
                
                // Update UI
                document.querySelector('.video-wrapper.local').classList.remove('screen-sharing');
                const cameraOverlay = document.getElementById('cameraOverlay');
                if (cameraOverlay) {
                    cameraOverlay.classList.remove('active');
                }
                
                isScreenSharing = false;
                shareScreenButton.classList.remove('active');
            } catch (error) {
                console.error('Error stopping screen share:', error);
                alert('Could not restore camera. Please refresh the page.');
            }
        }

        // Leave the call
        function leaveCall() {
            console.log('leaveCall function triggered, isHost:', window.signaling?.isHost);
            
            // Update status text immediately
            statusText.textContent = 'Leaving meeting...';
            statusText.className = 'status-text status-warning';
            
            // Disable leave button to prevent double-clicks
            leaveCallButton.disabled = true;
            
            // Store host status before we reset it
            const wasHost = window.signaling?.isHost || false;
            const roomIdCopy = roomId;  // Store for reference after reset
            
            // Flag to track if we've successfully sent the leave message
            let leaveSent = false;
            
            try {
                // Apply animation to all video elements
                const videoWrappers = document.querySelectorAll('.video-wrapper');
                console.log(`Applying leaving animation to ${videoWrappers.length} video wrappers`);
                videoWrappers.forEach(wrapper => {
                    wrapper.classList.add('leaving');
                });
                
                // Add exiting class to conference screen for smooth transition
                conferenceScreen.classList.add('exiting');
                
                // Try to send leave/close room message first
                if (window.signaling && window.signaling.ws && window.signaling.ws.readyState === WebSocket.OPEN) {
                    console.log('Sending leave/close room message');
                    leaveSent = wasHost ? 
                        window.signaling.closeRoom() : 
                        window.signaling.leaveRoom();
                        
                    console.log(`${wasHost ? 'Close' : 'Leave'} room message sent:`, leaveSent);
                    
                    // If we're the host and message failed, show error
                    if (wasHost && !leaveSent) {
                        showParticipantNotification('Failed to close room. Other participants may still be connected.', 'warning');
                    }
                } else {
                    console.warn('WebSocket not available for leave message');
                    // Even if WebSocket is not available, we'll still clean up local resources
                }
                
                // Wait for animation to complete
                setTimeout(() => {
                    console.log('Animation completed, cleaning up resources');
                    
                    // Clean up all resources efficiently
                    cleanupResources();
                    
                    // Reset UI
                    resetUI();
                    
                    // Show notification based on host status
                    if (wasHost) {
                        showParticipantNotification(`Meeting ended. Room ${roomIdCopy} has been closed.`, 'info');
                    } else {
                        showParticipantNotification('You left the meeting', 'leave');
                    }
                    
                    console.log('Leave call complete');
                    
                    // Re-enable leave button (although it's now hidden)
                    leaveCallButton.disabled = false;
                }, 650); // Slightly longer than animation to ensure completion
                
            } catch (error) {
                console.error('Error in leaveCall:', error);
                
                // Even if there's an error, make sure we clean up
                cleanupResources();
                resetUI();
                
                // Show error notification
                showParticipantNotification('Error leaving meeting. Resources have been cleaned up.', 'warning');
                
                // Re-enable leave button (although it's now hidden)
                leaveCallButton.disabled = false;
            }
        }
        
        // Function to clean up all resources efficiently
        function cleanupResources() {
            console.log('Starting resource cleanup');
            
            try {
                // 1. Stop all media tracks with careful error handling
                if (localStream) {
                    console.log('Stopping local media tracks');
                    try {
                        localStream.getTracks().forEach(track => {
                            try {
                                track.stop();
                                console.log(`Stopped ${track.kind} track: ${track.label}`);
                            } catch (e) {
                                console.error(`Error stopping ${track.kind} track:`, e);
                            }
                        });
                        localStream = null;
                    } catch (e) {
                        console.error('Error stopping local stream:', e);
                    }
                }
                
                // 2. Clean up all peer connections
                Object.entries(peerConnections).forEach(([userId, pc]) => {
                    try {
                        // Stop all remote tracks
                        const remoteStreams = pc.getRemoteStreams();
                        remoteStreams.forEach(stream => {
                            stream.getTracks().forEach(track => {
                                try {
                                    track.stop();
                                    console.log(`Stopped remote ${track.kind} track for user ${userId}`);
                                } catch (e) {
                                    console.error(`Error stopping remote track for user ${userId}:`, e);
                                }
                            });
                        });
                        
                        // Stop all local tracks being sent to this peer
                        if (pc.getSenders) {
                            pc.getSenders().forEach(sender => {
                                if (sender.track) {
                                    try {
                                        sender.track.stop();
                                        console.log(`Stopped sender track for user ${userId}`);
                                    } catch (e) {
                                        console.error(`Error stopping sender track for user ${userId}:`, e);
                                    }
                                }
                            });
                        }
                        
                        // Clear any stats intervals
                        if (pc.statsIntervalId) {
                            clearInterval(pc.statsIntervalId);
                        }
                        
                        // Close the connection
                        pc.close();
                        console.log(`Closed peer connection for user ${userId}`);
                    } catch (e) {
                        console.error(`Error cleaning up peer connection for user ${userId}:`, e);
                    }
                });
                
                // Clear all peer connections
                peerConnections = {};
                
                // 3. Clean up video elements
                const videoContainer = document.getElementById('videoContainer');
                if (videoContainer) {
                    const videos = videoContainer.getElementsByTagName('video');
                    Array.from(videos).forEach(video => {
                        try {
                            if (video.srcObject) {
                                const stream = video.srcObject;
                                stream.getTracks().forEach(track => {
                                    try {
                                        track.stop();
                                    } catch (e) {
                                        console.error('Error stopping video track:', e);
                                    }
                                });
                                video.srcObject = null;
                            }
                        } catch (e) {
                            console.error('Error cleaning up video element:', e);
                        }
                    });
                }
                
                console.log('Resource cleanup completed');
            } catch (error) {
                console.error('Error during resource cleanup:', error);
                // Even if there's an error, try to clear peer connections
                peerConnections = {};
            }
        }
        
        // Function to reset UI state
        function resetUI() {
            console.log('Resetting UI state');
            
            try {
                // Reset screen visibility with transition
                conferenceScreen.style.display = 'none';
                
                // Apply proper setup screen display style and animation
                setupScreen.style.display = 'flex'; // Use flex instead of block to center content
                
                // Remove any custom styles that might have been applied
                setupScreen.style.position = '';
                setupScreen.style.top = '';
                setupScreen.style.left = '';
                setupScreen.style.transform = '';
                
                // First add fade-out and then remove it when transition completes
                // This ensures smooth transition between screens
                setupScreen.classList.add('fade-scale');
                
                // Reset animation states on conferenceScreen
                conferenceScreen.classList.remove('exiting');
                conferenceScreen.classList.add('fade-scale');
                
                // Reset form fields but keep the username for convenience
                roomIdInput.value = '';
                // Don't clear username: userNameInput.value = '';
                
                // Reset button states
                shareScreenButton.classList.remove('active');
                toggleVideoButton.classList.remove('active');
                toggleAudioButton.classList.remove('active');
                leaveCallButton.disabled = false;
                
                // Reset video container animations
                videoContainer.classList.remove('video-container-closing');
                
                // Empty and recreate video container for clean slate
                videoContainer.innerHTML = '';
                
                // Create a fresh local video element for next call
                const newLocalVideoWrapper = document.createElement('div');
                newLocalVideoWrapper.className = 'video-wrapper local';
                newLocalVideoWrapper.innerHTML = `
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-overlay">You</div>
                    <div class="status-indicator"></div>
                    <div id="localStats" class="video-overlay stats">Connecting...</div>
                `;
                videoContainer.appendChild(newLocalVideoWrapper);
                
                // Reset streams on existing video elements (without reassigning variables)
                // Clear existing video stream if it exists
                if (localVideo && localVideo.srcObject) {
                    const oldStream = localVideo.srcObject;
                    if (oldStream) {
                        oldStream.getTracks().forEach(track => {
                            track.stop();
                        });
                    }
                    localVideo.srcObject = null;
                }
                
                // Reset room ID display
                currentRoomIdSpan.textContent = '';
                
                // Reset status text
                statusText.textContent = 'Ready to join';
                statusText.className = 'status-text';
                
                // Clear any room-specific data that might be persisted in the UI
                document.querySelectorAll('.camera-overlay').forEach(el => el.remove());
                document.querySelectorAll('.remote-camera-overlay').forEach(el => el.remove());
                
                // Reset any toggles or switched states
                if (window.originalCameraTrack) {
                    window.originalCameraTrack = null;
                }
                
                // Ensure our references are updated for the new elements
                if (window.domReferences && typeof window.domReferences.ensureReferences === 'function') {
                    window.domReferences.ensureReferences();
                }
                
                console.log('UI reset complete');
            } catch (error) {
                console.error('Error resetting UI:', error);
                
                // Emergency reset in case of error
                try {
                    conferenceScreen.style.display = 'none';
                    setupScreen.style.display = 'flex'; // Use flex for proper centering
                    
                    // Reset any custom positioning
                    setupScreen.style.position = '';
                    setupScreen.style.top = '';
                    setupScreen.style.left = '';
                    setupScreen.style.transform = '';
                    
                    // Minimal reset without reassigning variables
                    if (videoContainer) {
                        videoContainer.innerHTML = `
                            <div class="video-wrapper local">
                                <video id="localVideo" autoplay muted playsinline></video>
                                <div class="video-overlay">You</div>
                                <div class="status-indicator"></div>
                                <div id="localStats" class="video-overlay stats">Connecting...</div>
                            </div>
                        `;
                    }
                    
                    if (statusText) {
                        statusText.textContent = 'Ready to join';
                        statusText.className = 'status-text';
                    }
                    
                    // Clear any existing streams without reassigning variables
                    if (localVideo && localVideo.srcObject) {
                        const oldStream = localVideo.srcObject;
                        if (oldStream) {
                            oldStream.getTracks().forEach(track => {
                                track.stop();
                            });
                        }
                        localVideo.srcObject = null;
                    }
                    
                    // Try to update references as a last resort
                    if (window.domReferences && typeof window.domReferences.ensureReferences === 'function') {
                        window.domReferences.ensureReferences();
                    }
                    
                } catch (e) {
                    console.error('Emergency UI reset failed:', e);
                }
            }
        }

        // Function to handle room closure from server or host
        function handleRoomClosure(reason, isLocalClose = false) {
            console.log(`Handling room closure: ${reason}, isLocalClose: ${isLocalClose}`);
            
            try {
                // Prevent multiple closures
                if (window.isHandlingRoomClosure) {
                    console.log('Already handling room closure, ignoring duplicate');
                    return;
                }
                window.isHandlingRoomClosure = true;
                
                // Show animated message
                showRoomClosedMessage(reason || 'This meeting has been ended by the host');
                
                // Apply closing animation to all videos
                videoContainer.classList.add('video-container-closing');
                
                // Set status text
                statusText.textContent = 'Meeting ended';
                statusText.className = 'status-text status-warning';
                
                // If this is a remote closure (we're not the host who closed it),
                // make sure we close our connections too
                if (!isLocalClose) {
                    // Local cleanup for remote closure
                    console.log('Remote room closure, cleaning up resources');
                    
                    // Disable leave button to prevent double-clicks
                    leaveCallButton.disabled = true;
                    
                    // Clean up and return to the join screen after animation
                    setTimeout(() => {
                        // Clean up all resources
                        cleanupResources();
                        resetUI();
                        
                        // Show appropriate notification based on who closed the room
                        if (reason && reason.includes('host')) {
                            showParticipantNotification('Meeting ended by the host', 'info');
                        } else {
                            showParticipantNotification('Meeting ended', 'info');
                        }
                        
                        // Reset handling flag
                        window.isHandlingRoomClosure = false;
                        leaveCallButton.disabled = false;
                    }, 800); // Match the room closure animation duration
                } else {
                    // For local closure (we're the host), we've already initiated leave call
                    // Just reset the handling flag after animation completes
                    setTimeout(() => {
                        window.isHandlingRoomClosure = false;
                    }, 800);
                }
            } catch (error) {
                console.error('Error handling room closure:', error);
                
                // Emergency cleanup
                try {
                    cleanupResources();
                    resetUI();
                    window.isHandlingRoomClosure = false;
                } catch (e) {
                    console.error('Error in emergency cleanup during room closure:', e);
                }
            }
        }

        // Function to show room closed message with animation
        function showRoomClosedMessage(message) {
            try {
                // Create message element if it doesn't exist
                let messageEl = document.getElementById('meetingEndMessage');
                if (!messageEl) {
                    messageEl = document.createElement('div');
                    messageEl.id = 'meetingEndMessage';
                    messageEl.className = 'meeting-end-message';
                    document.body.appendChild(messageEl);
                }
                
                // Set message text and show
                messageEl.textContent = message;
                
                // Force a reflow before adding the visible class for animation
                void messageEl.offsetWidth;
                messageEl.classList.add('visible');
                
                // Remove after animation
                setTimeout(() => {
                    messageEl.classList.remove('visible');
                    setTimeout(() => {
                        if (messageEl && messageEl.parentNode) {
                            messageEl.parentNode.removeChild(messageEl);
                        }
                    }, 400); // Match the opacity transition duration
                }, 2000); // Show message for 2 seconds
            } catch (error) {
                console.error('Error showing room closed message:', error);
            }
        }

        // Function to show participant notifications
        function showParticipantNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `participant-notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.add('visible');
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.remove('visible');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }

        // Setup signaling event listeners
        function setupSignalingListeners(signaling) {
            // When a user joins the room
            signaling.on('user-joined', async (data) => {
                if (data.userId !== signaling.userId) {
                    console.log(`${data.userName} joined the room`);
                    
                    // Show notification
                    showParticipantNotification(`${data.userName} joined the meeting`, 'join');
                    
                    // Create a peer connection for the new user
                    const pc = createPeerConnection(data.userId, data.userName);
                    
                    // Create and send an offer (handled by negotiationneeded event)
                }
            });
            
            // When a user leaves the room
            signaling.on('user-left', (data) => {
                console.log(`${data.userName || 'A user'} left the meeting`);
                
                // Only show notification if it's not the current user leaving
                if (data.userName && data.userId !== signaling.userId) {
                    showParticipantNotification(`${data.userName} left the meeting`, 'leave');
                }
                
                // Find and cleanup the video wrapper
                const videoWrapper = document.getElementById(`video-wrapper-${data.userId}`);
                if (videoWrapper) {
                    // Add leaving animation
                    videoWrapper.classList.add('leaving');
                    
                    // Remove element after animation completes
                    setTimeout(() => {
                        // Close peer connection with proper cleanup
                        const pc = peerConnections[data.userId];
                        if (pc) {
                            try {
                                // Only stop remote tracks from this specific peer
                                const remoteStreams = pc.getRemoteStreams();
                                remoteStreams.forEach(stream => {
                                    stream.getTracks().forEach(track => {
                                        track.stop();
                                    });
                                });
                                
                                // Don't stop local tracks, just remove them from this peer connection
                                if (pc.getSenders) {
                                    pc.getSenders().forEach(sender => {
                                        try {
                                            if (sender.track) {
                                                // Instead of stopping the track, just remove it from the sender
                                                sender.replaceTrack(null);
                                            }
                                        } catch (e) {
                                            console.error(`Error removing track from sender for user ${userId}:`, e);
                                        }
                                    });
                                }
                                
                                // Clear any stats intervals
                                if (pc.statsIntervalId) {
                                    clearInterval(pc.statsIntervalId);
                                }
                                
                                // Close the connection
                                pc.close();
                                delete peerConnections[data.userId];
                                
                                // Clear video srcObject
                                const video = videoWrapper.querySelector('video');
                                if (video && video.srcObject) {
                                    const stream = video.srcObject;
                                    stream.getTracks().forEach(track => {
                                        track.stop();
                                    });
                                    video.srcObject = null;
                                }
                            } catch (e) {
                                console.error(`Error cleaning up peer connection for user ${data.userId}:`, e);
                            }
                        }
                        
                        // Remove video element after cleanup
                        videoWrapper.remove();
                        
                        // Verify local video is still working
                        const localVideo = document.getElementById('localVideo');
                        if (localVideo && localVideo.srcObject) {
                            const tracks = localVideo.srcObject.getTracks();
                            if (tracks.length === 0 || tracks.every(track => track.readyState === 'ended')) {
                                console.log('Local video tracks ended, attempting to restore...');
                                // Attempt to restore local video if needed
                                if (localStream) {
                                    localVideo.srcObject = localStream;
                                }
                            }
                        }
                    }, 600); // Match animation duration
                } else {
                    // Fallback if element not found
                    const pc = peerConnections[data.userId];
                    if (pc) {
                        try {
                            // Only stop remote tracks
                            const remoteStreams = pc.getRemoteStreams();
                            remoteStreams.forEach(stream => {
                                stream.getTracks().forEach(track => {
                                    track.stop();
                                });
                            });
                            
                            // Remove local tracks from peer connection without stopping them
                            if (pc.getSenders) {
                                pc.getSenders().forEach(sender => {
                                    if (sender.track) {
                                        sender.replaceTrack(null);
                                    }
                                });
                            }
                            
                            if (pc.statsIntervalId) {
                                clearInterval(pc.statsIntervalId);
                            }
                            
                            pc.close();
                            delete peerConnections[data.userId];
                        } catch (e) {
                            console.error(`Error cleaning up peer connection for user ${data.userId}:`, e);
                        }
                    }
                }
            });
            
            // When a user temporarily disconnects
            signaling.on('user-disconnected', (data) => {
                console.log(`${data.userName || 'A user'} temporarily disconnected`);
                
                // Show notification
                if (data.userName) {
                    showParticipantNotification(`${data.userName} disconnected (reconnecting...)`, 'warning');
                }
                
                // Update UI to show disconnected state
                const videoWrapper = document.getElementById(`video-wrapper-${data.userId}`);
                if (videoWrapper) {
                    videoWrapper.classList.add('disconnected');
                    
                    // Update stats display
                    const statsDiv = document.getElementById(`stats-${data.userId}`);
                    if (statsDiv) {
                        statsDiv.textContent = 'Disconnected (reconnecting...)';
                    }
                }
            });
            
            // When a user reconnects
            signaling.on('user-reconnected', (data) => {
                console.log(`${data.userName || 'A user'} reconnected`);
                
                // Show notification
                if (data.userName) {
                    showParticipantNotification(`${data.userName} reconnected`, 'join');
                }
                
                // Update UI to show connected state
                const videoWrapper = document.getElementById(`video-wrapper-${data.userId}`);
                if (videoWrapper) {
                    videoWrapper.classList.remove('disconnected');
                    
                    // Update stats display
                    const statsDiv = document.getElementById(`stats-${data.userId}`);
                    if (statsDiv) {
                        statsDiv.textContent = 'Reconnected';
                    }
                }
            });
            
            // When a new host is assigned
            signaling.on('new-host', (data) => {
                console.log(`${data.userName} is now the host`);
                
                // Show notification
                showParticipantNotification(`${data.userName} is now the host`, 'info');
                
                // Update UI to show new host
                const videoWrapper = document.getElementById(`video-wrapper-${data.userId}`);
                if (videoWrapper) {
                    const nameOverlay = videoWrapper.querySelector('.video-overlay');
                    if (nameOverlay) {
                        nameOverlay.textContent = `${data.userName} (Host)`;
                    }
                }
                
                // If this is us, update our host status
                if (data.userId === signaling.userId) {
                    signaling.isHost = true;
                    document.querySelector('.video-wrapper.local .video-overlay').textContent = 'You (Host)';
                }
            });
            
            // When we receive an offer
            signaling.on('offer', async (data) => {
                if (data.targetUserId === signaling.userId) {
                    console.log(`Received offer from ${data.senderName || data.senderId}`);
                    
                    // Create a peer connection if it doesn't exist
                    let pc = peerConnections[data.senderId];
                    if (!pc) {
                        pc = createPeerConnection(data.senderId, data.senderName || 'Peer');
                    }
                    
                    // Process the remote offer
                    await pc.processRemoteOffer(data.offer);
                }
            });
            
            // When we receive an answer
            signaling.on('answer', async (data) => {
                if (data.targetUserId === signaling.userId) {
                    console.log(`Received answer from ${data.senderId}`);
                    
                    // Get the peer connection
                    const pc = peerConnections[data.senderId];
                    if (pc) {
                        try {
                            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        } catch (error) {
                            console.error('Error handling answer:', error);
                        }
                    }
                }
            });
            
            // When we receive an ICE candidate
            signaling.on('ice-candidate', async (data) => {
                if (data.targetUserId === signaling.userId) {
                    const pc = peerConnections[data.senderId];
                    if (pc) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        } catch (error) {
                            console.error('Error adding ICE candidate:', error);
                        }
                    }
                }
            });
            
            // When a chat message is received
            signaling.on('chat-message', (data) => {
                console.log(`Received ${data.isPrivate ? 'private' : 'chat'} message from ${data.senderName}`);
                
                // In a real app, you would display this in a chat UI
                const isFromMe = data.senderId === signaling.userId;
                const messageText = data.isPrivate 
                    ? `[Private] ${isFromMe ? 'You to ' + data.targetName : data.senderName}: ${data.message}`
                    : `${isFromMe ? 'You' : data.senderName}: ${data.message}`;
                
                // Show notification for incoming messages
                if (!isFromMe) {
                    showParticipantNotification(messageText, 'message');
                }
            });
            
            // When connection state changes
            signaling.on('connection-state-changed', (data) => {
                console.log(`WebSocket connection state changed to: ${data.state}`);
                
                // Update UI based on connection state
                switch (data.state) {
                    case 'connected':
                        statusText.className = 'status-text status-good';
                        break;
                    case 'connecting':
                        statusText.textContent = 'Connecting to server...';
                        statusText.className = 'status-text status-warning';
                        break;
                    case 'disconnected':
                        if (conferenceScreen.style.display !== 'none') {
                            statusText.textContent = 'Disconnected from server';
                            statusText.className = 'status-text status-bad';
                        }
                        break;
                    case 'error':
                    case 'failed':
                        statusText.textContent = 'Connection error';
                        statusText.className = 'status-text status-bad';
                        break;
                }
            });

            // When we receive a room-closed event
            signaling.on('room-closed', (data) => {
                console.log(`Room ${data.roomId} was closed by ${data.hostName || data.hostId}`);
                
                // Check if this is a local closure (we initiated it as host)
                const isLocalClose = data.isLocalClose === true;
                
                // Handle room closure, passing the isLocalClose flag
                handleRoomClosure(`This meeting has been ended by ${data.hostName || 'the host'}`, isLocalClose);
            });
        }

        // Function to create a peer connection with optimized settings for low latency
        function createPeerConnection(userId, userName) {
            console.log(`Creating peer connection for ${userName} (${userId})`);
            const pc = new RTCPeerConnection(configuration);
            
            // Single place to track if we're in the process of negotiating
            pc.isNegotiating = false;
            
            // Add all local tracks to the peer connection
            const senders = {};
            localStream.getTracks().forEach(track => {
                console.log(`Adding ${track.kind} track to peer connection for ${userName}`);
                const sender = pc.addTrack(track, localStream);
                senders[track.kind] = sender;
            });
            
            // Helper method to safely replace video track
            pc.replaceVideoTrack = async (newTrack) => {
                const videoSender = pc.getSenders().find(sender => 
                    sender.track && sender.track.kind === 'video');
                
                if (videoSender) {
                    console.log(`Replacing video track for ${userName}`);
                    return videoSender.replaceTrack(newTrack);
                } else {
                    console.warn(`No video sender found for ${userName}`);
                }
            };
            
            // Add a stable update function for connection stats
            pc.updateConnectionStats = debounce((stats) => {
                const statsDiv = document.getElementById(`stats-${userId}`);
                const indicator = document.getElementById(`indicator-${userId}`);
                
                if (statsDiv && stats) {
                    const { latency, packetLoss, jitter } = stats;
                    
                    // Update stats display only if the connection is established
                    if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                        // Format stats with fixed width to prevent layout shifts
                        statsDiv.textContent = `${latency.toString().padStart(3, ' ')}ms | Loss: ${packetLoss}% | Jitter: ${jitter}ms`;
                    }
                    
                    // Update status indicator
                    if (indicator) {
                        if (latency < 70 && packetLoss < 2) {
                            indicator.className = 'status-indicator';
                        } else if (latency < 150 && packetLoss < 5) {
                            indicator.className = 'status-indicator warning';
                        } else {
                            indicator.className = 'status-indicator error';
                        }
                    }
                }
            }, 500); // Update UI at most every 500ms
            
            // Prevent overlapping negotiations
            pc.addEventListener('signalingstatechange', () => {
                pc.isNegotiating = (pc.signalingState !== 'stable');
                console.log(`Signaling state changed to: ${pc.signalingState} for ${userName}`);
            });
            
            // Handle negotiation
            pc.addEventListener('negotiationneeded', async () => {
                // Prevent concurrent negotiations
                if (pc.isNegotiating) {
                    console.log(`Negotiation already in progress for ${userName}, skipping`);
                    return;
                }
                
                try {
                    pc.isNegotiating = true;
                    console.log(`Starting negotiation with ${userName}`);
                    
                    // Create offer
                    const offer = await pc.createOffer();
                    
                    // Verify signaling state before setting local description
                    if (pc.signalingState !== 'stable') {
                        console.log(`Signaling state changed, aborting negotiation with ${userName}`);
                        pc.isNegotiating = false;
                        return;
                    }
                    
                    // Set local description
                    try {
                        console.log(`Setting local description for ${userName}`);
                    await pc.setLocalDescription(offer);
                        console.log(`Local description set successfully for ${userName}`);
                        
                        // Send the offer
                    window.signaling.sendOffer(userId, pc.localDescription);
                } catch (error) {
                        console.error(`Error setting local description for ${userName}:`, error);
                        
                        // If it's an m-line order issue, try a workaround
                        if (error.name === 'InvalidAccessError' && error.message.includes('m-lines')) {
                            console.warn(`M-line order issue detected with ${userName}, attempting recovery`);
                            
                            // Try creating a new offer with default options
                            try {
                                const newOffer = await pc.createOffer({offerToReceiveAudio: true, offerToReceiveVideo: true});
                                await pc.setLocalDescription(newOffer);
                                window.signaling.sendOffer(userId, pc.localDescription);
                            } catch (recoveryError) {
                                console.error(`Recovery attempt failed for ${userName}:`, recoveryError);
                                throw recoveryError;
                            }
                        } else {
                            throw error;
                        }
                    }
                } catch (error) {
                    console.error(`Negotiation failed with ${userName}:`, error);
                } finally {
                    pc.isNegotiating = false;
                }
            });
            
            // Enhanced handling of remote offer
            pc.processRemoteOffer = async (offer) => {
                try {
                    // If we're in the middle of setting our own local description, wait
                    if (pc.signalingState === 'have-local-offer') {
                        console.log(`Received remote offer while in have-local-offer state for ${userName}, rolling back`);
                        await pc.setLocalDescription({type: 'rollback'});
                    }
                    
                    console.log(`Setting remote description from ${userName}`);
                    await pc.setRemoteDescription(new RTCSessionDescription(offer));
                    
                    // Create and send answer
                    console.log(`Creating answer for ${userName}`);
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    window.signaling.sendAnswer(userId, pc.localDescription);
                } catch (error) {
                    console.error(`Error processing remote offer from ${userName}:`, error);
                }
            };
            
            // Handle ICE candidates
            pc.onicecandidate = event => {
                if (event.candidate) {
                    window.signaling.sendIceCandidate(userId, event.candidate);
                }
            };
            
            // Handle ICE connection state changes
            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state with ${userName}: ${pc.iceConnectionState}`);
                const statsDiv = document.getElementById(`stats-${userId}`);
                
                // Update UI based on ICE state
                if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                    // Start monitoring stats after connection is established
                    startPeerStats(pc, userId);
                    
                    // Update stats display
                    if (statsDiv && statsDiv.textContent.includes('Initializing') || statsDiv.textContent.includes('Connecting')) {
                        statsDiv.textContent = pc.iceConnectionState === 'completed' ? 
                            "Connection Established" : "Connected";
                    }
                    
                    // Remove the connecting class
                    const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                    if (videoWrapper) {
                        videoWrapper.classList.remove('connecting');
                    }
                } else if (pc.iceConnectionState === 'failed') {
                    if (statsDiv) statsDiv.textContent = "ICE Connection Failed";
                } else if (pc.iceConnectionState === 'disconnected') {
                    if (statsDiv) statsDiv.textContent = "ICE Disconnected";
                }
            };
            
            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log(`Connection state with ${userName}: ${pc.connectionState}`);
                const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                const statusIndicator = document.getElementById(`indicator-${userId}`);
                const statsDiv = document.getElementById(`stats-${userId}`);
                
                if (videoWrapper && statusIndicator) {
                    if (pc.connectionState === 'connected') {
                        statusIndicator.className = 'status-indicator';
                        videoWrapper.classList.remove('connecting');
                        if (statsDiv) statsDiv.textContent = "Connected";
                        
                        // Ensure we start stats monitoring
                        startPeerStats(pc, userId);
                        
                        // Check if this is a reconnection during screen sharing
                        if (videoWrapper.classList.contains('screen-sharing')) {
                            console.log(`Connection restored for ${userName} during screen sharing, ensuring camera overlay...`);
                            
                            // Create a sequence of checks at increasing intervals
                            setTimeout(() => pc.restoreScreenShareView(), 500);
                            setTimeout(() => pc.restoreScreenShareView(), 1500);
                            setTimeout(() => pc.restoreScreenShareView(), 3000);
                            
                            // Also trigger the global checking function
                            setTimeout(() => {
                                if (typeof checkAndRestoreScreenShareOverlays === 'function') {
                                    checkAndRestoreScreenShareOverlays();
                                }
                            }, 2000);
                        }
                    } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                        statusIndicator.className = 'status-indicator error';
                        videoWrapper.classList.add('problem');
                        if (statsDiv) statsDiv.textContent = pc.connectionState === 'disconnected' ? "Disconnected" : "Connection Failed";
                    } else if (pc.connectionState === 'connecting') {
                        videoWrapper.classList.add('connecting');
                        if (statsDiv) statsDiv.textContent = "Connecting...";
                    }
                }
            };
            
            // Update the ontrack handler to set initial connection state
            pc.ontrack = event => {
                const stream = event.streams[0];
                const tracks = stream.getTracks();
                
                // Check if we already have a video element for this user
                let videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                let mainVideo, statsDiv, statusIndicator;
                
                if (!videoWrapper) {
                    // Create new elements with fixed dimensions
                    const elements = createPeerVideoElement(userId, userName, pc);
                    videoWrapper = elements.videoWrapper;
                    mainVideo = elements.mainVideo;
                    statsDiv = elements.statsDiv;
                    statusIndicator = elements.statusIndicator;
                    
                    // Update the stats div with current connection state
                    if (pc.connectionState === 'connected') {
                        statsDiv.textContent = 'Connected';
                        videoWrapper.classList.remove('connecting');
                    } else if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                        statsDiv.textContent = 'ICE Connected';
                        videoWrapper.classList.remove('connecting');
                    }
                } else {
                    mainVideo = document.getElementById(`video-${userId}`);
                }
                
                // Get all video tracks
                const videoTracks = tracks.filter(t => t.kind === 'video');
                
                // Check if this is a screen share (2 video tracks)
                if (videoTracks.length === 2) {
                    // Determine which track is screen share based on track settings
                    let screenTrack, cameraTrack;
                    
                    for (const track of videoTracks) {
                        const settings = track.getSettings();
                        // Screen share tracks typically have displaySurface property or larger dimensions
                        if (settings.displaySurface || (settings.width > 1280 && settings.height > 720)) {
                            screenTrack = track;
                        } else {
                            cameraTrack = track;
                        }
                    }
                    
                    // If we couldn't determine which is which, use the first as screen and second as camera
                    if (!screenTrack || !cameraTrack) {
                        screenTrack = videoTracks[0];
                        cameraTrack = videoTracks[1];
                    }
                    
                    // Create screen share stream for main video
                    const screenStream = new MediaStream([screenTrack]);
                    mainVideo.srcObject = screenStream;
                    
                    // Create or update camera overlay
                    let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                    if (!cameraOverlay) {
                        cameraOverlay = document.createElement('div');
                        cameraOverlay.id = `camera-overlay-${userId}`;
                        cameraOverlay.className = 'remote-camera-overlay';
                        
                        const cameraVideo = document.createElement('video');
                        cameraVideo.id = `camera-video-${userId}`;
                        cameraVideo.autoplay = true;
                        cameraVideo.playsInline = true;
                        
                        const nameOverlay = document.createElement('div');
                        nameOverlay.className = 'video-overlay';
                        nameOverlay.textContent = userName;
                        
                        cameraOverlay.appendChild(cameraVideo);
                        cameraOverlay.appendChild(nameOverlay);
                        videoWrapper.appendChild(cameraOverlay);
                    }
                    
                    // Set camera stream - create a fresh stream to ensure it's properly connected
                    const cameraStream = new MediaStream([cameraTrack]);
                    const cameraVideo = document.getElementById(`camera-video-${userId}`);
                    
                    if (cameraVideo) {
                        // If we have an existing camera video element, update it
                        cameraVideo.srcObject = cameraStream;
                        
                        // Ensure it plays
                        cameraVideo.play().catch(e => console.warn(`Failed to play camera video: ${e.message}`));
                    }
                    
                    // Add class to indicate remote camera is attached
                    videoWrapper.classList.add('has-remote-camera');
                    videoWrapper.classList.add('screen-sharing');
                    
                    // Ensure camera overlay is visible with stronger force
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;
                    
                    // Update disabled state for camera
                    if (!cameraTrack.enabled) {
                        cameraOverlay.classList.add('camera-disabled');
                    } else {
                        cameraOverlay.classList.remove('camera-disabled');
                    }
                    
                    // Listen for enabled/disabled state changes
                    cameraTrack.onmute = () => cameraOverlay.classList.add('camera-disabled');
                    cameraTrack.onunmute = () => cameraOverlay.classList.remove('camera-disabled');
                    
                    // Log successful setup
                    console.log(`Successfully set up screen sharing with camera for ${userName}`);
                    
                    // Trigger another check in 1 second to ensure everything is visible
                    setTimeout(() => {
                        if (typeof checkAndRestoreScreenShareOverlays === 'function') {
                            checkAndRestoreScreenShareOverlays();
                        }
                    }, 1000);
                } else {
                    // Regular video call - single video track
                    mainVideo.srcObject = stream;
                    videoWrapper.classList.remove('screen-sharing');
                    
                    // Remove camera overlay if exists
                    const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                    if (cameraOverlay) {
                        cameraOverlay.remove();
                    }
                }
                
                // Apply settings for low latency playback
                mainVideo.addEventListener('canplay', () => {
                    mainVideo.play().catch(e => console.error('Error playing video:', e));
                    
                    // Update stats when video starts playing
                    const statsDiv = document.getElementById(`stats-${userId}`);
                    if (statsDiv && statsDiv.textContent === 'Initializing...') {
                        statsDiv.textContent = 'Video Playing';
                    }
                });
            };
            
            // Handle track removal (disconnection/leaving)
            pc.onremovetrack = event => {
                console.log(`Track removed: ${event.track.kind} from ${userName}`);
            };
            
            // Handle reconnection for screen share with camera overlay
            pc.restoreScreenShareView = () => {
                const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                
                if (videoWrapper && videoWrapper.classList.contains('screen-sharing') && cameraOverlay) {
                    // Ensure camera overlay is visible on reconnection
                    videoWrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.display = 'flex';
                    cameraOverlay.style.visibility = 'visible';
                    cameraOverlay.style.opacity = '1';
                    console.log(`Restored camera overlay for ${userName}`);
                }
            };
            
            // Add reconnection check when connection state becomes connected
            const originalOnConnectionStateChange = pc.onconnectionstatechange;
            pc.onconnectionstatechange = () => {
                // Call the original handler
                if (originalOnConnectionStateChange) {
                    originalOnConnectionStateChange();
                }
                
                // Additional logic for reconnection with screen share
                if (pc.connectionState === 'connected') {
                    // Restore screen share view if needed
                    setTimeout(() => {
                        pc.restoreScreenShareView();
                    }, 1000); // Small delay to ensure all streams are processed
                }
            };
            
            // Store peer connection
            peerConnections[userId] = pc;
            return pc;
        }

        // Helper function to create video elements for peers with consistent styling
        function createPeerVideoElement(userId, userName, pc) {
            console.log(`Creating video element for ${userName} (${userId})`);
            
            // Create container
            const videoWrapper = document.createElement('div');
            videoWrapper.id = `video-wrapper-${userId}`;
            videoWrapper.className = 'video-wrapper connecting entering';
            
            // Create video element
            const video = document.createElement('video');
            video.id = `video-${userId}`;
            video.autoplay = true;
            video.playsInline = true;
            
            // Create name overlay
            const nameOverlay = document.createElement('div');
            nameOverlay.className = 'video-overlay';
            nameOverlay.textContent = userName;
            
            // Create status indicator
            const statusIndicator = document.createElement('div');
            statusIndicator.id = `indicator-${userId}`;
            statusIndicator.className = 'status-indicator';
            
            // Create stats overlay with fixed initial content to prevent layout shifts
            const statsOverlay = document.createElement('div');
            statsOverlay.id = `stats-${userId}`;
            statsOverlay.className = 'video-overlay stats';
            statsOverlay.textContent = 'Initializing...';
            
            // Create reconnection indicator
            const reconnectingIndicator = document.createElement('div');
            reconnectingIndicator.className = 'reconnecting-indicator';
            
            // Assemble video wrapper
            videoWrapper.appendChild(video);
            videoWrapper.appendChild(nameOverlay);
            videoWrapper.appendChild(statusIndicator);
            videoWrapper.appendChild(statsOverlay);
            videoWrapper.appendChild(reconnectingIndicator);
            
            // Add to video container
            videoContainer.appendChild(videoWrapper);
            
            // Remove the entering class after animation completes
            setTimeout(() => {
                videoWrapper.classList.remove('entering');
            }, 600);
            
            return {
                videoWrapper,
                mainVideo: video,
                statsDiv: statsOverlay,
                statusIndicator
            };
        }

        // Helper function to enforce original m-line order (if needed for debugging)
        function enforceOriginalMLineOrder(sdp, originalOrder) {
            const sections = splitSdpIntoSections(sdp);
            if (sections.length <= 1) return sdp; // Return original if no media sections
            
            const sessionLevel = sections[0];
            const mediaLines = sections.slice(1);
            const orderedMediaLines = [];
            
            // First, add media sections in the original order
            originalOrder.forEach(({kind}) => {
                const mediaSection = mediaLines.find(section => {
                    const mLine = section.split('\r\n')[0];
                    return mLine.startsWith(`m=${kind}`);
                });
                
                if (mediaSection) {
                    orderedMediaLines.push(mediaSection);
                    mediaLines.splice(mediaLines.indexOf(mediaSection), 1);
                }
            });
            
            // Add any remaining media sections at the end
            orderedMediaLines.push(...mediaLines);
            
            // Reconstruct SDP with proper line endings
            return sessionLevel + '\r\n' + orderedMediaLines.join('\r\n') + '\r\n';
        }

        // Helper function to split SDP into sections
        function splitSdpIntoSections(sdp) {
            const lines = sdp.split('\r\n');
            const sections = [];
            let currentSection = [];
            
            lines.forEach(line => {
                if (line.startsWith('m=')) {
                    if (currentSection.length > 0) {
                        sections.push(currentSection.join('\r\n'));
                        currentSection = [];
                    }
                }
                currentSection.push(line);
            });
            
            if (currentSection.length > 0) {
                sections.push(currentSection.join('\r\n'));
            }
            
            return sections;
        }

        // Check for existing participants
        function checkExistingParticipants(roomId) {
            // In a real application, you would query the server
            // For this demo, we'll manually broadcast our presence again
            setTimeout(() => {
                window.signaling.joinRoom(roomId);
            }, 1000);
        }

        // Initialize network monitoring
        function initializeNetworkMonitoring() {
            // Create a connection quality observer
            window.connectionQuality = {
                latencies: [],
                packetsLost: 0,
                lastPacketsTotal: 0,
                jitter: 0,
                bandwidth: 0
            };
        }

        // Start monitoring network statistics
        function startNetworkMonitoring() {
            // Clear any existing interval
            if (statsInterval) {
                clearInterval(statsInterval);
            }
            
            // Update stats every second
            statsInterval = setInterval(updateNetworkStats, 1000);
        }

        // Start collecting statistics for a specific peer
        function startPeerStats(pc, userId) {
            if (!pc) return;
            
            // Collect stats every second
            const statsDiv = document.getElementById(`stats-${userId}`);
            const indicator = document.getElementById(`indicator-${userId}`);
            
            if (statsDiv && indicator) {
                // Clear any existing interval for this peer
                if (pc.statsIntervalId) {
                    clearInterval(pc.statsIntervalId);
                }
                
                // Initialize with stable content to prevent layout shifts
                if (statsDiv.textContent === 'Initializing...') {
                    statsDiv.textContent = 'Measuring...';
                }
                
                let lastStats = {
                    latency: 0,
                    packetLoss: 0,
                    jitter: 0
                };
                
                const getStats = async () => {
                    try {
                        const stats = await pc.getStats();
                        let inboundRtp = null;
                        let remoteOutbound = null;
                        let candidatePair = null;
                        
                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                inboundRtp = report;
                            } else if (report.type === 'remote-outbound-rtp' && report.kind === 'video') {
                                remoteOutbound = report;
                            } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                candidatePair = report;
                            }
                        });
                        
                        if (inboundRtp) {
                            let latency = 0;
                            let jitter = inboundRtp.jitter ? Math.round(inboundRtp.jitter * 1000) : 0;
                            let packetLoss = 0;
                            
                            if (remoteOutbound && remoteOutbound.timestamp && inboundRtp.timestamp) {
                                latency = Math.round(inboundRtp.timestamp - remoteOutbound.timestamp);
                            } else if (candidatePair && candidatePair.currentRoundTripTime) {
                                latency = Math.round(candidatePair.currentRoundTripTime * 1000);
                            }
                            
                            if (inboundRtp.packetsLost !== undefined && inboundRtp.packetsReceived !== undefined) {
                                const totalPackets = inboundRtp.packetsLost + inboundRtp.packetsReceived;
                                if (totalPackets > 0) {
                                    packetLoss = Math.round((inboundRtp.packetsLost / totalPackets) * 100);
                                }
                            }
                            
                            // Only update if values changed significantly to prevent UI flicker
                            const hasSignificantChange = 
                                Math.abs(latency - lastStats.latency) > 5 ||
                                Math.abs(packetLoss - lastStats.packetLoss) > 1 ||
                                Math.abs(jitter - lastStats.jitter) > 5;
                            
                            if (hasSignificantChange) {
                                lastStats = { latency, packetLoss, jitter };
                                
                                // Update stats with debounce to prevent flickering
                                if (pc.updateConnectionStats) {
                                    pc.updateConnectionStats({
                                        latency,
                                        packetLoss,
                                        jitter
                                    });
                                }
                                
                                // Update the global status text (debounced)
                                debounceUpdateConnectionStatus(latency, packetLoss);
                            }
                        }
                    } catch (e) {
                        console.error('Error getting stats:', e);
                    }
                };
                
                // Get stats immediately and then on an interval
                getStats();
                pc.statsIntervalId = setInterval(getStats, 1000);
            }
        }

        // Update network statistics with real measurements if possible
        function updateNetworkStats() {
            const localIndicator = document.querySelector('.video-wrapper.local .status-indicator');
            
            // Use real stats if available, otherwise simulate
            if (Object.keys(peerConnections).length > 0) {
                const pc = Object.values(peerConnections)[0];
                
                if (pc && pc.connectionState === 'connected') {
                    pc.getStats().then(stats => {
                        let outboundRtp = null;
                        let candidatePair = null;
                        
                        stats.forEach(report => {
                            if (report.type === 'outbound-rtp' && report.kind === 'video') {
                                outboundRtp = report;
                            } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                candidatePair = report;
                            }
                        });
                        
                        if (candidatePair) {
                            const latency = Math.round(candidatePair.currentRoundTripTime * 1000);
                            let bandwidth = 'Unknown';
                            
                            if (outboundRtp && outboundRtp.bytesSent) {
                                const bytesSent = outboundRtp.bytesSent;
                                
                                if (window.lastBytesSent && window.lastTimestamp) {
                                    const byteDiff = bytesSent - window.lastBytesSent;
                                    const timeDiff = outboundRtp.timestamp - window.lastTimestamp;
                                    const kbps = Math.round((byteDiff * 8) / timeDiff);
                                    bandwidth = `${kbps} kbps`;
                                }
                                
                                window.lastBytesSent = bytesSent;
                                window.lastTimestamp = outboundRtp.timestamp;
                            }
                            
                            // Update local stats
                            localStats.textContent = `Latency: ${latency}ms | BW: ${bandwidth}`;
                            
                            // Update connection status
                            if (latency < 70) {
                                statusText.textContent = `Connected (${latency}ms)`;
                                statusText.className = 'status-text status-good';
                                localIndicator.className = 'status-indicator';
                            } else if (latency < 120) {
                                statusText.textContent = `Connected (${latency}ms)`;
                                statusText.className = 'status-text status-warning';
                                localIndicator.className = 'status-indicator warning';
                            } else {
                                statusText.textContent = `Connected (${latency}ms)`;
                                statusText.className = 'status-text status-bad';
                                localIndicator.className = 'status-indicator error';
                            }
                            
                            return;
                        }
                    }).catch(e => {
                        console.error('Error getting stats:', e);
                        simulateNetworkStats();
                    });
                } else {
                    simulateNetworkStats();
                }
            } else {
                simulateNetworkStats();
            }
        }
        
        // Fallback to simulation when real stats aren't available
        function simulateNetworkStats() {
            // Simulate better latency for the demo (20-50ms range)
            const latency = Math.floor(Math.random() * (50 - 20 + 1)) + 20;
            localStats.textContent = `Latency: ${latency}ms`;
            
            // Update connection status based on latency
            const localIndicator = document.querySelector('.video-wrapper.local .status-indicator');
            
            if (latency < 35) {
                statusText.textContent = `Connected (${latency}ms)`;
                statusText.className = 'status-text status-good';
                localIndicator.className = 'status-indicator';
            } else if (latency < 70) {
                statusText.textContent = `Connected (${latency}ms)`;
                statusText.className = 'status-text status-good';
                localIndicator.className = 'status-indicator';
            } else {
                statusText.textContent = `Connected (${latency}ms)`;
                statusText.className = 'status-text status-warning';
                localIndicator.className = 'status-indicator warning';
            }
        }

        // Add a helper function to update the overall connection status
        function updateConnectionStatus(latency, packetLoss) {
            if (!statusText) return;
            
            // Format text with consistent length
            const formattedLatency = latency.toString().padStart(3, ' ');
            
            if (latency < 70 && packetLoss < 2) {
                statusText.textContent = `Connected (${formattedLatency}ms)`;
                statusText.className = 'status-text status-good';
            } else if (latency < 150 && packetLoss < 5) {
                statusText.textContent = `Connected (${formattedLatency}ms)`;
                statusText.className = 'status-text status-warning';
            } else {
                statusText.textContent = `Connected (${formattedLatency}ms)`;
                statusText.className = 'status-text status-bad';
            }
        }

        // Add smooth transitions when the application initializes
        function addSmoothTransitions() {
            const style = document.createElement('style');
            style.textContent = `
                .video-wrapper {
                    transition: all 0.3s ease-out;
                }
                .video-overlay {
                    transition: background-color 0.3s ease-out, color 0.3s ease-out;
                }
                .status-indicator {
                    transition: background-color 0.3s ease-out;
                }
                .status-text {
                    transition: background-color 0.3s ease-out, color 0.3s ease-out;
                }
            `;
            document.head.appendChild(style);
        }

        // Initialize the application
        function initialize() {
            // Initialize DOM references once at startup
            window.domReferences = {
                localVideoInitialized: false,
                ensureReferences: function() {
                    // This will be called when elements are created to ensure references exist
                    const videoEl = document.getElementById('localVideo');
                    const statsEl = document.getElementById('localStats');
                    
                    // Only update references if the elements exist in the DOM
                    if (videoEl) {
                        localVideo = videoEl;
                    }
                    if (statsEl) {
                        localStats = statsEl;
                    }
                    
                    window.domReferences.localVideoInitialized = true;
                }
            };
            
            // Initial reference setup
            window.domReferences.ensureReferences();
            
            // Set up event listeners
            joinRoomForm.addEventListener('submit', joinRoom);
            copyRoomIdButton.addEventListener('click', copyRoomId);
            toggleAudioButton.addEventListener('click', toggleAudio);
            toggleVideoButton.addEventListener('click', toggleVideo);
            shareScreenButton.addEventListener('click', toggleScreenShare);
            
            // Make sure the leave call button has a proper event listener
            if (leaveCallButton) {
                console.log('Setting up leave call button event listener');
                // Remove any existing event listeners to prevent duplicates
                leaveCallButton.removeEventListener('click', leaveCall);
                // Add the event listener
                leaveCallButton.addEventListener('click', function(e) {
                    console.log('Leave call button clicked');
                    e.preventDefault();
                    leaveCall();
                });
            } else {
                console.error('Leave call button not found in the DOM');
            }
            
            // Initialize network monitoring
            initializeNetworkMonitoring();
            
            // Add smooth transitions
            addSmoothTransitions();
            
            // Hide conference screen initially
            conferenceScreen.style.display = 'none';
            
            // Check if room ID is in URL
            const urlParams = new URLSearchParams(window.location.search);
            const roomIdFromUrl = urlParams.get('room');
            if (roomIdFromUrl) {
                roomIdInput.value = roomIdFromUrl;
            }
            
            // Add event listeners for DOM changes
            // This ensures our references stay up to date when elements are recreated
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        // When elements are added to the DOM, check if we need to update references
                        setTimeout(function() {
                            window.domReferences.ensureReferences();
                        }, 0);
                    }
                });
            });
            
            // Start observing the document with the configured parameters
            observer.observe(document.body, { childList: true, subtree: true });
        }

        // Initialize the application
        initialize();

        // Add debounce function to prevent too frequent UI updates
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        // Create a debounced version of the updateConnectionStatus function
        const debounceUpdateConnectionStatus = debounce(updateConnectionStatus, 500);

        // Add a function to check and restore screen share camera overlays
        function checkAndRestoreScreenShareOverlays() {
            // Look for all screen sharing video wrappers
            const screenShareWrappers = document.querySelectorAll('.video-wrapper.screen-sharing');
            
            screenShareWrappers.forEach(wrapper => {
                const userId = wrapper.id.replace('video-wrapper-', '');
                const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                
                if (cameraOverlay) {
                    // Ensure the camera overlay is visible
                    wrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.display = 'flex';
                    cameraOverlay.style.visibility = 'visible';
                    cameraOverlay.style.opacity = '1';
                    console.log(`Automatically restored camera overlay for user ${userId}`);
                }
            });
        }
        
        // Call the restore function when room is joined
        window.addEventListener('roomJoined', () => {
            // Give a short delay to allow all connections to establish
            setTimeout(() => {
                // Activate ongoing monitoring for screen shares
                setupScreenShareMonitoring();
            }, 2000);
        });

        // Add a more robust periodic checking mechanism for screen share camera overlays
        function setupScreenShareMonitoring() {
            // Initial check
            checkAndRestoreScreenShareOverlays();
            
            // Set up a periodic check every 3 seconds
            const monitoringInterval = setInterval(() => {
                // Only run the check if we're in a conference
                if (conferenceScreen.style.display !== 'none') {
                    checkAndRestoreScreenShareOverlays();
                } else {
                    // Clear the interval if we're not in a conference
                    clearInterval(monitoringInterval);
                }
            }, 3000);
            
            // Store the interval ID so it can be cleared if needed
            window.screenShareMonitoringInterval = monitoringInterval;
        }
        
        // Enhanced function to check and restore screen share overlays
        function checkAndRestoreScreenShareOverlays() {
            // Look for all screen sharing video wrappers
            const screenShareWrappers = document.querySelectorAll('.video-wrapper.screen-sharing');
            
            // If no screen sharing is happening, nothing to do
            if (screenShareWrappers.length === 0) {
                return;
            }
            
            console.log(`Checking ${screenShareWrappers.length} screen sharing wrappers for camera overlays...`);
            
            screenShareWrappers.forEach(wrapper => {
                const userId = wrapper.id.replace('video-wrapper-', '');
                let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                
                // Check if we have a peer connection for this user
                const pc = peerConnections[userId];
                
                if (!cameraOverlay && pc) {
                    console.log(`Camera overlay missing for screen sharing user ${userId}, attempting to recreate it...`);
                    
                    // Attempt to create the missing camera overlay
                    createMissingCameraOverlay(userId, wrapper, pc);
                } else if (cameraOverlay) {
                    // Ensure the camera overlay is visible and properly styled
                    wrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.display = 'flex';
                    cameraOverlay.style.visibility = 'visible';
                    cameraOverlay.style.opacity = '1';
                    
                    // Also check if the video element inside is working
                    const cameraVideo = document.getElementById(`camera-video-${userId}`);
                    if (cameraVideo && (!cameraVideo.srcObject || !cameraVideo.srcObject.active)) {
                        console.log(`Camera video feed missing for user ${userId}, attempting to restore...`);
                        attemptToRestoreCameraFeed(userId, pc, cameraVideo);
                    }
                }
            });
        }
        
        // Function to create a missing camera overlay for a screen share
        function createMissingCameraOverlay(userId, videoWrapper, pc) {
            // Get the user name
            const userName = getUserNameFromUserId(userId) || 'User';
            
            // Create the camera overlay
            const cameraOverlay = document.createElement('div');
            cameraOverlay.id = `camera-overlay-${userId}`;
            cameraOverlay.className = 'remote-camera-overlay';
            cameraOverlay.style.display = 'flex';
            cameraOverlay.style.visibility = 'visible';
            cameraOverlay.style.opacity = '1';
            
            // Create the camera video element
            const cameraVideo = document.createElement('video');
            cameraVideo.id = `camera-video-${userId}`;
            cameraVideo.autoplay = true;
            cameraVideo.playsInline = true;
            
            // Create the name overlay
            const nameOverlay = document.createElement('div');
            nameOverlay.className = 'video-overlay';
            nameOverlay.textContent = userName;
            
            // Add elements to the overlay
            cameraOverlay.appendChild(cameraVideo);
            cameraOverlay.appendChild(nameOverlay);
            videoWrapper.appendChild(cameraOverlay);
            
            // Add class to indicate remote camera is attached
            videoWrapper.classList.add('has-remote-camera');
            
            // Try to find camera track from the peer connection
            if (pc && pc.getReceivers) {
                // Look through receivers for a video track that's not the screen share
                pc.getReceivers().forEach(receiver => {
                    if (receiver.track && receiver.track.kind === 'video') {
                        // Get track settings to determine if it's a camera or screen
                        const settings = receiver.track.getSettings();
                        
                        // This is likely the camera track if it's smaller than typical screen share
                        if (!settings.displaySurface && (!settings.width || settings.width <= 1280)) {
                            const cameraStream = new MediaStream([receiver.track]);
                            cameraVideo.srcObject = cameraStream;
                            console.log(`Restored camera feed for user ${userId} from existing track`);
                            
                            // Set disabled state if track is muted
                            if (!receiver.track.enabled) {
                                cameraOverlay.classList.add('camera-disabled');
                            }
                        }
                    }
                });
            }
            
            return cameraOverlay;
        }
        
        // Function to try to restore a camera feed for an existing overlay
        function attemptToRestoreCameraFeed(userId, pc, cameraVideo) {
            if (pc && pc.getReceivers) {
                // Get all video tracks from the peer connection
                const videoReceivers = pc.getReceivers().filter(r => 
                    r.track && r.track.kind === 'video');
                
                if (videoReceivers.length >= 2) {
                    // If we have 2+ video tracks, the smaller one is likely the camera
                    let cameraTrack = null;
                    
                    for (const receiver of videoReceivers) {
                        const settings = receiver.track.getSettings();
                        // This is likely the camera track if it's smaller
                        if (!settings.displaySurface && (!settings.width || settings.width <= 1280)) {
                            cameraTrack = receiver.track;
                            break;
                        }
                    }
                    
                    // If we still couldn't determine, use the second video track
                    if (!cameraTrack && videoReceivers.length >= 2) {
                        cameraTrack = videoReceivers[1].track;
                    }
                    
                    if (cameraTrack) {
                        const cameraStream = new MediaStream([cameraTrack]);
                        cameraVideo.srcObject = cameraStream;
                        console.log(`Restored camera feed for user ${userId} from receiver`);
                        
                        // Update disabled state
                        const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                        if (cameraOverlay) {
                            if (!cameraTrack.enabled) {
                                cameraOverlay.classList.add('camera-disabled');
                            } else {
                                cameraOverlay.classList.remove('camera-disabled');
                            }
                        }
                        
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Helper function to get a user name from user ID
        function getUserNameFromUserId(userId) {
            // Try to find the username in video overlays
            const overlays = document.querySelectorAll('.video-overlay');
            for (const overlay of overlays) {
                const wrapper = overlay.closest('.video-wrapper');
                if (wrapper && wrapper.id === `video-wrapper-${userId}`) {
                    return overlay.textContent;
                }
            }
            return null;
        }

        // Add touch event handlers for better mobile responsiveness
        toggleAudioButton.addEventListener('touchstart', function(e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.add('touch-active'); // Visual feedback
        }, { passive: false });

        toggleAudioButton.addEventListener('touchend', function(e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.remove('touch-active');
            toggleAudio(); // Call the toggle function
        }, { passive: false });

        toggleVideoButton.addEventListener('touchstart', function(e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.add('touch-active'); // Visual feedback
        }, { passive: false });

        toggleVideoButton.addEventListener('touchend', function(e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.remove('touch-active');
            toggleVideo(); // Call the toggle function
        }, { passive: false });

        // Also add touch events for the other buttons for consistency
        shareScreenButton.addEventListener('touchstart', function(e) {
            e.preventDefault();
            this.classList.add('touch-active');
        }, { passive: false });

        shareScreenButton.addEventListener('touchend', function(e) {
            e.preventDefault();
            this.classList.remove('touch-active');
            toggleScreenShare();
        }, { passive: false });

        leaveCallButton.addEventListener('touchstart', function(e) {
            e.preventDefault();
            this.classList.add('touch-active');
        }, { passive: false });

        leaveCallButton.addEventListener('touchend', function(e) {
            e.preventDefault();
            this.classList.remove('touch-active');
            leaveCall();
        }, { passive: false });

        // Add device detection on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Add device-specific classes to HTML element
            const htmlElement = document.documentElement;
            
            if (isMobileDevice()) {
                htmlElement.classList.add('mobile');
                
                if (isIOSDevice()) {
                    htmlElement.classList.add('ios');
                    // Hide screen share button on iOS since it's not supported
                    const shareScreenButton = document.getElementById('shareScreen');
                    if (shareScreenButton) {
                        shareScreenButton.style.display = 'none';
                    }
                } else if (isAndroidDevice()) {
                    htmlElement.classList.add('android');
                }
            } else {
                htmlElement.classList.add('desktop');
            }
        });
    </script>
</body>
</html>