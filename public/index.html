<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="FastMeet - Ultra low latency video conferencing with high quality">
    <link rel="icon" href="/icons/favicon.svg" type="image/svg+xml">
    <link rel="alternate icon" href="/icons/favicon.png" type="image/png">
    <link rel="shortcut icon" href="/icons/favicon.png">
    <link rel="apple-touch-icon" href="/icons/favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500&family=Roboto:wght@300;400;500&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <title>FastMeet - Ultra Low Latency Video Conferencing</title>
    <style>
        /* Google Meet inspired styles */
        body {
            font-family: 'Google Sans', 'Roboto', sans-serif;
            background: #202124;
            color: #fff;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        .meet-controls {
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 32px;
            padding: 8px;
            gap: 8px;
        }

        .meet-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #3c4043;
            color: #fff;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .meet-button:hover {
            background: #5f6368;
        }

        .meet-button.leave {
            background: #ea4335;
            position: relative;
            overflow: visible;
        }

        .meet-button.leave::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            background: transparent;
            border: 2px solid #ea4335;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .meet-button.leave:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .meet-button.leave:hover::before {
            opacity: 0.5;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }

            70% {
                transform: scale(1.1);
                opacity: 0;
            }

            100% {
                transform: scale(1.1);
                opacity: 0;
            }
        }

        .meet-button.active {
            background: #ea4335;
        }

        .meet-info {
            position: fixed;
            top: 24px;
            left: 24px;
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 16px;
            color: #fff;
            z-index: 100;
        }

        .status-text {
            position: fixed;
            top: 24px;
            right: 24px;
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 16px;
            color: #fff;
            z-index: 100;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
            min-height: 20px;
            box-sizing: border-box;
        }

        .status-text::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: block;
        }

        .status-text.status-good::before {
            background: #34a853;
        }

        .status-text.status-warning::before {
            background: #fbbc04;
        }

        .status-text.status-bad::before {
            background: #ea4335;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 8px;
            padding: 16px;
            height: calc(100vh - 100px);
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
                height: calc(100vh - 120px);
                padding: 8px;
            }

            .meet-controls {
                padding: 6px;
                gap: 4px;
            }

            .meet-button {
                width: 36px;
                height: 36px;
            }

            .status-text {
                top: 12px;
                right: 12px;
                font-size: 12px;
                min-width: 150px;
                padding: 10px;
            }

            .meet-info {
                top: 12px;
                left: 12px;
                padding: 10px;
                font-size: 12px;
                max-width: calc(50% - 24px);
            }

            .meet-info .flex {
                flex-wrap: wrap;
                gap: 6px;
            }

            .meet-info code {
                max-width: 100%;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            #copyRoomId {
                padding: 4px 8px;
                margin-top: 4px;
                min-height: 30px;
                min-width: 50px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            #copyRoomId:active {
                transform: scale(0.95);
            }

            /* Add a mobile-specific room ID tooltip */
            @media (max-width: 480px) {
                .meet-info code:active {
                    white-space: normal;
                    word-break: break-all;
                    background: rgba(255, 255, 255, 0.2);
                }

                #copyRoomId:active {
                    background: rgba(138, 180, 248, 0.4);
                }
            }

            h1.text-2xl {
                font-size: 1.25rem;
            }

            .join-form {
                width: 90%;
                max-width: 320px;
            }

            .meet-input {
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .video-grid {
                grid-template-columns: 1fr;
                padding: 4px;
                gap: 4px;
            }

            .meet-controls {
                bottom: 4px;
                padding: 4px;
                gap: 2px;
            }

            .meet-button {
                width: 32px;
                height: 32px;
            }

            .meet-button svg {
                width: 20px;
                height: 20px;
            }

            .video-overlay {
                bottom: 8px;
                left: 8px;
                font-size: 11px;
            }

            .status-text,
            .meet-info {
                padding: 8px;
                font-size: 11px;
            }

            .meet-info {
                max-width: calc(60% - 16px);
            }

            .meet-info .flex {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }

            #copyRoomId {
                margin-top: 2px;
                padding: 4px 8px;
                background: rgba(138, 180, 248, 0.2);
                border-radius: 4px;
                width: 100%;
                text-align: center;
            }
        }

        @media (orientation: landscape) and (max-height: 480px) {
            .video-grid {
                height: calc(100vh - 60px);
            }

            .meet-controls {
                bottom: 2px;
            }

            .video-wrapper {
                height: calc(100vh - 70px);
                aspect-ratio: auto;
            }
        }

        /* Portrait orientation for mobile */
        @media (orientation: portrait) and (max-width: 480px) {
            .camera-overlay {
                width: 80px;
                height: 120px;
                bottom: 70px;
                right: 8px;
            }
        }

        .video-wrapper {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: #3c4043;
            aspect-ratio: 16/9;
        }

        .video-wrapper.local {
            border: 2px solid #8ab4f8;
        }

        .video-wrapper video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-overlay {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(32, 33, 36, 0.6);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            color: #fff;
            z-index: 10;
        }

        .video-overlay.stats {
            bottom: 56px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            min-height: 18px;
            min-width: 120px;
            padding: 4px 8px;
            box-sizing: border-box;
        }

        .video-overlay.stats::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #34a853;
            border-radius: 50%;
            display: block;
        }

        .status-indicator {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #34a853;
        }

        .join-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100%;
            background: #202124;
            gap: 24px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        .join-form {
            background: rgba(60, 64, 67, 0.3);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }

        .meet-input {
            width: 100%;
            padding: 12px;
            background: rgba(32, 33, 36, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: #fff;
            margin-bottom: 16px;
        }

        .meet-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .join-button {
            width: 100%;
            padding: 12px;
            background: #1a73e8;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .join-button:hover {
            background: #1557b0;
        }

        /* Keep existing animation styles */
        @keyframes ping {

            75%,
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        @keyframes fadeScale {
            from {
                opacity: 0;
                transform: scale(0.98);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .fade-scale {
            animation: fadeScale 0.5s ease-out forwards;
        }

        .video-wrapper.screen-sharing {
            position: relative;
        }

        .video-wrapper.screen-sharing video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .camera-overlay {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid #8ab4f8;
            z-index: 1000;
            background: #3c4043;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            justify-content: center;
            transform: scale(1);
        }

        .camera-overlay.active {
            display: flex;
        }

        .camera-overlay video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            min-width: 100%;
            min-height: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .camera-overlay:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }

        .camera-overlay .video-overlay {
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 2;
        }

        /* Comprehensive responsive camera overlay styles */
        /* Large tablets and small desktops */
        @media (max-width: 1200px) {
            .camera-overlay {
                width: 160px;
                height: 160px;
                bottom: 24px;
                right: 24px;
            }
        }

        /* Tablets */
        @media (max-width: 992px) {
            .camera-overlay {
                width: 140px;
                height: 140px;
                bottom: 24px;
                right: 20px;
            }
        }

        /* Small tablets */
        @media (max-width: 768px) {
            .camera-overlay {
                width: 120px;
                height: 120px;
                bottom: 65px;
                right: 15px;
            }
        }

        /* Large phones */
        @media (max-width: 576px) {
            .camera-overlay {
                width: 100px;
                height: 100px;
                bottom: 60px;
                right: 10px;
                border-width: 2px;
            }

            .camera-overlay .video-overlay {
                font-size: 10px;
                padding: 3px 6px;
            }
        }

        /* Small phones */
        @media (max-width: 480px) {
            .camera-overlay {
                width: 80px;
                height: 80px;
                bottom: 55px;
                right: 8px;
            }

            /* Make buttons more touch-friendly on small screens */
            .meet-button {
                touch-action: manipulation;
                min-width: 44px;
                /* Minimum touch target size */
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Optimize join form for mobile */
            .join-form {
                padding: 16px;
            }

            .meet-input {
                padding: 10px;
                font-size: 14px;
                height: 44px;
                /* Minimum touch target height */
            }

            .join-button {
                padding: 10px;
                height: 44px;
                /* Minimum touch target height */
            }

            /* Fix video grid layout on very small screens */
            .video-grid {
                grid-template-columns: 1fr;
            }

            /* Improve notification positioning */
            .notification {
                width: 90%;
                max-width: 300px;
                padding: 8px;
                font-size: 12px;
            }
        }

        /* Portrait orientation-specific adjustments */
        @media (orientation: portrait) {
            /* Medium to large phones in portrait */
            @media (max-width: 576px) and (min-width: 481px) {
                .camera-overlay {
                    width: 90px;
                    height: 90px;
                    bottom: 65px;
                }
            }

            /* Small phones in portrait */
            @media (max-width: 480px) {
                .camera-overlay {
                    width: 70px;
                    height: 70px;
                    border-width: 2px;
                }
            }
        }

        /* Landscape orientation-specific adjustments */
        @media (orientation: landscape) {

            /* Regular landscape mode */
            .camera-overlay {
                bottom: 65px;
            }

            /* Small landscape mode (like phones) */
            @media (max-height: 480px) {
                .camera-overlay {
                    width: 70px;
                    height: 70px;
                    bottom: 55px;
                    right: 10px;
                    border-width: 2px;
                }

                .camera-overlay .video-overlay {
                    font-size: 9px;
                    padding: 2px 4px;
                    bottom: 4px;
                }

                /* Join form adjustments for landscape */
                .join-screen {
                    padding: 10px;
                }

                .join-form {
                    padding: 12px;
                    max-width: 350px;
                }

                .meet-input,
                .join-button {
                    margin-bottom: 8px;
                    height: 40px;
                }
            }

            /* Very small height (like iPhone in landscape) */
            @media (max-height: 380px) {
                .camera-overlay {
                    width: 60px;
                    height: 60px;
                    bottom: 45px;
                    right: 8px;
                }
            }
        }

        /* Ensure camera-overlay doesn't block controls on very small screens */
        @media (max-width: 480px) and (max-height: 480px) {
            .camera-overlay {
                bottom: 50px;
            }
        }

        .remote-camera-overlay {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid #8ab4f8;
            background: #3c4043;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remote-camera-overlay video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            min-width: 100%;
            min-height: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .remote-camera-overlay .video-overlay {
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 2;
        }

        /* Styles for disabled camera during screen sharing */
        .camera-overlay.camera-disabled::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }

        .camera-overlay.camera-disabled::after {
            content: 'Camera Off';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            z-index: 6;
            text-align: center;
            width: 100%;
        }

        /* Add style for remote camera disabled as well */
        .remote-camera-overlay.camera-disabled::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }

        .remote-camera-overlay.camera-disabled::after {
            content: 'Camera Off';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            z-index: 6;
            text-align: center;
            width: 100%;
        }

        /* Add CSS to improve transitions */
        .video-wrapper {
            transition: all 0.3s ease-out;
        }

        .video-overlay {
            transition: background-color 0.3s ease-out, color 0.3s ease-out;
        }

        .status-indicator {
            transition: background-color 0.3s ease-out;
        }

        .status-text {
            transition: background-color 0.3s ease-out, color 0.3s ease-out;
        }

        /* Animations for participant removal */
        @keyframes participant-leave {
            0% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.9) rotate(-2deg);
                filter: brightness(0.8);
            }

            100% {
                opacity: 0;
                transform: scale(0.8) rotate(-5deg);
                filter: brightness(0.5);
            }
        }

        .video-wrapper.leaving {
            animation: participant-leave 0.6s ease-out forwards;
            pointer-events: none;
        }

        /* Animation for room closure */
        @keyframes room-closure {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.8;
                transform: scale(0.95);
            }

            100% {
                opacity: 0;
                transform: scale(0.9);
            }
        }

        .video-container-closing {
            animation: room-closure 0.8s ease-out forwards;
        }

        /* Message animation */
        .meeting-end-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.4s ease-out;
        }

        .meeting-end-message.visible {
            opacity: 1;
        }

        /* Add CSS for participant entry animation as well */
        @keyframes participant-enter {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(10px);
            }

            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .video-wrapper.entering {
            animation: participant-enter 0.6s ease-out forwards;
        }

        /* Add function to show participant notifications */
        .participant-notification {
            position: fixed;
            top: 80px;
            right: 24px;
            background: rgba(32, 33, 36, 0.95);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .participant-notification.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .participant-notification.leave {
            border-left: 4px solid #ea4335;
        }

        .participant-notification.join {
            border-left: 4px solid #34a853;
        }

        /* Add CSS for disconnected state */
        .video-wrapper.disconnected {
            position: relative;
            opacity: 0.7;
            filter: grayscale(0.5) brightness(0.8);
        }

        .video-wrapper.disconnected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 5;
            border-radius: 8px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }

        .video-wrapper.disconnected .status-indicator {
            background: #fbbc04;
            animation: pulse 1.5s infinite;
        }

        /* Improve notification styles */
        .participant-notification.warning {
            border-left: 4px solid #fbbc04;
        }

        .participant-notification.message {
            border-left: 4px solid #8ab4f8;
        }

        .participant-notification.info {
            border-left: 4px solid #8ab4f8;
        }

        /* Add transition for smoother UI changes */
        .video-wrapper,
        .video-overlay,
        .status-indicator,
        .status-text {
            transition: all 0.3s ease-out;
        }

        /* Optimize animations for better performance */
        @keyframes participant-leave {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
                filter: brightness(1);
            }

            100% {
                opacity: 0;
                transform: scale(0.8) translateY(10px);
                filter: brightness(0.5);
            }
        }

        /* Add loading indicator for reconnection */
        .reconnecting-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: #fff;
            animation: spin 1s linear infinite;
            z-index: 10;
            display: none;
        }

        .video-wrapper.disconnected .reconnecting-indicator {
            display: block;
        }

        @keyframes spin {
            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Add styles for clean exit animation */
        .exiting {
            animation: exit-fade 0.5s ease-out forwards;
        }

        @keyframes exit-fade {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0.95);
            }
        }

        /* Add styles for clean entry animation */
        .entering {
            animation: enter-fade 0.5s ease-out forwards;
        }

        @keyframes enter-fade {
            0% {
                opacity: 0;
                transform: scale(0.95);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Improve the fade-scale animation */
        @keyframes fadeScale {
            from {
                opacity: 0;
                transform: scale(0.98);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Animation for setup screen entry and exit */
        .fade-scale {
            animation: fadeScale 0.5s ease-out forwards;
        }

        /* Ensure conference screen transitions smoothly */
        #conferenceScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            z-index: 500;
        }

        #conferenceScreen.exiting {
            opacity: 0;
            transform: scale(0.95);
        }

        /* Add a transition utility class for screens */
        .screen-transition {
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        /* Add fixed positioning to screens to prevent layout shifts */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
            transition: all 0.3s ease-out;
            font-weight: 400;
            width: 400px;
            max-width: 90%;
        }

        /* Mobile notification adjustments */
        @media (max-width: 768px) {
            .notification {
                width: 90%;
                max-width: 400px;
                top: 60px;
                padding: 10px 14px;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .notification {
                width: 85%;
                max-width: 320px;
                top: 50px;
                padding: 8px 12px;
                font-size: 13px;
                gap: 8px;
            }
        }

        .notification.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Port notification adjustments */
        @media (orientation: portrait) and (max-width: 480px) {
            .camera-overlay {
                width: 80px;
                height: 120px;
                bottom: 70px;
                right: 8px;
            }
        }

        /* Room ID styles */
        .meet-info code {
            max-width: 160px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            transition: all 0.2s ease;
        }

        #copyRoomId {
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Responsive styles for remote camera overlay */
        @media (max-width: 1200px) {
            .remote-camera-overlay {
                width: 160px;
                height: 160px;
            }
        }

        @media (max-width: 992px) {
            .remote-camera-overlay {
                width: 140px;
                height: 140px;
            }
        }

        @media (max-width: 768px) {
            .remote-camera-overlay {
                width: 120px;
                height: 120px;
                bottom: 20px;
                right: 20px;
            }
        }

        @media (max-width: 576px) {
            .remote-camera-overlay {
                width: 100px;
                height: 100px;
                bottom: 16px;
                right: 16px;
                border-width: 2px;
            }

            .remote-camera-overlay .video-overlay {
                font-size: 10px;
                padding: 3px 6px;
            }
        }

        @media (max-width: 480px) {
            .remote-camera-overlay {
                width: 80px;
                height: 80px;
                bottom: 12px;
                right: 12px;
            }
        }

        @media (orientation: landscape) and (max-height: 480px) {
            .remote-camera-overlay {
                width: 70px;
                height: 70px;
                bottom: 10px;
                right: 10px;
                border-width: 2px;
            }

            .remote-camera-overlay .video-overlay {
                font-size: 9px;
                padding: 2px 4px;
                bottom: 4px;
            }
        }

        @media (max-width: 576px) {

            .camera-overlay.camera-disabled::after,
            .remote-camera-overlay.camera-disabled::after {
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {

            .camera-overlay.camera-disabled::after,
            .remote-camera-overlay.camera-disabled::after {
                font-size: 10px;
            }
        }

        @media (orientation: landscape) and (max-height: 380px) {

            .camera-overlay.camera-disabled::after,
            .remote-camera-overlay.camera-disabled::after {
                font-size: 9px;
            }
        }

        /* Enhanced remote camera positioning for screen sharing */
        .video-wrapper.screen-sharing .remote-camera-overlay {
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            z-index: 20;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .video-wrapper.screen-sharing .remote-camera-overlay video {
            object-fit: cover;
            min-width: 100%;
            min-height: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
        }

        /* Fix remote camera positioning on different screen sizes during screen sharing */
        @media (max-width: 576px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 100px;
                height: 100px;
                bottom: 16px;
                right: 16px;
                border-width: 2px;
            }
        }

        @media (max-width: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 70px;
                height: 70px;
                bottom: 12px;
                right: 12px;
            }
        }

        @media (orientation: landscape) and (max-height: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 65px;
                height: 65px;
                bottom: 10px;
                right: 10px;
                border-width: 2px;
            }
        }

        @media (orientation: landscape) and (max-height: 380px) {
            .video-wrapper.screen-sharing .remote-camera-overlay {
                width: 55px;
                height: 55px;
                bottom: 8px;
                right: 8px;
            }
        }

        .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 5;
            font-size: 12px;
            padding: 3px 6px;
            background: rgba(0, 0, 0, 0.7);
        }

        /* Adjust text size for small screens */
        @media (max-width: 576px) {
            .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
                font-size: 10px;
                padding: 2px 4px;
            }
        }

        @media (max-width: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
                font-size: 9px;
                padding: 2px 3px;
            }
        }

        @media (orientation: landscape) and (max-height: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay .video-overlay {
                font-size: 8px;
                padding: 1px 3px;
                bottom: 4px;
            }
        }

        /* Camera off state during screen sharing */
        .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 6;
        }

        .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::after {
            content: 'Camera Off';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 7;
            text-align: center;
            width: 100%;
            font-size: 12px;
        }

        @media (max-width: 576px) {
            .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::after {
                font-size: 10px;
            }
        }

        @media (max-width: 480px) {
            .video-wrapper.screen-sharing .remote-camera-overlay.camera-disabled::after {
                font-size: 8px;
            }
        }

        /* Ensure remote camera overlay is visible when rejoining during screen share */
        .video-wrapper.screen-sharing {
            position: relative;
        }

        /* Fix for rejoining during screen share - ensure camera overlay is visible */
        .video-wrapper.screen-sharing:not(.has-remote-camera)::after {
            content: '';
            position: absolute;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .video-wrapper.screen-sharing.has-remote-camera .remote-camera-overlay {
            visibility: visible;
            opacity: 1;
        }

        /* Ensure the remote camera overlay has proper initial visibility */
        .remote-camera-overlay {
            visibility: visible;
            opacity: 1;
            transition: visibility 0.3s ease, opacity 0.3s ease;
        }

        /* Android Chrome specific fixes */
        @supports (-webkit-touch-callout: none) and (not (translate: none)) {

            /* Target Android Chrome */
            .meet-controls {
                position: fixed !important;
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
                z-index: 2000 !important;
                bottom: 50px !important;
                /* Higher position to ensure reachability */
                left: 50% !important;
                transform: translateX(-50%) !important;
                background: rgba(32, 33, 36, 0.95) !important;
                backdrop-filter: blur(30px) !important;
                border-radius: 32px !important;
                padding: 8px !important;
                gap: 8px !important;
                width: auto !important;
                min-width: 200px !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
            }

            .meet-button {
                width: 48px !important;
                /* Larger touch target */
                height: 48px !important;
                /* Larger touch target */
                min-width: 48px !important;
                min-height: 48px !important;
                border-radius: 50% !important;
                background-color: #3c4043 !important;
                color: #fff !important;
                border: none !important;
                cursor: pointer !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                margin: 0 4px !important;
                opacity: 1 !important;
                transition: background-color 0.2s ease !important;
                -webkit-tap-highlight-color: transparent !important;
            }

            /* Fix for the active state of buttons on Android */
            .meet-button.active {
                background-color: #ea4335 !important;
            }

            .meet-button.leave {
                background: #ea4335 !important;
            }

            .meet-button svg {
                width: 24px !important;
                height: 24px !important;
                stroke: currentColor !important;
                stroke-width: 2 !important;
                display: block !important;
                opacity: 1 !important;
            }
        }

        /* Alternative Android Chrome fix using user agent detection */
        @media screen and (-webkit-min-device-pixel-ratio:0) {
            @supports (not (-webkit-touch-callout:inherit)) {

                /* Target Android browsers, but not iOS */
                .meet-controls {
                    position: fixed !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    bottom: 50px !important;
                    /* Higher position to ensure reachability */
                }

                .meet-button {
                    position: relative !important;
                    display: flex !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    width: 48px !important;
                    /* Larger touch target */
                    height: 48px !important;
                    /* Larger touch target */
                    -webkit-tap-highlight-color: transparent !important;
                }

                .meet-button.active {
                    background-color: #ea4335 !important;
                }
            }
        }

        /* Additional Android SVG fixes */
        @media screen and (max-width: 768px) {

            /* Fix for Android Chrome SVG visibility issues */
            button.meet-button svg {
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                fill: none !important;
                stroke: currentColor !important;
                stroke-width: 2px !important;
                min-width: 24px !important;
                min-height: 24px !important;
            }

            /* Add background color to SVG parent to ensure visibility */
            button.meet-button {
                position: relative !important;
                background-color: #3c4043 !important;
                border-radius: 50% !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                width: 48px !important;
                /* Larger size for better tap target */
                height: 48px !important;
                /* Larger size for better tap target */
                margin: 0 6px !important;
                /* Increase space between buttons */
                overflow: visible !important;
                -webkit-tap-highlight-color: transparent !important;
            }

            /* Add active state for touch devices */
            button.meet-button.active {
                background-color: #ea4335 !important;
            }

            /* Specific style for the leave button */
            button.meet-button.leave {
                background-color: #ea4335 !important;
            }

            /* Increase tap target for mobile and move higher for better reachability */
            .meet-controls {
                padding: 10px 12px !important;
                bottom: 50px !important;
                /* Higher position to ensure reachability */
                gap: 6px !important;
            }
        }

        /* Ensure controls are always visible */
        #meetControls {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 2000 !important;
        }

        /* Additional styles for touch feedback */
        .meet-button.touch-active {
            transform: scale(0.95) !important;
            opacity: 0.9 !important;
        }

        /* Fix for camera-overlay positioning when controls are higher */
        @media (max-width: 576px) {
            .camera-overlay {
                bottom: 120px !important;
                /* Move up to prevent overlap with raised controls */
            }
        }

        /* Add touch-specific active state for buttons */
        @media (hover: none) {

            /* Target touch devices specifically */
            .meet-button:active,
            .meet-button.active,
            .meet-button.touch-active {
                background-color: #ea4335 !important;
                transform: scale(0.95) !important;
                transition: transform 0.1s ease-out, background-color 0.1s ease-out !important;
            }

            /* Make sure leave button stays red and just changes opacity on touch */
            .meet-button.leave:active,
            .meet-button.leave.touch-active {
                opacity: 0.8 !important;
                transform: scale(0.95) !important;
            }

            /* Fix active state rendering for buttons */
            button.meet-button.active svg,
            button.meet-button:active svg {
                opacity: 1 !important;
                visibility: visible !important;
            }
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            z-index: 9999;
            background: rgba(32, 33, 36, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            max-width: 90%;
            width: auto;
            text-align: center;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .notification.showing {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .notification-content {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-info {
            border-left: 4px solid #4285f4;
        }

        .notification-warning {
            border-left: 4px solid #fbbc05;
        }

        .notification-error {
            border-left: 4px solid #ea4335;
        }

        /* Mobile-specific styles for screen sharing button */
        @media (max-width: 768px) {

            /* Hide screen share button on iOS since it's not supported */
            html.ios #shareScreen {
                display: none !important;
            }

            /* Special styling for Android screen share button to indicate it might not work everywhere */
            html.android #shareScreen {
                position: relative;
            }

            html.android #shareScreen::after {
                content: "?";
                position: absolute;
                top: -5px;
                right: -5px;
                background: #fbbc05;
                color: #000;
                border-radius: 50%;
                width: 16px;
                height: 16px;
                font-size: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
            }
        }

        /* Add these styles to your existing CSS */
        .audio-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .video-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .select-wrapper {
            position: relative;
            margin-right: 8px;
        }

        .meet-select {
            appearance: none;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 14px;
            padding: 6px 24px 6px 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
        }

        .meet-select:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .meet-select:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .meet-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .meet-select.loading {
            background-image: url('data:image/svg+xml;charset=utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>');
            background-repeat: no-repeat;
            background-position: center right 8px;
            background-size: 16px;
            animation: rotate 1s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Custom select arrow */
        .select-wrapper::after {
            content: '';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='rgba(255, 255, 255, 0.8)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            transition: all 0.2s ease;
            opacity: 0.8;
        }

        .select-wrapper:hover::after {
            opacity: 1;
            transform: translateY(-50%) translateY(1px);
        }

        .meet-select:focus+.select-wrapper::after {
            opacity: 1;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .meet-select {
                max-width: 180px;
                font-size: 12px;
                padding: 6px 28px 6px 10px;
            }

            .audio-control-group {
                gap: 2px;
            }
        }

        @media (max-width: 480px) {
            .meet-select {
                max-width: 140px;
                font-size: 10px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) {
            .meet-select {
                padding: 10px 32px 10px 12px;
                /* Larger touch target */
            }
        }

        /* Loading state */
        .meet-select.loading {
            background-image: linear-gradient(90deg,
                    rgba(32, 33, 36, 0.8) 25%,
                    rgba(42, 43, 46, 0.8) 50%,
                    rgba(32, 33, 36, 0.8) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite linear;
        }

        @keyframes loading {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }


        /* Mobile optimizations */
        @media (max-width: 768px) {
            .meet-select {
                max-width: 180px;
                font-size: 13px;
                padding: 6px 32px 6px 10px;
            }

            .audio-control-group {
                gap: 6px;
            }
        }

        @media (max-width: 480px) {
            .meet-select {
                max-width: 140px;
                font-size: 12px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) {
            .meet-select {
                padding: 10px 36px 10px 12px;
            }

            .meet-select:active {
                transform: scale(0.98);
                transition: transform 0.1s ease;
            }
        }

        /* Hide overlay text by default */
        .video-overlay,
        .stats-overlay {
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        /* Show on hover for desktop devices */
        @media (hover: hover) {

            .video-wrapper:hover .video-overlay,
            .video-wrapper:hover .stats-overlay {
                opacity: 1;
            }

            /* Also show camera overlay name on hover */
            .camera-overlay:hover .video-overlay,
            .remote-camera-overlay:hover .video-overlay {
                opacity: 1;
            }
        }

        /* Touch device handling */
        @media (hover: none) {

            .video-wrapper.touch-active .video-overlay,
            .video-wrapper.touch-active .stats-overlay {
                opacity: 1;
            }

            .camera-overlay.touch-active .video-overlay,
            .remote-camera-overlay.touch-active .video-overlay {
                opacity: 1;
            }
        }

        /* Always show room ID when copied */
        #currentRoomId.copied {
            opacity: 1;
        }

        /* Exception for camera disabled state - always show the text */
        .camera-overlay.camera-disabled::after,
        .remote-camera-overlay.camera-disabled::after {
            opacity: 1 !important;
        }

        /* Notification Manager Styles */
        #notification-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            width: 90%;
            max-width: 400px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .notification {
            position: fixed;
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(8px);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease-out;
            pointer-events: auto;
            width: 90%;
            left: 50%;
            transform: translateX(-50%);
            box-sizing: border-box;
            z-index: 9999;
        }

        .notification.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .notification-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
        }

        .notification-content {
            flex-grow: 1;
            font-size: 14px;
            line-height: 1.4;
            margin-right: 8px;
            word-break: break-word;
        }

        .notification-close {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
        }

        .notification-close:hover {
            color: #fff;
        }

        .notification.info {
            border-left: 4px solid #4285f4;
        }

        .notification.success {
            border-left: 4px solid #34a853;
        }

        .notification.warning {
            border-left: 4px solid #fbbc05;
        }

        .notification.error {
            border-left: 4px solid #ea4335;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            #notification-container {
                top: 10px;
                left: 0;
                right: 0;
                width: calc(100% - 20px);
                padding-left: 10px;
                padding-right: 10px;
                box-sizing: border-box;
            }

            .notification {
                width: 100%;
                max-width: none;
                margin: 0 auto;
                padding: 10px 12px;
                font-size: 13px;
                box-sizing: border-box;
            }

            .notification-icon {
                width: 16px;
                height: 16px;
            }
        }

        /* Safe area insets for modern mobile devices */
        @supports (padding-top: env(safe-area-inset-top)) {
            #notification-container {
                padding-top: env(safe-area-inset-top);
            }
        }

        /* Muted indicator styles */
        .muted-indicator {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(202, 214, 253, 0.743);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(4px);
            font-size: 13px;
        }

        /* Style for the SVG container */
        .muted-indicator span {
            font-weight: 500;
            display: flex;
            align-items: center;
        }

        /* Control SVG size */
        .muted-indicator svg {
            width: 1.2rem;
            height: 1.2rem;
        }

        /* Remove the pulse animation and red overlay */
        .video-wrapper:has(.muted-indicator)::before {
            display: none;
        }

        /* Add styles for clean exit animation */
        .exiting {
            animation: exit-fade 0.5s ease-out forwards;
        }

        /* Define the exit animation */
        @keyframes exit-fade {
            from {
                opacity: 1;
                transform: translateY(0);
            }

            to {
                opacity: 0;
                transform: translateY(10px);
            }
        }

        /* Mobile/Desktop specific elements */
        .mobile-only {
            display: none !important;
        }

        .desktop-only {
            display: block;
        }

        /* Show/hide elements based on device type */
        html.mobile .mobile-only {
            display: flex !important;
        }

        html.mobile .desktop-only {
            display: none !important;
        }

        /* Mobile-friendly select styles */
        html.mobile .select-wrapper {
            max-width: 120px;
            margin: 0 4px;
        }

        html.mobile .meet-select {
            height: 40px;
            padding: 0 24px 0 8px;
            font-size: 14px;
            border-radius: 20px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        html.mobile .select-wrapper::after {
            right: 8px;
            width: 8px;
            height: 8px;
        }

        @media (max-width: 360px) {
            html.mobile .select-wrapper {
                max-width: 100px;
            }

            html.mobile .meet-select {
                font-size: 13px;
                padding: 0 20px 0 6px;
            }
        }

        /* Switch camera button styles */
        #switchCamera {
            margin-left: 8px;
        }

        #switchCamera svg {
            transform-origin: center;
            transition: transform 0.3s ease;
        }

        #switchCamera.switching svg {
            transform: rotate(180deg);
        }

        /* Control group spacing */
        .video-control-group {
            display: flex;
            align-items: center;
            margin-left: 8px;
        }

        .audio-control-group {
            display: flex;
            align-items: center;
            margin-right: 8px;
        }

        #toggleVideo {
            margin-right: 8px;
        }

        @media (max-width: 360px) {
            html.mobile .select-wrapper {
                max-width: 100px;
            }

            html.mobile .meet-select {
                font-size: 13px;
                padding: 0 20px 0 6px;
            }

            .video-control-group,
            .audio-control-group {
                margin-left: 4px;
                margin-right: 4px;
            }

            #toggleVideo {
                margin-right: 4px;
            }    
        }
    </style>
</head>

<body>
    <!-- Add notification container at the top of body -->
    <div id="notification-container"></div>
    <div id="setupScreen"
        class="join-screen screen screen-transition flex flex-col items-center justify-start md:justify-center w-full max-w-md mx-auto p-6 md:p-8">
        <!-- Logo -->
        <div class="flex items-center gap-2 mb-6">
            <span class="text-2xl md:text-3xl text-blue-500">⚡</span>
            <h1 class="text-2xl font-medium mb-2">FastMeet</h1>
        </div>

        <form id="joinRoomForm" class="join-form w-full bg-gray-800 rounded-xl shadow-lg p-6 relative">
            <!-- Status indicator -->
            <div id="health-status"
                class="absolute top-4 right-4 flex items-center gap-1 bg-green-900/20 text-green-500 px-2 py-1 rounded-full text-xs">
                <span class="w-2 h-2 rounded-full bg-green-500"></span>
                Live
            </div>

            <div class="mb-4">
                <label for="roomIdInput" class="block mb-2 text-sm font-medium text-gray-400">Room ID</label>
                <input type="text" id="roomIdInput" placeholder="Enter room ID or leave blank to create a new room"
                    class="meet-input w-full px-4 py-3 bg-gray-700 border border-gray-700 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/30 rounded-lg outline-none text-white">
            </div>

            <div class="mb-5">
                <label for="userNameInput" class="block mb-2 text-sm font-medium text-gray-400">Your name</label>
                <input type="text" id="userNameInput" placeholder="Your name" required
                    class="meet-input w-full px-4 py-3 bg-gray-700 border border-gray-700 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/30 rounded-lg outline-none text-white">
            </div>

            <button type="submit"
                class="join-button w-full mt-5 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-all hover:scale-[1.01] focus:ring-2 focus:ring-blue-500/50 focus:outline-none active:scale-[0.98]">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M15 10l5 5-5 5"></path>
                    <path d="M4 4v7a4 4 0 0 0 4 4h12"></path>
                </svg>
                Join meeting
            </button>
        </form>


        <!-- Footer -->
        <div class="mt-8 md:mt-12 text-gray-500 text-xs text-center">
            © 2025 FastMeet •
            <a href="#" class="px-1 hover:text-gray-400">Privacy</a> •
            <a href="#" class="px-1 hover:text-gray-400">Terms</a>
        </div>
    </div>

    <div id="conferenceScreen" class="screen screen-transition fade-scale" style="display: none;">
        <div class="meet-info">
            <div class="flex items-center gap-4">
                <span class="text-sm">Room ID:</span>
                <code id="currentRoomId"
                    class="text-sm bg-[rgba(255,255,255,0.1)] px-2 py-1 rounded text-ellipsis overflow-hidden"></code>
                <button id="copyRoomId"
                    class="text-sm text-[#8ab4f8] hover:text-white flex items-center justify-center">
                    <span>Copy</span>
                </button>
            </div>
        </div>

        <div id="statusText" class="status-text">
            Initializing...
        </div>

        <div id="videoContainer" class="video-grid">
            <div class="video-wrapper local">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-overlay">You</div>
                <div class="status-indicator"></div>
                <div id="localStats" class="video-overlay stats">Connecting...</div>
            </div>
        </div>

        <div id="meetControls"
            class="fixed bottom-8 left-1/2 transform -translate-x-1/2 meet-controls flex items-center"
            style="z-index: 2000; display: flex !important;">
            <div class="audio-control-group">
                <button id="toggleAudio" class="meet-button" type="button" aria-label="Toggle microphone">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        style="display: block;">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                </button>
                <div class="select-wrapper">
                    <select id="micSelect" class="meet-select" aria-label="Select microphone">
                        <option value="">Loading microphones...</option>
                    </select>
                </div>
            </div>
            <button id="toggleVideo" class="meet-button" type="button" aria-label="Toggle camera">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    style="display: block;">
                    <polygon points="23 7 16 12 23 17 23 7"></polygon>
                    <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                </svg>
            </button>
            <div class="video-control-group">
                <!-- Camera select dropdown (desktop only) -->
                <div class="select-wrapper desktop-only">
                    <select id="cameraSelect" class="meet-select" aria-label="Select camera">
                        <option value="">Loading cameras...</option>
                    </select>
                </div>
                <!-- Camera switch button (mobile only) -->
                <button id="switchCamera" class="meet-button mobile-only" type="button" aria-label="Switch camera">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                        <path d="m191.715 63.853 3.534-.022 3.866-.008 4.081-.02q6.699-.028 13.398-.041l4.624-.013q10.87-.029 21.74-.041 12.513-.015 25.027-.077 9.692-.044 19.384-.048c3.852-.002 7.705-.011 11.557-.036q5.446-.035 10.894-.018c1.949.001 3.898-.018 5.847-.038 12.14.071 21.656 3.217 31.333 10.509l2.625 1.75c8.766 8.304 13.423 20.038 18.546 30.75 1.02 2.126 2.053 4.244 3.087 6.363l.916 1.948c2.753 5.63 5.39 9.3 11.382 11.487 5.466 1.09 10.994.961 16.546.94l7.113.05c3.699.016 7.398.025 11.097.017 19.41-.014 34.318.618 48.836 14.793 9.356 9.86 13.164 20.544 13.12 33.926l.013 3.012c.013 3.322.011 6.644.01 9.967q.008 3.577.02 7.156.023 8.704.023 17.41.001 7.08.012 14.16a28194 28194 0 0 1 .024 44.578c0 11.702.019 23.404.047 35.107q.043 18.048.04 36.098c0 6.748.005 13.497.027 20.245q.029 9.526.005 19.052-.003 3.487.015 6.975c.09 18.678-1.616 31.738-14.816 45.966-11.367 10.757-23.81 12.705-38.932 12.638q-2.303.007-4.604.016c-4.196.014-8.391.01-12.587.003-4.533-.005-9.066.008-13.6.018-8.872.017-17.745.018-26.617.013q-10.821-.006-21.641.002l-3.114.003-6.263.004c-19.569.014-39.137.009-58.705-.003-17.891-.01-35.782.003-53.672.027q-27.576.037-55.15.027-15.474-.006-30.947.017-13.172.022-26.344-.002c-4.478-.009-8.955-.011-13.432.004q-6.158.02-12.314-.01-2.219-.006-4.437.01c-15.9.104-27.399-3.993-39.079-14.83-9.149-9.666-12.724-20.984-12.638-34.072l-.016-3.02c-.014-3.313-.007-6.625 0-9.938l-.02-7.158q-.023-8.689-.014-17.378.006-7.067-.002-14.135l-.003-2.037-.004-4.1c-.014-12.792-.009-25.584.003-38.377.01-11.683-.003-23.365-.027-35.048q-.037-18.029-.027-36.058c.003-6.738.001-13.477-.017-20.215q-.021-9.507.008-19.015.005-3.48-.01-6.96c-.078-18.658 1.644-31.714 14.83-45.926 10.433-9.874 22.164-12.695 36.16-12.656l3.524-.033c4.934-.046 9.868-.057 14.802-.072 3.62-.016 7.24-.049 10.861-.083l3.344.01c10.626-.093 10.626-.093 19.703-5.016 5.592-6.648 8.916-15.456 12.61-23.268 7.378-15.532 15.762-27.152 32.456-33.405 4.102-1.339 7.605-1.856 11.942-1.874m-7.781 37.842c-5.078 6.66-8.313 14.809-11.9 22.339-7.459 15.593-14.918 26.913-31.807 33.24-3.94 1.285-7.335 1.854-11.495 1.884l-3.187.03-3.432.023-7.22.086q-5.682.063-11.362.104c-3.66.028-7.32.074-10.98.122l-3.4.01c-6.79.106-14.203.29-19.735 4.742-5.51 6.004-5.711 13.33-5.677 21.01l-.011 2.77c-.01 3.054-.007 6.106-.003 9.16l-.015 6.58c-.014 5.95-.014 11.9-.012 17.85q0 7.455-.008 14.911-.016 18.595-.005 37.192c.006 10.753-.006 21.507-.025 32.261q-.03 16.582-.024 33.166c.002 6.2 0 12.402-.014 18.603q-.019 8.75.002 17.498.004 3.207-.009 6.413c-.01 2.924-.002 5.848.01 8.772l-.022 2.547c.056 6.067.759 12.69 4.672 17.587 7.318 6.659 16.636 5.693 25.87 5.666l4.354.011c3.98.01 7.96.008 11.94.004 4.297-.002 8.593.007 12.888.014q12.62.018 25.24.012 10.257-.002 20.515.005l2.95.001 5.932.004q27.816.013 55.631.003c16.962-.006 33.923.006 50.885.025q26.13.03 52.258.024 14.668-.005 29.335.014 12.488.019 24.974.002c4.246-.006 8.492-.007 12.738.005q5.835.014 11.67-.007 2.106-.004 4.213.008c12.14.268 12.14.268 22.908-4.66 5.526-5.989 5.719-13.336 5.685-21.011l.011-2.77c.01-3.054.007-6.106.003-9.16l.015-6.58c.014-5.95.014-11.9.012-17.85q0-7.455.008-14.911.016-18.595.005-37.192c-.006-10.753.006-21.507.025-32.261q.03-16.582.024-33.166c-.002-6.2 0-12.402.014-18.603q.019-8.75-.002-17.498-.004-3.207.009-6.413c.01-2.924.002-5.848-.01-8.772l.022-2.547c-.056-6.067-.759-12.69-4.672-17.587-6.825-6.21-15.155-5.686-23.8-5.678l-7.15-.063q-5.59-.034-11.183-.045c-3.618-.01-7.236-.043-10.854-.08l-3.325.015c-12.964-.162-23.425-4.379-33.1-12.929-7.729-8.772-12.37-18.457-17.354-28.94a906 906 0 0 0-3.084-6.38l-.91-1.952c-2.167-4.43-4.739-8.652-8.965-11.353-6.61-2.191-12.86-2.29-19.781-2.275l-3.506-.015c-3.81-.014-7.619-.013-11.428-.01l-5.956-.01q-9.354-.016-18.708-.006c-6.413.006-12.826-.006-19.239-.027q-8.288-.026-16.577-.02-4.937.002-9.874-.015c-3.674-.013-7.347-.006-11.02.006l-3.265-.023c-7.5.052-15.124.559-20.712 6.09" fill="white"/>
                        <path d="M361.313 252.625c3.891 3.44 6.314 6.778 7.055 11.936.135 2.97.135 5.904.07 8.877l-.047 3.237c-.615 25.399-9.723 49.107-26.391 68.325l-2.012 2.45c-14.157 16.669-33.2 27.427-53.988 33.55l-3.352 1.031c-25.632 6.483-51.72 1.719-75.648-8.031l-2.95-1.18L202 372l-1.426 1.277-1.887 1.66-1.863 1.653c-4.077 3.152-8.91 2.982-13.824 2.41-5.02-1.624-7.664-4.39-10.186-9.038-1.34-3.228-1.386-6.436-1.345-9.872l-.012-2.214q-.004-2.3.022-4.6c.021-2.336 0-4.669-.026-7.005q.004-2.247.016-4.494l-.025-2.093c.096-5 1.436-7.827 4.556-11.684 7.27-5.724 14.365-5.209 23.25-5.25l3.316-.062c6.887-.033 14.583-.06 20.052 4.729 3.773 4.322 4.51 7.698 4.445 13.27l-.028 3.012L227 346l1.688.367 2.312.508c.83.182 1.66.364 2.516.55 2.093.485 4.167 1.052 6.234 1.637 19.74 4.858 40.97.093 58.25-10.062 3.148-2.176 6.078-4.532 9-7l1.793-1.355C322.463 319.978 331.579 300.953 334 284c.366-4.584.546-9.17.585-13.768.103-6.08.867-10.412 5.099-15.095l1.753-1.45c.577-.49 1.153-.982 1.747-1.488 5.558-3.67 12.467-2.351 18.128.426m-105.749-93 1.997.002c17.266.065 31.584 3.913 47.44 10.373l2.95 1.18 2.05.82 1.426-1.277 1.887-1.66 1.863-1.653c3.818-2.952 8.2-2.987 12.824-2.41 5.569 1.672 8.272 3.84 11.14 9.007 1.395 3.232 1.432 6.446 1.391 9.903l.012 2.214q.004 2.3-.022 4.6c-.021 2.336 0 4.669.026 7.005q-.004 2.247-.016 4.494l.025 2.093c-.096 5-1.436 7.827-4.556 11.684-7.27 5.724-14.365 5.209-23.25 5.25l-3.316.063c-6.887.032-14.583.06-20.052-4.73-3.773-4.322-4.51-7.698-4.445-13.27l.028-3.012L285 198c-23.837-6.138-45.562-6.633-67.96 5.188-18.849 11.24-31.373 27.947-37.349 49.007L179 255l-.574 2.25c-.78 5.042-.75 10.174-.856 15.27-.25 6.934-1.368 11.802-5.882 17.293-4.27 3.474-7.764 4.426-13.188 4.062-4.35-.643-7.153-1.917-10.5-4.875-4.42-6.058-4.6-11.07-4.437-18.437l.046-3.238c.615-25.399 9.723-49.107 26.391-68.325l2.012-2.45c20.776-24.462 51.86-36.97 83.55-36.925" fill="white"/>
                      </svg>
                </button>
            </div>
            <button id="shareScreen" class="meet-button" type="button" aria-label="Share screen">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    style="display: block;">
                    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                    <line x1="8" y1="21" x2="16" y2="21"></line>
                    <line x1="12" y1="17" x2="12" y2="21"></line>
                </svg>
            </button>
            <button id="leaveCall" class="meet-button leave" type="button" aria-label="Leave call">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    style="display: block;">
                    <path
                        d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91">
                    </path>
                    <line x1="1" y1="1" x2="23" y2="23"></line>
                </svg>
            </button>
        </div>
    </div>

    <script>
        // Advanced configuration for WebRTC with ultra-low latency settings
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ],
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 10,
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            // Enable advanced options for low latency
            enableDtlsSrtp: true,
            enableRtpDataChannels: false,
            // Optimize ICE gathering
            iceServersTransportPolicy: 'all',
            // Add codec preferences for more efficient video
            codecPreferences: {
                video: ['VP9', 'VP8', 'H264'],
                audio: ['OPUS']
            }
        };

        // Optimized media constraints for low latency and high quality
        const mediaConstraints = {
            video: {
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 },
                frameRate: { min: 24, ideal: 30, max: 60 },
                aspectRatio: { ideal: 16 / 9 },
                // Low latency specific constraints
                latency: { ideal: 0.01 },
                // Advanced video constraints for better quality
                advanced: [
                    { width: { min: 640, ideal: 1280, max: 1920 } },
                    { height: { min: 480, ideal: 720, max: 1080 } },
                    { frameRate: { min: 24, ideal: 30, max: 60 } },
                    { aspectRatio: { ideal: 16 / 9 } },
                    // Reduce noise in dark environments (if supported)
                    { noiseSuppression: true },
                    // Automatic gain control (if supported)
                    { autoGainControl: true }
                ]
            },
            audio: {
                // Audio constraints optimized for voice clarity and low latency
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                // High sampling rate for better audio quality
                sampleRate: { ideal: 48000 },
                sampleSize: { ideal: 16 },
                channelCount: { ideal: 2 },
                // Low latency audio processing
                latency: { ideal: 0.01 },
                // Advanced audio constraints
                advanced: [
                    { echoCancellation: { ideal: true } },
                    { noiseSuppression: { ideal: true } },
                    { autoGainControl: { ideal: true } }
                ]
            }
        };

        // Function to apply codec preferences during offer/answer creation
        async function applyCodecPreferences(pc, offerOptions = {}) {
            // Check if RTCRtpTransceiver is supported and has setCodecPreferences
            if (!window.RTCRtpTransceiver || !RTCRtpTransceiver.prototype.setCodecPreferences) {
                console.warn('Codec preferences not supported in this browser');
                return pc.createOffer(offerOptions);
            }

            try {
                // Get capabilities for video and audio
                const videoCapabilities = RTCRtpSender.getCapabilities('video');
                const audioCapabilities = RTCRtpSender.getCapabilities('audio');

                if (!videoCapabilities && !audioCapabilities) {
                    console.warn('No codec capabilities available');
                    return pc.createOffer(offerOptions);
                }

                // Find transceivers for video and audio
                const transceivers = pc.getTransceivers();
                let audioTransceiverFound = false;

                // Debug info
                console.log(`Applying codec preferences to ${transceivers.length} transceivers`);

                for (const transceiver of transceivers) {
                    // Skip if stopped or not receiving
                    if (transceiver.stopped || !transceiver.receiver) {
                        console.log('Skipping stopped or non-receiving transceiver');
                        continue;
                    }

                    const kind = transceiver.receiver.track?.kind;
                    if (!kind) {
                        console.log('Skipping transceiver with no kind');
                        continue;
                    }

                    console.log(`Processing ${kind} transceiver`);

                    if (kind === 'audio') {
                        audioTransceiverFound = true;
                    }

                    const capabilities = kind === 'video' ? videoCapabilities : (kind === 'audio' ? audioCapabilities : null);
                    const preferredCodecs = configuration.codecPreferences[kind];

                    if (!capabilities || !preferredCodecs) {
                        console.log(`No capabilities or preferred codecs for ${kind}`);
                        continue;
                    }

                    // Reorder codecs based on preference
                    const codecs = [];

                    // First add the preferred codecs in order
                    for (const codec of preferredCodecs) {
                        const matchingCodecs = capabilities.codecs.filter(c =>
                            c.mimeType.toLowerCase().includes(codec.toLowerCase()));
                        codecs.push(...matchingCodecs);
                    }

                    // Then add any remaining codecs
                    const remainingCodecs = capabilities.codecs.filter(c =>
                        !codecs.some(preferred => preferred.mimeType === c.mimeType));
                    codecs.push(...remainingCodecs);

                    if (codecs.length > 0) {
                        try {
                            transceiver.setCodecPreferences(codecs);
                            console.log(`Set codec preferences for ${kind}: ${codecs.map(c => c.mimeType).join(', ')}`);
                        } catch (e) {
                            console.warn(`Failed to set codec preferences for ${kind}:`, e);
                        }
                    } else {
                        console.warn(`No codecs available for ${kind}`);
                    }
                }

                // Ensure audio transceiver exists if we have audio tracks
                if (!audioTransceiverFound && localStream && localStream.getAudioTracks().length > 0) {
                    console.log('No audio transceiver found, but audio track exists. Adding audio transceiver.');
                    // Ensure we have an audio transceiver
                    const audioTransceiver = pc.addTransceiver('audio', {
                        direction: 'sendrecv',
                        streams: [localStream]
                    });

                    // Apply audio codec preferences if available
                    if (audioCapabilities && configuration.codecPreferences.audio) {
                        try {
                            const codecs = [];
                            for (const codec of configuration.codecPreferences.audio) {
                                const matchingCodecs = audioCapabilities.codecs.filter(c =>
                                    c.mimeType.toLowerCase().includes(codec.toLowerCase()));
                                codecs.push(...matchingCodecs);
                            }

                            const remainingCodecs = audioCapabilities.codecs.filter(c =>
                                !codecs.some(preferred => preferred.mimeType === c.mimeType));
                            codecs.push(...remainingCodecs);

                            if (codecs.length > 0) {
                                audioTransceiver.setCodecPreferences(codecs);
                                console.log(`Set codec preferences for newly added audio transceiver: ${codecs.map(c => c.mimeType).join(', ')}`);
                            }
                        } catch (e) {
                            console.warn('Failed to set codec preferences for newly added audio transceiver:', e);
                        }
                    }
                }

                // Create offer with the updated codec preferences
                // Make sure to explicitly request audio in the offer
                const updatedOfferOptions = { ...offerOptions, offerToReceiveAudio: true, offerToReceiveVideo: true };
                return pc.createOffer(updatedOfferOptions);
            } catch (error) {
                console.error('Error applying codec preferences:', error);
                return pc.createOffer({ ...offerOptions, offerToReceiveAudio: true, offerToReceiveVideo: true });
            }
        }

        // Variables to track state
        let localStream;
        let roomId;
        let userName;
        let peerConnections = {};
        let currentRoom;
        let statsInterval;
        let isScreenSharing = false;
        let currentMicrophoneId = null;
        let currentCameraId = null;

        // DOM elements
        const setupScreen = document.getElementById('setupScreen');
        const conferenceScreen = document.getElementById('conferenceScreen');
        const joinRoomForm = document.getElementById('joinRoomForm');
        const roomIdInput = document.getElementById('roomIdInput');
        const userNameInput = document.getElementById('userNameInput');
        const currentRoomIdSpan = document.getElementById('currentRoomId');
        const copyRoomIdButton = document.getElementById('copyRoomId');
        let localVideo = document.getElementById('localVideo');
        const videoContainer = document.getElementById('videoContainer');
        const toggleAudioButton = document.getElementById('toggleAudio');
        const toggleVideoButton = document.getElementById('toggleVideo');
        const shareScreenButton = document.getElementById('shareScreen');
        const leaveCallButton = document.getElementById('leaveCall');
        const statusText = document.getElementById('statusText');
        let localStats = document.getElementById('localStats');
        const micSelect = document.getElementById('micSelect');
        const cameraSelect = document.getElementById('cameraSelect');

        // WebSocket-based signaling implementation
        class WebSocketSignaling {
            constructor(userName) {
                this.userName = userName;
                this.listeners = {};
                this.isConnecting = false;
                this.reconnectAttempts = 0;
                this.maxReconnectDelay = 5000;
                this.pendingMessages = [];
                this.isHost = false; // Track if this user is the host
                this.connectionState = 'disconnected'; // Track connection state

                // Start connection
                this.connect();
            }

            connect() {
                if (this.isConnecting) return;
                this.isConnecting = true;
                this.connectionState = 'connecting';

                // Use secure WebSocket if the page is served over HTTPS
                const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${location.host}`;

                console.log('Connecting to WebSocket server at:', wsUrl);
                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log('WebSocket connected successfully');
                    this.isConnecting = false;
                    this.reconnectAttempts = 0;
                    this.connectionState = 'connected';

                    // Send any pending messages
                    while (this.pendingMessages.length > 0) {
                        const message = this.pendingMessages.shift();
                        this.send(message);
                    }

                    // Rejoin room if we were previously in one
                    if (this.roomId && this.userId) {
                        console.log('Rejoining room:', this.roomId);

                        // When reconnecting, send special reconnect request to verify room still exists
                        this.send({
                            type: 'reconnect',
                            roomId: this.roomId,
                            userId: this.userId,
                            userName: this.userName,
                            isHost: this.isHost
                        });
                    }

                    // Trigger connected event for UI updates
                    this.triggerEvent('connection-state-changed', { state: 'connected' });
                };

                this.ws.onmessage = (event) => {
                    try {
                        const signal = JSON.parse(event.data);

                        // Add special handling for room-closed and reconnection errors
                        if (signal.type === 'error') {
                            console.error('Received error from server:', signal.error, signal.message);

                            // Handle specific error cases
                            if (signal.error === 'room-closed' || signal.error === 'room-not-found') {
                                console.log('Error with room:', signal.error);
                                handleRoomClosure(signal.message);
                                return;
                            }

                            // Handle session expired
                            if (signal.error === 'session-expired') {
                                alert(signal.message);
                                leaveCall();
                                return;
                            }
                        }

                        // Handle room closed event
                        if (signal.type === 'room-closed') {
                            console.log(`Room ${signal.roomId} was closed by the host ${signal.hostName || signal.hostId}`);
                            handleRoomClosure(`This meeting has been ended by ${signal.hostName || 'the host'}`);
                            return;
                        }

                        // Handle server shutdown
                        if (signal.type === 'server-shutdown') {
                            console.log('Server is shutting down:', signal.message);
                            handleRoomClosure('The server is shutting down. Please try again later.');
                            return;
                        }

                        // Handle leave-confirmed message
                        if (signal.type === 'leave-confirmed') {
                            console.log('Leave confirmed by server, closing WebSocket connection');
                            // Close the WebSocket connection
                            this.disconnect();
                            return;
                        }

                        // Dispatch to registered listeners
                        if (this.listeners[signal.type]) {
                            this.listeners[signal.type].forEach(callback => callback(signal));
                        }

                        // Handle room-joined events to improve reconnection handling
                        if (signal.type === 'room-joined' || signal.type === 'room-rejoined') {
                            console.log(`Successfully ${signal.type === 'room-joined' ? 'joined' : 'rejoined'} room ${signal.roomId}`);

                            // Dispatch a custom roomJoined event for the application to handle
                            const roomJoinedEvent = new CustomEvent('roomJoined', {
                                detail: {
                                    roomId: signal.roomId,
                                    userId: signal.userId,
                                    isRejoin: signal.type === 'room-rejoined'
                                }
                            });
                            window.dispatchEvent(roomJoinedEvent);

                            // Force a delay and then check for screen share overlays
                            setTimeout(() => {
                                if (typeof checkAndRestoreScreenShareOverlays === 'function') {
                                    checkAndRestoreScreenShareOverlays();
                                }
                            }, 1500);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.isConnecting = false;
                    this.connectionState = 'error';
                    this.triggerEvent('connection-state-changed', { state: 'error', error });
                };

                this.ws.onclose = () => {
                    console.log('WebSocket connection closed');
                    this.isConnecting = false;
                    this.connectionState = 'disconnected';

                    // Check if we should try to reconnect
                    if (this.roomId) {
                        // If we were in a room, attempt to reconnect
                        // Implement exponential backoff for reconnection
                        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), this.maxReconnectDelay);
                        this.reconnectAttempts++;

                        if (this.reconnectAttempts <= 5) { // Limit reconnection attempts
                            console.log(`Attempting to reconnect in ${delay}ms... (Attempt ${this.reconnectAttempts})`);

                            // Show reconnection status if we're in the conference
                            if (conferenceScreen.style.display !== 'none') {
                                statusText.textContent = `Reconnecting... (${this.reconnectAttempts}/5)`;
                                statusText.className = 'status-text status-warning';
                            }

                            setTimeout(() => this.connect(), delay);
                        } else {
                            // Failed to reconnect after 5 attempts
                            this.connectionState = 'failed';
                            this.triggerEvent('connection-state-changed', { state: 'failed' });

                            alert('Unable to reconnect to the meeting. Please try joining again.');

                            // Reset room state
                            this.roomId = null;
                            this.userId = null;
                            this.isHost = false;

                            // Return to join screen
                            if (conferenceScreen.style.display !== 'none') {
                                leaveCall();
                            }
                        }
                    } else {
                        this.triggerEvent('connection-state-changed', { state: 'disconnected' });
                    }
                };
            }

            send(signal) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(signal));
                    return true;
                } else {
                    console.log('WebSocket not connected, queueing message');
                    this.pendingMessages.push(signal);
                    if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
                        this.connect();
                    }
                    return false;
                }
            }

            joinRoom(roomId, isNewRoom = false) {
                this.roomId = roomId;
                const userId = this.generateUserId();
                this.userId = userId;

                this.isHost = isNewRoom; // Set host flag if creating new room

                this.send({
                    type: 'join',
                    roomId: roomId,
                    userId: userId,
                    userName: this.userName,
                    isHost: this.isHost // Send host status to server
                });

                return userId;
            }

            sendOffer(targetUserId, offer) {
                return this.send({
                    type: 'offer',
                    offer: offer,
                    targetUserId: targetUserId,
                    roomId: this.roomId
                });
            }

            sendAnswer(targetUserId, answer) {
                return this.send({
                    type: 'answer',
                    answer: answer,
                    targetUserId: targetUserId,
                    roomId: this.roomId
                });
            }

            sendIceCandidate(targetUserId, candidate) {
                return this.send({
                    type: 'ice-candidate',
                    candidate: candidate,
                    targetUserId: targetUserId,
                    roomId: this.roomId
                });
            }

            leaveRoom() {
                console.log('leaveRoom called, isHost:', this.isHost, 'WebSocket state:', this.ws?.readyState);

                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    console.warn('WebSocket not open, cannot send leave message');
                    // Reset state anyway
                    const wasInRoom = !!this.roomId;
                    this.roomId = null;
                    this.userId = null;
                    this.isHost = false;
                    return false;
                }

                // If host is leaving, close the room for everyone
                if (this.isHost) {
                    console.log('Host is leaving, closing room for everyone');
                    const result = this.closeRoom();
                    console.log('closeRoom result:', result);
                    return result;
                } else {
                    // Regular leave for non-hosts
                    console.log('Regular participant leaving, sending leave message');
                    const userName = this.userName; // Capture for notification

                    try {
                        const result = this.send({
                            type: 'leave',
                            userId: this.userId,
                            userName: this.userName,
                            roomId: this.roomId
                        });

                        // Trigger a leave event locally too
                        this.triggerEvent('user-left', {
                            userId: this.userId,
                            userName: this.userName,
                            roomId: this.roomId,
                            isLocalUser: true
                        });

                        // Reset state regardless of send success
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;

                        return result;
                    } catch (error) {
                        console.error('Error sending leave message:', error);

                        // Reset state anyway
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;

                        return false;
                    }
                }
            }

            on(eventType, callback) {
                if (!this.listeners[eventType]) {
                    this.listeners[eventType] = [];
                }
                this.listeners[eventType].push(callback);
            }

            off(eventType, callback) {
                if (this.listeners[eventType]) {
                    this.listeners[eventType] = this.listeners[eventType].filter(cb => cb !== callback);
                }
            }

            triggerEvent(eventType, data) {
                if (this.listeners[eventType]) {
                    this.listeners[eventType].forEach(callback => callback(data));
                }
            }

            generateUserId() {
                return 'user_' + Math.random().toString(36).substr(2, 9);
            }

            // Add method to close the room (only host can do this)
            closeRoom() {
                console.log('closeRoom called, isHost:', this.isHost);

                if (!this.isHost) {
                    console.warn('Attempt to close room by non-host');
                    return false;
                }

                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    console.log('Sending close-room signal to server');

                    try {
                        // First, trigger local room-closed event for immediate UI update
                        this.triggerEvent('room-closed', {
                            roomId: this.roomId,
                            hostId: this.userId,
                            hostName: this.userName,
                            isLocalClose: true
                        });

                        // Then send the close request to server
                        const result = this.send({
                            type: 'close-room',
                            roomId: this.roomId,
                            userId: this.userId,
                            userName: this.userName
                        });

                        // Reset state regardless of send success
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;

                        return result;
                    } catch (error) {
                        console.error('Error sending close-room message:', error);

                        // Reset state anyway
                        this.roomId = null;
                        this.userId = null;
                        this.isHost = false;

                        return false;
                    }
                } else {
                    console.error('WebSocket not open, cannot close room');

                    // Reset state anyway
                    this.roomId = null;
                    this.userId = null;
                    this.isHost = false;

                    return false;
                }
            }

            // Add method to send chat messages
            sendChatMessage(message, isPrivate = false, targetUserId = null) {
                return this.send({
                    type: 'message',
                    roomId: this.roomId,
                    message: message,
                    isPrivate: isPrivate,
                    targetUserId: targetUserId
                });
            }

            // Add method to get connection state
            getConnectionState() {
                return this.connectionState;
            }

            // Add method to disconnect cleanly
            disconnect() {
                if (this.ws) {
                    // First leave any room we're in
                    if (this.roomId) {
                        this.leaveRoom();
                    }

                    // Then close the connection
                    if (this.ws.readyState === WebSocket.OPEN) {
                        this.ws.close(1000, "User disconnected");
                    }
                }

                // Reset all state
                this.roomId = null;
                this.userId = null;
                this.isHost = false;
                this.pendingMessages = [];
                this.reconnectAttempts = 0;
                this.connectionState = 'disconnected';
            }

            // Add broadcast method
            broadcast(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    // Use the message type that server accepts
                    const messageToSend = {
                        type: 'message',  // Server accepts this type
                        roomId: this.roomId,
                        userId: this.userId,
                        userName: this.userName,
                        message: {
                            type: 'media-update',
                            ...message
                        }
                    };
                    this.ws.send(JSON.stringify(messageToSend));
                } else {
                    console.warn('WebSocket not ready, message queued:', message);
                    this.pendingMessages.push(message);
                }
            }
        }

        // Function to update the health status display
        async function pingHealth() {
            const url = `${window.location.protocol}//${window.location.host}/health`;
            const statusElement = document.getElementById('health-status');

            try {
                const response = await fetch(url);
                if (response.status === 200) {
                    // Service is healthy: show "Live" with green dot.
                    statusElement.innerHTML = `<span class="w-2 h-2 rounded-full bg-green-500"></span> Live`;
                    statusElement.classList.remove('bg-red-900/20', 'text-red-500');
                    statusElement.classList.add('bg-green-900/20', 'text-green-500');
                } else {
                    // Non-200 status: show "Offline" with red dot.
                    statusElement.innerHTML = `<span class="w-2 h-2 rounded-full bg-red-500"></span> Offline`;
                    statusElement.classList.remove('bg-green-900/20', 'text-green-500');
                    statusElement.classList.add('bg-red-900/20', 'text-red-500');
                }
            } catch (error) {
                // Network error or exception: show "Offline" with red dot.
                statusElement.innerHTML = `<span class="w-2 h-2 rounded-full bg-red-500"></span> Offline`;
                statusElement.classList.remove('bg-green-900/20', 'text-green-500');
                statusElement.classList.add('bg-red-900/20', 'text-red-500');
            }
        }

        // Immediately check health and then every 2 minutes (120000 ms)
        pingHealth();
        setInterval(pingHealth, 2 * 60 * 1000);


        // Function to ensure clean join process
        function cleanJoinProcess() {
            // Reset any lingering UI states
            setupScreen.classList.remove('fade-scale');
            conferenceScreen.classList.remove('exiting');

            // Ensure clean slate for conference screen
            if (videoContainer) {
                // Keep only local video wrapper
                const localWrapper = document.querySelector('.video-wrapper.local');
                if (!localWrapper) {
                    videoContainer.innerHTML = `
                        <div class="video-wrapper local">
                            <video id="localVideo" autoplay muted playsinline></video>
                            <div class="video-overlay">You</div>
                            <div class="status-indicator"></div>
                            <div id="localStats" class="video-overlay stats">Connecting...</div>
                        </div>
                    `;
                }
            }

            // Clear any lingering messages or notifications
            document.querySelectorAll('.participant-notification').forEach(el => el.remove());
            const meetingEndMessage = document.getElementById('meetingEndMessage');
            if (meetingEndMessage) {
                meetingEndMessage.remove();
            }

            // Reset any screen or room handling flags
            window.isHandlingRoomClosure = false;

            // Make sure all buttons are enabled
            if (leaveCallButton) leaveCallButton.disabled = false;
            if (toggleAudioButton) toggleAudioButton.classList.remove('active');
            if (toggleVideoButton) toggleVideoButton.classList.remove('active');
            if (shareScreenButton) shareScreenButton.classList.remove('active');
        }

        // Device permission handling system
        async function checkMediaPermissions() {
            const permissionStatus = {
                audio: false,
                video: false,
                error: null
            };

            try {
                // First check if the browser supports the permissions API
                if (navigator.permissions && navigator.permissions.query) {
                    try {
                        // Check camera permission
                        const cameraPermission = await navigator.permissions.query({ name: 'camera' });
                        permissionStatus.video = cameraPermission.state === 'granted';

                        // Check microphone permission
                        const micPermission = await navigator.permissions.query({ name: 'microphone' });
                        permissionStatus.audio = micPermission.state === 'granted';

                        // Add permission change listeners
                        cameraPermission.addEventListener('change', () => {
                            handlePermissionChange('video', cameraPermission.state);
                        });

                        micPermission.addEventListener('change', () => {
                            handlePermissionChange('audio', micPermission.state);
                        });
                    } catch (e) {
                        console.warn('Permissions API not fully supported, falling back to getUserMedia check');
                        await fallbackPermissionCheck(permissionStatus);
                    }
                } else {
                    await fallbackPermissionCheck(permissionStatus);
                }
            } catch (error) {
                permissionStatus.error = error.message;
                console.error('Error checking permissions:', error);
            }

            return permissionStatus;
        }

        async function fallbackPermissionCheck(permissionStatus) {
            try {
                // Try to get both audio and video permissions
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                permissionStatus.audio = true;
                permissionStatus.video = true;

                // Stop all tracks immediately
                stream.getTracks().forEach(track => track.stop());
            } catch (error) {
                // If the combined request fails, try individual requests
                try {
                    const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    permissionStatus.audio = true;
                    audioStream.getTracks().forEach(track => track.stop());
                } catch (e) {
                    permissionStatus.audio = false;
                }

                try {
                    const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    permissionStatus.video = true;
                    videoStream.getTracks().forEach(track => track.stop());
                } catch (e) {
                    permissionStatus.video = false;
                }
            }
        }

        // Helper function to guide users to browser settings
        function showPermissionSettingsGuide(deviceType) {
            const browser = detectBrowser();
            let instructions = '';

            switch (browser) {
                case 'chrome':
                    instructions = `
                        To enable ${deviceType} access in Chrome:
                        1. Click the lock/info icon in the address bar
                        2. Click "Site settings"
                        3. Allow ${deviceType} access
                        4. Refresh the page
                    `;
                    break;
                case 'firefox':
                    instructions = `
                        To enable ${deviceType} access in Firefox:
                        1. Click the lock/info icon in the address bar
                        2. Click the gear icon (Site Settings)
                        3. Find "${deviceType}" and select "Allow"
                        4. Refresh the page
                    `;
                    break;
                case 'safari':
                    instructions = `
                        To enable ${deviceType} access in Safari:
                        1. Click Safari in the menu bar
                        2. Click "Settings for This Website"
                        3. Allow ${deviceType} access
                        4. Refresh the page
                    `;
                    break;
                case 'edge':
                    instructions = `
                        To enable ${deviceType} access in Edge:
                        1. Click the lock/info icon in the address bar
                        2. Click "Site permissions"
                        3. Allow ${deviceType} access
                        4. Refresh the page
                    `;
                    break;
                default:
                    instructions = `
                        To enable ${deviceType} access:
                        1. Check your browser settings
                        2. Look for site permissions or privacy settings
                        3. Allow ${deviceType} access for this site
                        4. Refresh the page
                    `;
            }

            // Create a modal to show the instructions
            const modal = document.createElement('div');
            modal.className = 'permission-guide-modal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 24px;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                z-index: 10000;
                max-width: 400px;
                width: 90%;
                color: #333;
            `;

            const title = document.createElement('h3');
            title.textContent = `Enable ${deviceType.charAt(0).toUpperCase() + deviceType.slice(1)} Access`;
            title.style.cssText = `
                margin: 0 0 16px 0;
                color: #1a73e8;
                font-size: 18px;
            `;

            const content = document.createElement('div');
            content.style.whiteSpace = 'pre-line';
            content.style.lineHeight = '1.5';
            content.textContent = instructions;

            const closeButton = document.createElement('button');
            closeButton.textContent = 'Got it';
            closeButton.style.cssText = `
                margin-top: 20px;
                padding: 8px 16px;
                background: #1a73e8;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.2s;
            `;
            closeButton.onmouseover = () => closeButton.style.background = '#1557b0';
            closeButton.onmouseout = () => closeButton.style.background = '#1a73e8';
            closeButton.onclick = () => {
                modal.remove();
                overlay.remove();
            };

            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 9999;
            `;
            overlay.onclick = () => {
                modal.remove();
                overlay.remove();
            };

            modal.appendChild(title);
            modal.appendChild(content);
            modal.appendChild(closeButton);
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
        }

        // Browser detection helper
        function detectBrowser() {
            const userAgent = navigator.userAgent.toLowerCase();

            if (userAgent.includes('chrome')) return 'chrome';
            if (userAgent.includes('firefox')) return 'firefox';
            if (userAgent.includes('safari') && !userAgent.includes('chrome')) return 'safari';
            if (userAgent.includes('edg')) return 'edge';
            return 'unknown';
        }

        // Update handlePermissionChange to use the guide
        function handlePermissionChange(deviceType, state) {
            console.log(`${deviceType} permission changed to: ${state}`);

            const statusText = document.getElementById('statusText');
            const toggleButton = deviceType === 'video' ? toggleVideoButton : toggleAudioButton;

            if (state === 'denied') {
                toggleButton.classList.add('disabled');
                showNotification(`${deviceType === 'video' ? 'Camera' : 'Microphone'} access was denied.`, 'error', 5000);

                // Show the permission settings guide
                showPermissionSettingsGuide(deviceType === 'video' ? 'camera' : 'microphone');

                if (deviceType === 'video') {
                    document.querySelectorAll('.video-wrapper.local').forEach(wrapper => {
                        wrapper.classList.add('camera-disabled');
                    });
                }
            } else if (state === 'granted') {
                toggleButton.classList.remove('disabled');
                showNotification(`${deviceType === 'video' ? 'Camera' : 'Microphone'} access granted.`, 'success', 3000);

                if (deviceType === 'video') {
                    document.querySelectorAll('.video-wrapper.local').forEach(wrapper => {
                        wrapper.classList.remove('camera-disabled');
                    });
                }

                reinitializeDevice(deviceType);
            }
        }

        async function reinitializeDevice(deviceType) {
            try {
                if (!localStream) return;

                const constraints = deviceType === 'video' ?
                    { video: mediaConstraints.video } :
                    { audio: mediaConstraints.audio };

                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                const track = deviceType === 'video' ?
                    newStream.getVideoTracks()[0] :
                    newStream.getAudioTracks()[0];

                if (track) {
                    // Replace the existing track in the local stream
                    const oldTrack = deviceType === 'video' ?
                        localStream.getVideoTracks()[0] :
                        localStream.getAudioTracks()[0];

                    if (oldTrack) {
                        oldTrack.stop();
                        localStream.removeTrack(oldTrack);
                    }

                    localStream.addTrack(track);

                    // Update all peer connections
                    Object.values(peerConnections).forEach(pc => {
                        const senders = pc.getSenders();
                        const sender = senders.find(s => s.track && s.track.kind === deviceType);
                        if (sender) {
                            sender.replaceTrack(track);
                        }
                    });

                    // Update local video if it's a video track
                    if (deviceType === 'video' && localVideo) {
                        localVideo.srcObject = localStream;
                    }

                    showNotification(`${deviceType === 'video' ? 'Camera' : 'Microphone'} access restored`, 'success', 3000);
                }
            } catch (error) {
                console.error(`Error reinitializing ${deviceType}:`, error);
                showNotification(`Failed to reinitialize ${deviceType}. Please check your settings.`, 'error', 5000);
            }
        }

        // Update the joinRoom function to use the new permission system
        async function joinRoom() {
            event.preventDefault();

            userName = userNameInput.value.trim();
            if (!userName) {
                alert('Please enter your name');
                return;
            }

            // Initialize WebSocket signaling
            const signaling = new WebSocketSignaling(userName);

            // Get room ID or generate a new one
            roomId = roomIdInput.value.trim();
            const isNewRoom = !roomId; // Flag to track if this is a new room
            if (isNewRoom) {
                roomId = generateRoomId();
            }

            // Display room ID
            currentRoomIdSpan.textContent = roomId;

            try {
                // Show a loading indicator
                statusText.textContent = 'Initializing...';
                statusText.className = 'status-text status-warning';

                // First enumerate devices to populate dropdowns
                await updateAudioDevices();
                await updateCameraDevices();

                // Then get media stream
                localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                await applyLowLatencySettings(localStream);

                // Store the initial microphone and camera IDs
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    const settings = audioTrack.getSettings();
                    currentMicrophoneId = settings.deviceId;
                    if (micSelect) {
                        micSelect.value = currentMicrophoneId;
                    }
                }

                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    currentCameraId = settings.deviceId;
                    if (cameraSelect) {
                        cameraSelect.value = currentCameraId;
                    }
                }

                // Handle localVideo reference
                // First try to get the current element if it exists
                const localVideoElement = document.getElementById('localVideo');
                if (localVideoElement) {
                    // Update the srcObject of the existing element
                    localVideoElement.srcObject = localStream;
                } else if (localVideo) {
                    // If the localVideo variable is defined but element doesn't exist in DOM
                    localVideo.srcObject = localStream;
                }

                // Apply proper transition from join to conference screen
                setupScreen.classList.remove('fade-scale');
                setupScreen.style.display = 'none';

                // Make sure conference screen is visible with animation
                conferenceScreen.style.display = 'block';
                conferenceScreen.classList.add('fade-scale');

                // Explicitly remove any properties that might interfere
                conferenceScreen.style.position = '';
                conferenceScreen.style.top = '';
                conferenceScreen.style.left = '';

                // Pass isNewRoom flag to identify the host
                const userId = signaling.joinRoom(roomId, isNewRoom);
                setupSignalingListeners(signaling);
                window.signaling = signaling;

                // Update the UI to show host status
                if (isNewRoom) {
                    document.querySelector('.video-wrapper.local .video-overlay').textContent = 'You (Host)';
                }

                // Ensure references are up to date with new DOM elements
                if (window.domReferences) {
                    window.domReferences.ensureReferences();
                }

                startNetworkMonitoring();

            } catch (error) {
                console.error('Error accessing media devices:', error);
                alert('Could not access camera and microphone. Please check permissions.');

                // Reset UI on error
                setupScreen.style.display = 'flex';
                conferenceScreen.style.display = 'none';
                statusText.textContent = 'Ready to join';
                statusText.className = 'status-text';
            }
        }

        // Apply low latency encoding settings to the stream
        async function applyLowLatencySettings(stream) {
            // Check and log audio tracks
            const audioTracks = stream.getAudioTracks();
            console.log(`Audio tracks available: ${audioTracks.length}`);

            if (audioTracks.length > 0) {
                const audioTrack = audioTracks[0];
                console.log('Audio track found:', audioTrack.label, 'enabled:', audioTrack.enabled);

                // Ensure audio track is enabled
                if (!audioTrack.enabled) {
                    console.log('Enabling audio track');
                    audioTrack.enabled = true;
                }

                // Log audio constraints
                if (typeof audioTrack.getConstraints === 'function') {
                    const audioConstraints = audioTrack.getConstraints();
                    console.log('Current audio constraints:', audioConstraints);
                }

                // Log audio settings
                if (typeof audioTrack.getSettings === 'function') {
                    const audioSettings = audioTrack.getSettings();
                    console.log('Current audio settings:', audioSettings);
                }
            } else {
                console.warn('No audio tracks found in the stream');
            }

            // Process video settings as before
            const videoTrack = stream.getVideoTracks()[0];

            if (videoTrack && typeof videoTrack.getConstraints === 'function') {
                // Log current video settings
                const settings = videoTrack.getSettings();
                console.log('Current video settings:', settings);

                // Try to set encoding parameters if supported
                if (RTCRtpSender.getCapabilities && RTCRtpSender.getCapabilities('video')) {
                    const capabilities = RTCRtpSender.getCapabilities('video');
                    console.log('Video encoding capabilities:', capabilities);

                    // Find the best codec for low latency
                    const preferredCodecs = ['VP9', 'H264', 'VP8'];
                    let selectedCodec = null;

                    for (const preferred of preferredCodecs) {
                        const codec = capabilities.codecs.find(c =>
                            c.mimeType.toLowerCase().includes(preferred.toLowerCase()));
                        if (codec) {
                            selectedCodec = codec;
                            break;
                        }
                    }

                    if (selectedCodec) {
                        console.log('Selected codec for low latency:', selectedCodec);
                    }
                }

                // Apply optimal constraints for low latency
                const constraints = {
                    width: { ideal: settings.width || 1280 },
                    height: { ideal: settings.height || 720 },
                    frameRate: { ideal: 30, max: 60 },
                    aspectRatio: { ideal: settings.aspectRatio || 16 / 9 },
                    deviceId: { exact: settings.deviceId }
                };

                try {
                    await videoTrack.applyConstraints(constraints);
                    console.log('Successfully applied video constraints:', constraints);

                    // Verify the applied settings
                    const newSettings = videoTrack.getSettings();
                    console.log('New video settings after constraints:', newSettings);
                } catch (e) {
                    console.error('Error applying video constraints:', e);
                    // Fallback to less strict constraints if exact constraints fail
                    try {
                        const fallbackConstraints = {
                            ...constraints,
                            deviceId: { ideal: settings.deviceId }
                        };
                        await videoTrack.applyConstraints(fallbackConstraints);
                        console.log('Applied fallback video constraints:', fallbackConstraints);
                    } catch (fallbackError) {
                        console.error('Error applying fallback video constraints:', fallbackError);
                    }
                }
            }

            // Apply audio optimizations
            const audioTrack = stream.getAudioTracks()[0];
            if (audioTrack) {
                try {
                    await audioTrack.applyConstraints({
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        latency: { ideal: 0.01 }
                    });
                    console.log('Successfully applied audio constraints');
                } catch (e) {
                    console.error('Error applying audio constraints:', e);
                }
            }
        }

        // Generate a random room ID
        function generateRoomId() {
            return 'room_' + Math.random().toString(36).substr(2, 9);
        }

        // Copy room ID to clipboard
        function copyRoomId() {
            navigator.clipboard.writeText(roomId).then(() => {
                const originalText = copyRoomIdButton.textContent;
                copyRoomIdButton.textContent = 'Copied!';
                setTimeout(() => {
                    copyRoomIdButton.textContent = originalText;
                }, 2000);
            });
        }

        // Toggle audio
        function toggleAudio() {
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                console.log(`Toggling audio. Found ${audioTracks.length} audio tracks`);

                if (audioTracks.length > 0) {
                    const audioTrack = audioTracks[0];
                    const currentState = audioTrack.enabled;
                    audioTrack.enabled = !currentState;
                    console.log(`Audio track '${audioTrack.label}' toggled from ${currentState} to ${audioTrack.enabled}`);

                    // Update UI - only toggle button state for local user
                    toggleAudioButton.classList.toggle('active');

                    // Notify peers of audio state change if signaling is available
                    if (window.signaling && window.signaling.broadcast) {
                        const message = {
                            kind: 'audio',
                            enabled: audioTrack.enabled,
                            userId: window.signaling.userId
                        };
                        window.signaling.broadcast(message);
                    }
                }
            }
        }

        // Toggle video
        function toggleVideo() {
            if (localStream) {
                if (isScreenSharing) {
                    // When screen sharing, toggle the camera overlay instead
                    if (window.originalCameraTrack) {
                        window.originalCameraTrack.enabled = !window.originalCameraTrack.enabled;

                        // Update the camera overlay visibility to match the enabled state
                        const cameraOverlay = document.getElementById('cameraOverlay');
                        if (cameraOverlay) {
                            if (!window.originalCameraTrack.enabled) {
                                cameraOverlay.classList.add('camera-disabled');
                            } else {
                                cameraOverlay.classList.remove('camera-disabled');
                            }
                        }

                        // Also update other peers to see your camera disabled
                        Object.values(peerConnections).forEach(pc => {
                            const senders = pc.getSenders();
                            const cameraSender = senders.find(sender =>
                                sender.track && sender.track.kind === 'video' &&
                                sender.track.label === window.originalCameraTrack.label);

                            if (cameraSender && cameraSender.track) {
                                cameraSender.track.enabled = window.originalCameraTrack.enabled;
                            }
                        });

                        toggleVideoButton.classList.toggle('active');
                    }
                } else {
                    // Normal mode - toggle the main video track
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        toggleVideoButton.classList.toggle('active');
                    }
                }
            }
        }

        // Function to detect mobile devices
        function isMobileDevice() {
            return (
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /Mobi|Android/i.test(navigator.userAgent))
            );
        }

        // Function to detect iOS devices specifically
        function isIOSDevice() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // Function to detect Android devices specifically
        function isAndroidDevice() {
            return /Android/i.test(navigator.userAgent);
        }

        // Function to show a notification
        function showNotification(message, type = 'info', duration = 5000) {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `<div class="notification-content">${message}</div>`;

            document.body.appendChild(notification);

            // Add showing class for animation
            setTimeout(() => {
                notification.classList.add('showing');
            }, 10);

            // Auto dismiss after duration
            setTimeout(() => {
                notification.classList.remove('showing');
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, duration);
        }

        // Toggle screen sharing with mobile device support
        async function toggleScreenShare() {
            try {
                if (!isScreenSharing) {
                    // Store current audio track before screen sharing
                    const currentAudioTrack = localStream.getAudioTracks()[0];

                    // Default desktop handling with explicit audio capture
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            cursor: 'always',
                            displaySurface: 'monitor'
                        }
                    });

                    // Add the current audio track to screen stream
                    if (currentAudioTrack) {
                        screenStream.addTrack(currentAudioTrack);
                    }

                    handleScreenShareSuccess(screenStream);
                } else {
                    await stopScreenShare();
                }
            } catch (error) {
                console.error('Error sharing screen:', error);
                showNotification('Could not share screen. Please check permissions.', 'error');
                isScreenSharing = false;
                shareScreenButton.classList.remove('active');
            }
        }

        // Handle successful screen share acquisition
        function handleScreenShareSuccess(screenStream) {
            const screenTrack = screenStream.getVideoTracks()[0];
            window.originalCameraTrack = localStream.getVideoTracks()[0];
            const existingAudioTrack = localStream.getAudioTracks()[0];

            // Keep track of the original stream's audio track
            window.originalAudioTrack = existingAudioTrack;

            // Replace tracks in all peer connections
            Promise.all(Object.values(peerConnections).map(async pc => {
                try {
                    const transceivers = pc.getTransceivers();
                    console.log('Current transceivers:', transceivers.map(t => ({
                        mid: t.mid,
                        kind: t.receiver.track?.kind,
                        currentDirection: t.direction
                    })));

                    // First ensure we have all necessary transceivers in the correct order
                    if (transceivers.length === 0) {
                        // If no transceivers exist, create them in the correct order
                        pc.addTransceiver('audio', { direction: 'sendrecv' });
                        pc.addTransceiver('video', { direction: 'sendrecv' });
                        pc.addTransceiver('video', { direction: 'sendrecv' });
                    }

                    // Get updated transceivers after ensuring they exist
                    const updatedTransceivers = pc.getTransceivers();

                    // Replace tracks in existing transceivers
                    for (let i = 0; i < updatedTransceivers.length; i++) {
                        const transceiver = updatedTransceivers[i];

                        if (transceiver.receiver.track.kind === 'audio' && existingAudioTrack) {
                            console.log('Replacing audio track in transceiver:', transceiver.mid);
                            await transceiver.sender.replaceTrack(existingAudioTrack);
                        } else if (transceiver.receiver.track.kind === 'video') {
                            if (i === 1) { // First video transceiver gets screen share
                                console.log('Replacing video track with screen share in transceiver:', transceiver.mid);
                                await transceiver.sender.replaceTrack(screenTrack);
                            } else if (i === 2) { // Second video transceiver gets camera
                                console.log('Replacing video track with camera in transceiver:', transceiver.mid);
                                await transceiver.sender.replaceTrack(window.originalCameraTrack);
                            }
                        }
                    }

                    // Create offer while maintaining the order
                    const offer = await pc.createOffer();

                    // Log the SDP for debugging
                    console.log('Generated offer SDP:', offer.sdp);

                    // Set local description
                    await pc.setLocalDescription(offer);

                    // Send the offer through signaling
                    if (window.signaling && pc.remoteUserId) {
                        window.signaling.sendOffer(pc.remoteUserId, pc.localDescription);
                    }
                } catch (e) {
                    console.error('Error updating tracks for screen share:', e);
                    // Try to recover by renegotiating
                    try {
                        if (pc.signalingState === 'stable') {
                            const offer = await pc.createOffer();
                            await pc.setLocalDescription(offer);
                            if (window.signaling && pc.remoteUserId) {
                                window.signaling.sendOffer(pc.remoteUserId, pc.localDescription);
                            }
                        }
                    } catch (recoveryError) {
                        console.error('Recovery attempt failed:', recoveryError);
                    }
                }
            }));

            // Update local video while preserving audio
            const newLocalStream = new MediaStream();
            newLocalStream.addTrack(screenTrack);
            if (existingAudioTrack) {
                newLocalStream.addTrack(existingAudioTrack);
            }
            localVideo.srcObject = newLocalStream;

            // Update the local stream reference
            localStream = newLocalStream;

            // Create camera overlay with the original camera feed
            createCameraOverlay();

            screenTrack.onended = async () => {
                await stopScreenShare();
            };

            isScreenSharing = true;
            shareScreenButton.classList.add('active');
        }

        // Function to create camera overlay for screen sharing
        function createCameraOverlay() {
            // Create camera overlay if it doesn't exist
            let cameraOverlay = document.getElementById('cameraOverlay');
            if (!cameraOverlay) {
                cameraOverlay = document.createElement('div');
                cameraOverlay.id = 'cameraOverlay';
                cameraOverlay.className = 'camera-overlay';

                const cameraVideo = document.createElement('video');
                cameraVideo.id = 'cameraVideo';
                cameraVideo.autoplay = true;
                cameraVideo.muted = true;
                cameraVideo.playsInline = true;

                const nameOverlay = document.createElement('div');
                nameOverlay.className = 'video-overlay';
                nameOverlay.textContent = 'You';

                cameraOverlay.appendChild(cameraVideo);
                cameraOverlay.appendChild(nameOverlay);
                document.body.appendChild(cameraOverlay);
            }

            // Create a new stream with the original camera track for the overlay
            const cameraStream = new MediaStream([window.originalCameraTrack]);
            document.getElementById('cameraVideo').srcObject = cameraStream;

            // Show the camera overlay
            cameraOverlay.classList.add('active');

            // Make the local video wrapper show the screen share properly
            document.querySelector('.video-wrapper.local').classList.add('screen-sharing');
        }

        // Update stopScreenShare function to use transceivers
        async function stopScreenShare() {
            try {
                if (!window.originalCameraTrack) {
                    const cameraStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                    window.originalCameraTrack = cameraStream.getVideoTracks()[0];
                }

                // Replace tracks in all peer connections
                await Promise.all(Object.values(peerConnections).map(async pc => {
                    try {
                        const transceivers = pc.getTransceivers();

                        // Replace tracks in existing transceivers
                        for (const transceiver of transceivers) {
                            if (transceiver.receiver.track.kind === 'video') {
                                // Replace all video tracks with the camera track
                                await transceiver.sender.replaceTrack(window.originalCameraTrack);
                            }
                        }

                        // Create and send offer
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);

                        if (window.signaling && pc.remoteUserId) {
                            window.signaling.sendOffer(pc.remoteUserId, pc.localDescription);
                        }
                    } catch (e) {
                        console.error('Error updating tracks when stopping screen share:', e);
                    }
                }));

                // Stop screen share track
                localStream.getVideoTracks().forEach(track => {
                    if (track.label !== window.originalCameraTrack.label) {
                        track.stop();
                    }
                });

                // Create new stream with camera and original audio
                const newLocalStream = new MediaStream();
                newLocalStream.addTrack(window.originalCameraTrack);
                if (window.originalAudioTrack) {
                    newLocalStream.addTrack(window.originalAudioTrack);
                }

                // Update local stream reference and video element
                localStream = newLocalStream;
                localVideo.srcObject = localStream;

                // Update UI
                document.querySelector('.video-wrapper.local').classList.remove('screen-sharing');
                const cameraOverlay = document.getElementById('cameraOverlay');
                if (cameraOverlay) {
                    cameraOverlay.remove();
                }

                isScreenSharing = false;
                shareScreenButton.classList.remove('active');
            } catch (error) {
                console.error('Error stopping screen share:', error);
                showNotification('Error stopping screen share', 'error');
            }
        }

        // Leave the call
        function leaveCall() {
            console.log('leaveCall function triggered, isHost:', window.signaling?.isHost);

            // Update status text immediately
            statusText.textContent = 'Leaving meeting...';
            statusText.className = 'status-text status-warning';

            // Disable leave button to prevent double-clicks
            leaveCallButton.disabled = true;

            // Store host status before we reset it
            const wasHost = window.signaling?.isHost || false;
            const roomIdCopy = roomId;  // Store for reference after reset

            // Flag to track if we've successfully sent the leave message
            let leaveSent = false;

            try {
                // Apply animation to all video elements
                const videoWrappers = document.querySelectorAll('.video-wrapper');
                console.log(`Applying leaving animation to ${videoWrappers.length} video wrappers`);
                videoWrappers.forEach(wrapper => {
                    wrapper.classList.add('leaving');
                });

                // Add exiting class to conference screen for smooth transition
                conferenceScreen.classList.add('exiting');

                // Try to send leave/close room message first
                if (window.signaling && window.signaling.ws && window.signaling.ws.readyState === WebSocket.OPEN) {
                    console.log('Sending leave/close room message');
                    leaveSent = wasHost ?
                        window.signaling.closeRoom() :
                        window.signaling.leaveRoom();

                    console.log(`${wasHost ? 'Close' : 'Leave'} room message sent:`, leaveSent);

                    // If we're the host and message failed, show error
                    if (wasHost && !leaveSent) {
                        showParticipantNotification('Failed to close room. Other participants may still be connected.', 'warning');
                    }
                } else {
                    console.warn('WebSocket not available for leave message');
                    // Even if WebSocket is not available, we'll still clean up local resources
                }

                // Wait for animation to complete
                setTimeout(() => {
                    console.log('Animation completed, cleaning up resources');

                    // Clean up all resources efficiently
                    cleanupResources();

                    // Reset UI
                    resetUI();

                    // Show notification based on host status
                    if (wasHost) {
                        showParticipantNotification(`Meeting ended. Room ${roomIdCopy} has been closed.`, 'info');
                    } else {
                        showParticipantNotification('You left the meeting', 'leave');
                    }

                    console.log('Leave call complete');

                    // Re-enable leave button (although it's now hidden)
                    leaveCallButton.disabled = false;
                }, 650); // Slightly longer than animation to ensure completion

            } catch (error) {
                console.error('Error in leaveCall:', error);

                // Even if there's an error, make sure we clean up
                cleanupResources();
                resetUI();

                // Show error notification
                showParticipantNotification('Error leaving meeting. Resources have been cleaned up.', 'warning');

                // Re-enable leave button (although it's now hidden)
                leaveCallButton.disabled = false;
            }
        }

        // Function to clean up all resources efficiently
        function cleanupResources() {
            console.log('Starting resource cleanup');

            try {
                // 1. Stop all media tracks with careful error handling
                if (localStream) {
                    console.log('Stopping local media tracks');
                    try {
                        localStream.getTracks().forEach(track => {
                            try {
                                track.stop();
                                console.log(`Stopped ${track.kind} track: ${track.label}`);
                            } catch (e) {
                                console.error(`Error stopping ${track.kind} track:`, e);
                            }
                        });
                        localStream = null;
                    } catch (e) {
                        console.error('Error stopping local stream:', e);
                    }
                }

                // 2. Clean up all peer connections
                Object.entries(peerConnections).forEach(([userId, pc]) => {
                    try {
                        // Stop all remote tracks
                        const remoteStreams = pc.getRemoteStreams();
                        remoteStreams.forEach(stream => {
                            stream.getTracks().forEach(track => {
                                try {
                                    track.stop();
                                    console.log(`Stopped remote ${track.kind} track for user ${userId}`);
                                } catch (e) {
                                    console.error(`Error stopping remote track for user ${userId}:`, e);
                                }
                            });
                        });

                        // Stop all local tracks being sent to this peer
                        if (pc.getSenders) {
                            pc.getSenders().forEach(sender => {
                                if (sender.track) {
                                    try {
                                        sender.track.stop();
                                        console.log(`Stopped sender track for user ${userId}`);
                                    } catch (e) {
                                        console.error(`Error stopping sender track for user ${userId}:`, e);
                                    }
                                }
                            });
                        }

                        // Clear any stats intervals
                        if (pc.statsIntervalId) {
                            clearInterval(pc.statsIntervalId);
                        }

                        // Close the connection
                        pc.close();
                        console.log(`Closed peer connection for user ${userId}`);
                    } catch (e) {
                        console.error(`Error cleaning up peer connection for user ${userId}:`, e);
                    }
                });

                // Clear all peer connections
                peerConnections = {};

                // 3. Clean up video elements
                const videoContainer = document.getElementById('videoContainer');
                if (videoContainer) {
                    const videos = videoContainer.getElementsByTagName('video');
                    Array.from(videos).forEach(video => {
                        try {
                            if (video.srcObject) {
                                const stream = video.srcObject;
                                stream.getTracks().forEach(track => {
                                    try {
                                        track.stop();
                                    } catch (e) {
                                        console.error('Error stopping video track:', e);
                                    }
                                });
                                video.srcObject = null;
                            }
                        } catch (e) {
                            console.error('Error cleaning up video element:', e);
                        }
                    });
                }

                console.log('Resource cleanup completed');
            } catch (error) {
                console.error('Error during resource cleanup:', error);
                // Even if there's an error, try to clear peer connections
                peerConnections = {};
            }
        }

        // Function to reset UI state
        function resetUI() {
            console.log('Resetting UI state');

            try {
                // Reset screen visibility with transition
                conferenceScreen.style.display = 'none';

                // Apply proper setup screen display style and animation
                setupScreen.style.display = 'flex'; // Use flex instead of block to center content

                // Remove any custom styles that might have been applied
                setupScreen.style.position = '';
                setupScreen.style.top = '';
                setupScreen.style.left = '';
                setupScreen.style.transform = '';

                // First add fade-out and then remove it when transition completes
                // This ensures smooth transition between screens
                setupScreen.classList.add('fade-scale');

                // Reset animation states on conferenceScreen
                conferenceScreen.classList.remove('exiting');
                conferenceScreen.classList.add('fade-scale');

                // Reset form fields but keep the username for convenience
                roomIdInput.value = '';
                // Don't clear username: userNameInput.value = '';

                // Reset button states
                shareScreenButton.classList.remove('active');
                toggleVideoButton.classList.remove('active');
                toggleAudioButton.classList.remove('active');
                leaveCallButton.disabled = false;

                // Reset video container animations
                videoContainer.classList.remove('video-container-closing');

                // Empty and recreate video container for clean slate
                videoContainer.innerHTML = '';

                // Create a fresh local video element for next call
                const newLocalVideoWrapper = document.createElement('div');
                newLocalVideoWrapper.className = 'video-wrapper local';
                newLocalVideoWrapper.innerHTML = `
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-overlay">You</div>
                    <div class="status-indicator"></div>
                    <div id="localStats" class="video-overlay stats">Connecting...</div>
                `;
                videoContainer.appendChild(newLocalVideoWrapper);

                // Reset streams on existing video elements (without reassigning variables)
                // Clear existing video stream if it exists
                if (localVideo && localVideo.srcObject) {
                    const oldStream = localVideo.srcObject;
                    if (oldStream) {
                        oldStream.getTracks().forEach(track => {
                            track.stop();
                        });
                    }
                    localVideo.srcObject = null;
                }

                // Reset room ID display
                currentRoomIdSpan.textContent = '';

                // Reset status text
                statusText.textContent = 'Ready to join';
                statusText.className = 'status-text';

                // Clear any room-specific data that might be persisted in the UI
                document.querySelectorAll('.camera-overlay').forEach(el => el.remove());
                document.querySelectorAll('.remote-camera-overlay').forEach(el => el.remove());

                // Reset any toggles or switched states
                if (window.originalCameraTrack) {
                    window.originalCameraTrack = null;
                }

                // Ensure our references are updated for the new elements
                if (window.domReferences && typeof window.domReferences.ensureReferences === 'function') {
                    window.domReferences.ensureReferences();
                }

                console.log('UI reset complete');
            } catch (error) {
                console.error('Error resetting UI:', error);

                // Emergency reset in case of error
                try {
                    conferenceScreen.style.display = 'none';
                    setupScreen.style.display = 'flex'; // Use flex for proper centering

                    // Reset any custom positioning
                    setupScreen.style.position = '';
                    setupScreen.style.top = '';
                    setupScreen.style.left = '';
                    setupScreen.style.transform = '';

                    // Minimal reset without reassigning variables
                    if (videoContainer) {
                        videoContainer.innerHTML = `
                            <div class="video-wrapper local">
                                <video id="localVideo" autoplay muted playsinline></video>
                                <div class="video-overlay">You</div>
                                <div class="status-indicator"></div>
                                <div id="localStats" class="video-overlay stats">Connecting...</div>
                            </div>
                        `;
                    }

                    if (statusText) {
                        statusText.textContent = 'Ready to join';
                        statusText.className = 'status-text';
                    }

                    // Clear any existing streams without reassigning variables
                    if (localVideo && localVideo.srcObject) {
                        const oldStream = localVideo.srcObject;
                        if (oldStream) {
                            oldStream.getTracks().forEach(track => {
                                track.stop();
                            });
                        }
                        localVideo.srcObject = null;
                    }

                    // Try to update references as a last resort
                    if (window.domReferences && typeof window.domReferences.ensureReferences === 'function') {
                        window.domReferences.ensureReferences();
                    }

                } catch (e) {
                    console.error('Emergency UI reset failed:', e);
                }
            }
        }

        // Function to handle room closure from server or host
        function handleRoomClosure(reason, isLocalClose = false) {
            console.log(`Handling room closure: ${reason}, isLocalClose: ${isLocalClose}`);

            try {
                // Prevent multiple closures
                if (window.isHandlingRoomClosure) {
                    console.log('Already handling room closure, ignoring duplicate');
                    return;
                }
                window.isHandlingRoomClosure = true;

                // Show animated message
                showRoomClosedMessage(reason || 'This meeting has been ended by the host');

                // Apply closing animation to all videos
                videoContainer.classList.add('video-container-closing');

                // Set status text
                statusText.textContent = 'Meeting ended';
                statusText.className = 'status-text status-warning';

                // If this is a remote closure (we're not the host who closed it),
                // make sure we close our connections too
                if (!isLocalClose) {
                    // Local cleanup for remote closure
                    console.log('Remote room closure, cleaning up resources');

                    // Disable leave button to prevent double-clicks
                    leaveCallButton.disabled = true;

                    // Clean up and return to the join screen after animation
                    setTimeout(() => {
                        // Clean up all resources
                        cleanupResources();
                        resetUI();

                        // Show appropriate notification based on who closed the room
                        if (reason && reason.includes('host')) {
                            showParticipantNotification('Meeting ended by the host', 'info');
                        } else {
                            showParticipantNotification('Meeting ended', 'info');
                        }

                        // Reset handling flag
                        window.isHandlingRoomClosure = false;
                        leaveCallButton.disabled = false;
                    }, 800); // Match the room closure animation duration
                } else {
                    // For local closure (we're the host), we've already initiated leave call
                    // Just reset the handling flag after animation completes
                    setTimeout(() => {
                        window.isHandlingRoomClosure = false;
                    }, 800);
                }
            } catch (error) {
                console.error('Error handling room closure:', error);

                // Emergency cleanup
                try {
                    cleanupResources();
                    resetUI();
                    window.isHandlingRoomClosure = false;
                } catch (e) {
                    console.error('Error in emergency cleanup during room closure:', e);
                }
            }
        }

        // Function to show room closed message with animation
        function showRoomClosedMessage(message) {
            try {
                // Create message element if it doesn't exist
                let messageEl = document.getElementById('meetingEndMessage');
                if (!messageEl) {
                    messageEl = document.createElement('div');
                    messageEl.id = 'meetingEndMessage';
                    messageEl.className = 'meeting-end-message';
                    document.body.appendChild(messageEl);
                }

                // Set message text and show
                messageEl.textContent = message;

                // Force a reflow before adding the visible class for animation
                void messageEl.offsetWidth;
                messageEl.classList.add('visible');

                // Remove after animation
                setTimeout(() => {
                    messageEl.classList.remove('visible');
                    setTimeout(() => {
                        if (messageEl && messageEl.parentNode) {
                            messageEl.parentNode.removeChild(messageEl);
                        }
                    }, 400); // Match the opacity transition duration
                }, 2000); // Show message for 2 seconds
            } catch (error) {
                console.error('Error showing room closed message:', error);
            }
        }

        // Function to show participant notifications
        function showParticipantNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `participant-notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.classList.add('visible');
            }, 10);

            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.remove('visible');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }

        // Setup signaling event listeners
        function setupSignalingListeners(signaling) {
            // When a user joins the room
            signaling.on('user-joined', async (data) => {
                if (data.userId !== signaling.userId) {
                    console.log(`${data.userName} joined the room`);

                    // Show notification
                    showParticipantNotification(`${data.userName} joined the meeting`, 'join');

                    // Create a peer connection for the new user
                    const pc = createPeerConnection(data.userId, data.userName);

                    // If current user is screen sharing, ensure tracks are properly set
                    if (isScreenSharing && window.originalCameraTrack) {
                        try {
                            // Create a combined stream with both screen share and camera tracks
                            const screenTrack = localStream.getVideoTracks()[0];
                            const combinedStream = new MediaStream();

                            // Check if tracks already exist in the peer connection
                            const existingSenders = pc.getSenders();
                            const existingTracks = existingSenders.map(sender => sender.track?.id);

                            // Only add tracks that aren't already in the peer connection
                            if (!existingTracks.includes(screenTrack.id)) {
                                combinedStream.addTrack(screenTrack);
                                pc.addTrack(screenTrack, combinedStream);
                            }

                            if (!existingTracks.includes(window.originalCameraTrack.id)) {
                                combinedStream.addTrack(window.originalCameraTrack);
                                pc.addTrack(window.originalCameraTrack, combinedStream);
                            }

                            console.log(`Added screen share and camera tracks for new participant ${data.userName}`);
                        } catch (error) {
                            console.error(`Error adding tracks to peer connection for ${data.userName}:`, error);
                        }
                    }

                    // Create and send an offer (handled by negotiationneeded event)
                }
            });

            // When a user leaves the room
            signaling.on('user-left', (data) => {
                console.log(`${data.userName || 'A user'} left the meeting`);

                // Only show notification if it's not the current user leaving
                if (data.userName && data.userId !== signaling.userId) {
                    showParticipantNotification(`${data.userName} left the meeting`, 'leave');
                }

                // Find and cleanup the video wrapper
                const videoWrapper = document.getElementById(`video-wrapper-${data.userId}`);
                if (videoWrapper) {
                    // Add leaving animation
                    videoWrapper.classList.add('leaving');

                    // Remove element after animation completes
                    setTimeout(() => {
                        // Close peer connection with proper cleanup
                        const pc = peerConnections[data.userId];
                        if (pc) {
                            try {
                                // Only stop remote tracks from this specific peer
                                const remoteStreams = pc.getRemoteStreams();
                                remoteStreams.forEach(stream => {
                                    stream.getTracks().forEach(track => {
                                        track.stop();
                                    });
                                });

                                // Don't stop local tracks, just remove them from this peer connection
                                if (pc.getSenders) {
                                    pc.getSenders().forEach(sender => {
                                        try {
                                            if (sender.track) {
                                                // Instead of stopping the track, just remove it from the sender
                                                sender.replaceTrack(null);
                                            }
                                        } catch (e) {
                                            console.error(`Error removing track from sender for user ${userId}:`, e);
                                        }
                                    });
                                }

                                // Clear any stats intervals
                                if (pc.statsIntervalId) {
                                    clearInterval(pc.statsIntervalId);
                                }

                                // Close the connection
                                pc.close();
                                delete peerConnections[data.userId];

                                // Clear video srcObject
                                const video = videoWrapper.querySelector('video');
                                if (video && video.srcObject) {
                                    const stream = video.srcObject;
                                    stream.getTracks().forEach(track => {
                                        track.stop();
                                    });
                                    video.srcObject = null;
                                }
                            } catch (e) {
                                console.error(`Error cleaning up peer connection for user ${data.userId}:`, e);
                            }
                        }

                        // Remove video element after cleanup
                        videoWrapper.remove();

                        // Verify local video is still working
                        const localVideo = document.getElementById('localVideo');
                        if (localVideo && localVideo.srcObject) {
                            const tracks = localVideo.srcObject.getTracks();
                            if (tracks.length === 0 || tracks.every(track => track.readyState === 'ended')) {
                                console.log('Local video tracks ended, attempting to restore...');
                                // Attempt to restore local video if needed
                                if (localStream) {
                                    localVideo.srcObject = localStream;
                                }
                            }
                        }
                    }, 600); // Match animation duration
                } else {
                    // Fallback if element not found
                    const pc = peerConnections[data.userId];
                    if (pc) {
                        try {
                            // Only stop remote tracks
                            const remoteStreams = pc.getRemoteStreams();
                            remoteStreams.forEach(stream => {
                                stream.getTracks().forEach(track => {
                                    track.stop();
                                });
                            });

                            // Remove local tracks from peer connection without stopping them
                            if (pc.getSenders) {
                                pc.getSenders().forEach(sender => {
                                    if (sender.track) {
                                        sender.replaceTrack(null);
                                    }
                                });
                            }

                            if (pc.statsIntervalId) {
                                clearInterval(pc.statsIntervalId);
                            }

                            pc.close();
                            delete peerConnections[data.userId];
                        } catch (e) {
                            console.error(`Error cleaning up peer connection for user ${data.userId}:`, e);
                        }
                    }
                }
            });

            // When a user temporarily disconnects
            signaling.on('user-disconnected', (data) => {
                console.log(`${data.userName || 'A user'} temporarily disconnected`);

                // Show notification
                if (data.userName) {
                    showParticipantNotification(`${data.userName} disconnected (reconnecting...)`, 'warning');
                }

                // Update UI to show disconnected state
                const videoWrapper = document.getElementById(`video-wrapper-${data.userId}`);
                if (videoWrapper) {
                    videoWrapper.classList.add('disconnected');

                    // Update stats display
                    const statsDiv = document.getElementById(`stats-${data.userId}`);
                    if (statsDiv) {
                        statsDiv.textContent = 'Disconnected (reconnecting...)';
                    }
                }
            });

            // When a user reconnects
            signaling.on('user-reconnected', (data) => {
                const { userId, userName, wasHost, audioEnabled, videoEnabled } = data;
                console.log(`${userName} reconnected with audio: ${audioEnabled}, video: ${videoEnabled}`);

                // Show notification
                showNotification(`${userName} reconnected${wasHost ? ' (Previous Host)' : ''}`, 'success', 3000);

                // Update UI to show connected state
                const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                if (videoWrapper) {
                    videoWrapper.classList.remove('disconnected');
                    
                    // Update mute indicator based on audio state
                    const muteIndicator = videoWrapper.querySelector('.muted-indicator');
                    if (!audioEnabled) {
                        if (!muteIndicator) {
                            const indicator = document.createElement('div');
                            indicator.className = 'muted-indicator';
                            indicator.innerHTML = `
                                <i class="fas fa-microphone-slash"></i>
                                <span>Muted</span>
                            `;
                            videoWrapper.appendChild(indicator);
                        }
                    } else if (muteIndicator) {
                        muteIndicator.remove();
                    }

                    // Update video state
                    const videoElement = videoWrapper.querySelector('video');
                    if (videoElement) {
                        if (!videoEnabled) {
                            videoElement.style.display = 'none';
                            // Show avatar or placeholder
                            const placeholder = videoWrapper.querySelector('.video-placeholder') || 
                                document.createElement('div');
                            placeholder.className = 'video-placeholder';
                            placeholder.textContent = userName.charAt(0).toUpperCase();
                            videoWrapper.appendChild(placeholder);
                        } else {
                            videoElement.style.display = 'block';
                            const placeholder = videoWrapper.querySelector('.video-placeholder');
                            if (placeholder) {
                                placeholder.remove();
                            }
                        }
                    }

                    // Update stats display
                    const statsDiv = document.getElementById(`stats-${userId}`);
                    if (statsDiv) {
                        statsDiv.textContent = 'Reconnected';
                    }
                }

                // Re-establish WebRTC connection
                if (peerConnections[userId]) {
                    // Close existing connection
                    peerConnections[userId].close();
                    delete peerConnections[userId];
                }

                // Create new peer connection
                const pc = createPeerConnection(userId, userName);
                
                // Create and send offer
                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .then(() => {
                        signaling.send({
                            type: 'offer',
                            targetUserId: userId,
                            roomId: currentRoom,
                            sdp: pc.localDescription
                        });
                    })
                    .catch(error => {
                        console.error('Error creating offer after reconnection:', error);
                        showNotification('Failed to reconnect with peer. Please refresh the page.', 'error', 5000);
                    });
            });

            // When a new host is assigned
            signaling.on('new-host', (data) => {
                console.log(`${data.userName} is now the host`);

                // Show notification
                showParticipantNotification(`${data.userName} is now the host`, 'info');

                // Update UI to show new host
                const videoWrapper = document.getElementById(`video-wrapper-${data.userId}`);
                if (videoWrapper) {
                    const nameOverlay = videoWrapper.querySelector('.video-overlay');
                    if (nameOverlay) {
                        nameOverlay.textContent = `${data.userName} (Host)`;
                    }
                }

                // If this is us, update our host status
                if (data.userId === signaling.userId) {
                    signaling.isHost = true;
                    document.querySelector('.video-wrapper.local .video-overlay').textContent = 'You (Host)';
                }
            });

            // When we receive an offer
            signaling.on('offer', async (data) => {
                if (data.targetUserId === signaling.userId) {
                    console.log(`Received offer from ${data.senderName || data.senderId}`);

                    // Create a peer connection if it doesn't exist
                    let pc = peerConnections[data.senderId];
                    if (!pc) {
                        pc = createPeerConnection(data.senderId, data.senderName || 'Peer');
                    }

                    // Process the remote offer
                    await pc.processRemoteOffer(data.offer);
                }
            });

            // When we receive an answer
            signaling.on('answer', async (data) => {
                if (data.targetUserId === signaling.userId) {
                    console.log(`Received answer from ${data.senderId}`);

                    // Get the peer connection
                    const pc = peerConnections[data.senderId];
                    if (pc) {
                        try {
                            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        } catch (error) {
                            console.error('Error handling answer:', error);
                        }
                    }
                }
            });

            // When we receive an ICE candidate
            signaling.on('ice-candidate', async (data) => {
                if (data.targetUserId === signaling.userId) {
                    const pc = peerConnections[data.senderId];
                    if (pc) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        } catch (error) {
                            console.error('Error adding ICE candidate:', error);
                        }
                    }
                }
            });

            // When a chat message is received
            signaling.on('chat-message', (data) => {
                console.log(`Received ${data.isPrivate ? 'private' : 'chat'} message from ${data.senderName}`);

                // In a real app, you would display this in a chat UI
                const isFromMe = data.senderId === signaling.userId;
                const messageText = data.isPrivate
                    ? `[Private] ${isFromMe ? 'You to ' + data.targetName : data.senderName}: ${data.message}`
                    : `${isFromMe ? 'You' : data.senderName}: ${data.message}`;

                // Show notification for incoming messages
                if (!isFromMe) {
                    showParticipantNotification(messageText, 'message');
                }
            });

            // When connection state changes
            signaling.on('connection-state-changed', (data) => {
                console.log(`WebSocket connection state changed to: ${data.state}`);

                // Update UI based on connection state
                switch (data.state) {
                    case 'connected':
                        statusText.className = 'status-text status-good';
                        break;
                    case 'connecting':
                        statusText.textContent = 'Connecting to server...';
                        statusText.className = 'status-text status-warning';
                        break;
                    case 'disconnected':
                        if (conferenceScreen.style.display !== 'none') {
                            statusText.textContent = 'Disconnected from server';
                            statusText.className = 'status-text status-bad';
                        }
                        break;
                    case 'error':
                    case 'failed':
                        statusText.textContent = 'Connection error';
                        statusText.className = 'status-text status-bad';
                        break;
                }
            });

            // When we receive a room-closed event
            signaling.on('room-closed', (data) => {
                console.log(`Room ${data.roomId} was closed by ${data.hostName || data.hostId}`);

                // Check if this is a local closure (we initiated it as host)
                const isLocalClose = data.isLocalClose === true;

                // Handle room closure, passing the isLocalClose flag
                handleRoomClosure(`This meeting has been ended by ${data.hostName || 'the host'}`, isLocalClose);
            });

            signaling.on('host-changed', handleHostChange);

            signaling.on('host-status-changed', (data) => {
                if (!data.isHost) {
                    disableHostControls();
                    showNotification(data.message, 'info', 5000);
                }
            });

            signaling.on('host-command', (data) => {
                switch (data.command) {
                    case 'mute-all':
                        if (!signaling.isHost) {
                            // Mute local audio
                            const audioTrack = localStream.getAudioTracks()[0];
                            if (audioTrack) {
                                audioTrack.enabled = false;
                                toggleAudioButton.classList.add('active');
                            }
                        }
                        break;

                    case 'remove-all':
                        if (!signaling.isHost) {
                            // Leave the call if we're not the host
                            showNotification('You have been removed from the call by the host', 'info', 5000);
                            leaveCall();
                        }
                        break;
                }
            });

            // Handle media state updates from peers
            signaling.on('message', (data) => {
                if (data.message && data.message.type === 'media-update') {
                    const { kind, enabled, userId } = data.message;
                    const userName = data.userName || getUserNameFromUserId(userId);

                    if (kind === 'audio') {
                        // Show notification about audio state change
                        const action = enabled ? 'unmuted' : 'muted';
                        showNotification(`${userName} ${action} their microphone`, 'info', 3000);

                        // Only update UI for remote users (not for local user)
                        if (userId !== window.signaling.userId) {
                            const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                            if (videoWrapper) {
                                const muteIndicator = videoWrapper.querySelector('.muted-indicator');
                                if (!enabled && !muteIndicator) {
                                    // Add muted indicator
                                    const indicator = document.createElement('div');
                                    indicator.className = 'muted-indicator';
                                    indicator.innerHTML = `
                                        <span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <!-- Microphone Body -->
  <rect x="40" y="20" width="20" height="35" rx="5" fill="#444444"/>
  
  <!-- Microphone Base -->
  <path d="M30 55 C30 68 45 75 50 75 C55 75 70 68 70 55" stroke="#444444" stroke-width="4" fill="none"/>
  
  <!-- Stand -->
  <line x1="50" y1="75" x2="50" y2="85" stroke="#444444" stroke-width="4"/>
  
  <!-- Base Stand -->
  <rect x="35" y="85" width="30" height="5" rx="2" fill="#444444"/>
  
  <!-- Slash Line -->
  <line x1="25" y1="25" x2="75" y2="75" stroke="#e74c3c" stroke-width="5" stroke-linecap="round"/>
</svg></span>
                                    `;
                                    videoWrapper.appendChild(indicator);
                                } else if (enabled && muteIndicator) {
                                    // Remove muted indicator
                                    muteIndicator.remove();
                                }
                            }
                        }
                    }
                }
            });

            signaling.on('user-disconnected', (data) => {
                const { userId, userName, temporary, wasHost } = data;

                if (temporary) {
                    showNotification(`${userName} temporarily disconnected${wasHost ? ' (Host)' : ''}`, 'warning', 3000);
                } else {
                    showNotification(`${userName} has left the meeting${wasHost ? ' (Host)' : ''}`, 'info', 3000);
                }

                // Handle UI updates for disconnected user
                const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                if (videoWrapper) {
                    if (temporary) {
                        videoWrapper.classList.add('disconnected');
                        const overlay = videoWrapper.querySelector('.video-overlay');
                        if (overlay) {
                            overlay.textContent += ' (Disconnected)';
                        }
                    } else {
                        handleParticipantLeft(userId);
                    }
                }
            });

            signaling.on('user-reconnected', (data) => {
                const { userId, userName, wasHost } = data;
                showNotification(`${userName} reconnected${wasHost ? ' (Previous Host)' : ''}`, 'success', 3000);

                const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                if (videoWrapper) {
                    videoWrapper.classList.remove('disconnected');
                    const overlay = videoWrapper.querySelector('.video-overlay');
                    if (overlay) {
                        overlay.textContent = overlay.textContent.replace(' (Disconnected)', '');
                    }
                }
            });

            // When we receive a room-joined event
            signaling.on('room-joined', (data) => {
                console.log('Room joined, processing participants:', data.participants);

                // Process each participant's initial state
                data.participants.forEach(participant => {
                    // If the participant is muted, show the mute indicator
                    if (participant.audioEnabled === false) {
                        const videoWrapper = document.getElementById(`video-wrapper-${participant.userId}`);
                        if (videoWrapper) {
                            const muteIndicator = videoWrapper.querySelector('.muted-indicator');
                            if (!muteIndicator) {
                                const indicator = document.createElement('div');
                                indicator.className = 'muted-indicator';
                                indicator.innerHTML = `
                                    <i class="fas fa-microphone-slash"></i>
                                    <span>Muted</span>
                                `;
                                videoWrapper.appendChild(indicator);
                            }
                        }
                    }
                });
            });

            // When we receive a room-rejoined event
            signaling.on('room-rejoined', (data) => {
                console.log('Room rejoined, processing participants:', data.participants);
                currentRoom = data.roomId;

                // Process each participant's state
                data.participants.forEach(participant => {
                    const { userId, userName, isHost, audioEnabled, videoEnabled } = participant;
                    
                    // Create new peer connection if needed
                    if (!peerConnections[userId]) {
                        const pc = createPeerConnection(userId, userName);
                        
                        // Create and send offer
                        pc.createOffer()
                            .then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                signaling.send({
                                    type: 'offer',
                                    targetUserId: userId,
                                    roomId: currentRoom,
                                    sdp: pc.localDescription
                                });
                            })
                            .catch(error => {
                                console.error('Error creating offer for participant:', error);
                            });
                    }

                    // Update UI with participant's media state
                    const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                    if (videoWrapper) {
                        // Update audio state
                        const muteIndicator = videoWrapper.querySelector('.muted-indicator');
                        if (!audioEnabled) {
                            if (!muteIndicator) {
                                const indicator = document.createElement('div');
                                indicator.className = 'muted-indicator';
                                indicator.innerHTML = `
                                    <i class="fas fa-microphone-slash"></i>
                                    <span>Muted</span>
                                `;
                                videoWrapper.appendChild(indicator);
                            }
                        } else if (muteIndicator) {
                            muteIndicator.remove();
                        }

                        // Update video state
                        const videoElement = videoWrapper.querySelector('video');
                        if (videoElement) {
                            if (!videoEnabled) {
                                videoElement.style.display = 'none';
                                // Show avatar or placeholder
                                const placeholder = videoWrapper.querySelector('.video-placeholder') || 
                                    document.createElement('div');
                                placeholder.className = 'video-placeholder';
                                placeholder.textContent = userName.charAt(0).toUpperCase();
                                videoWrapper.appendChild(placeholder);
                            } else {
                                videoElement.style.display = 'block';
                                const placeholder = videoWrapper.querySelector('.video-placeholder');
                                if (placeholder) {
                                    placeholder.remove();
                                }
                            }
                        }
                    }
                });
            });
        }

        // Function to create a peer connection with optimized settings for low latency
        function createPeerConnection(userId, userName) {
            console.log(`Creating peer connection for ${userName} (${userId})`);
            const pc = new RTCPeerConnection(configuration);

            // Single place to track if we're in the process of negotiating
            pc.isNegotiating = false;

            // Add all local tracks to the peer connection
            const senders = {};
            localStream.getTracks().forEach(track => {
                console.log(`Adding ${track.kind} track to peer connection for ${userName}`);
                const sender = pc.addTrack(track, localStream);
                senders[track.kind] = sender;
            });

            // Helper method to safely replace video track
            pc.replaceVideoTrack = async (newTrack) => {
                const videoSender = pc.getSenders().find(sender =>
                    sender.track && sender.track.kind === 'video');

                if (videoSender) {
                    console.log(`Replacing video track for ${userName}`);
                    return videoSender.replaceTrack(newTrack);
                } else {
                    console.warn(`No video sender found for ${userName}`);
                }
            };

            // Add a stable update function for connection stats
            pc.updateConnectionStats = debounce((stats) => {
                const statsDiv = document.getElementById(`stats-${userId}`);
                const indicator = document.getElementById(`indicator-${userId}`);

                if (statsDiv && stats) {
                    const { latency, packetLoss, jitter } = stats;

                    // Update stats display only if the connection is established
                    if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                        // Format stats with fixed width to prevent layout shifts
                        statsDiv.textContent = `${latency.toString().padStart(3, ' ')}ms | Loss: ${packetLoss}% | Jitter: ${jitter}ms`;
                    }

                    // Update status indicator
                    if (indicator) {
                        if (latency < 70 && packetLoss < 2) {
                            indicator.className = 'status-indicator';
                        } else if (latency < 150 && packetLoss < 5) {
                            indicator.className = 'status-indicator warning';
                        } else {
                            indicator.className = 'status-indicator error';
                        }
                    }
                }
            }, 500); // Update UI at most every 500ms

            // Prevent overlapping negotiations
            pc.addEventListener('signalingstatechange', () => {
                pc.isNegotiating = (pc.signalingState !== 'stable');
                console.log(`Signaling state changed to: ${pc.signalingState} for ${userName}`);
            });

            // Handle negotiation
            pc.addEventListener('negotiationneeded', async () => {
                // Prevent concurrent negotiations
                if (pc.isNegotiating) {
                    console.log(`Negotiation already in progress for ${userName}, skipping`);
                    return;
                }

                try {
                    pc.isNegotiating = true;
                    console.log(`Starting negotiation with ${userName}`);

                    // Use applyCodecPreferences instead of direct createOffer
                    const offer = await applyCodecPreferences(pc);

                    // Verify signaling state before setting local description
                    if (pc.signalingState !== 'stable') {
                        console.log(`Signaling state changed, aborting negotiation with ${userName}`);
                        pc.isNegotiating = false;
                        return;
                    }

                    // Set local description
                    try {
                        console.log(`Setting local description for ${userName}`);
                        await pc.setLocalDescription(offer);
                        console.log(`Local description set successfully for ${userName}`);

                        // Send the offer
                        window.signaling.sendOffer(userId, pc.localDescription);
                    } catch (error) {
                        console.error(`Error setting local description for ${userName}:`, error);

                        // If it's an m-line order issue, try a workaround
                        if (error.name === 'InvalidAccessError' && error.message.includes('m-lines')) {
                            console.warn(`M-line order issue detected with ${userName}, attempting recovery`);

                            // Try creating a new offer with default options, but still using codec preferences
                            try {
                                const offerOptions = { offerToReceiveAudio: true, offerToReceiveVideo: true };
                                const newOffer = await applyCodecPreferences(pc, offerOptions);
                                await pc.setLocalDescription(newOffer);
                                window.signaling.sendOffer(userId, pc.localDescription);
                            } catch (recoveryError) {
                                console.error(`Recovery attempt failed for ${userName}:`, recoveryError);
                                throw recoveryError;
                            }
                        } else {
                            throw error;
                        }
                    }
                } catch (error) {
                    console.error(`Negotiation failed with ${userName}:`, error);
                } finally {
                    pc.isNegotiating = false;
                }
            });

            // Enhanced handling of remote offer
            pc.processRemoteOffer = async (offer) => {
                try {
                    // If we're in the middle of setting our own local description, wait
                    if (pc.signalingState === 'have-local-offer') {
                        console.log(`Received remote offer while in have-local-offer state for ${userName}, rolling back`);
                        await pc.setLocalDescription({ type: 'rollback' });
                    }

                    console.log(`Setting remote description from ${userName}`);
                    await pc.setRemoteDescription(new RTCSessionDescription(offer));

                    // Create and send answer
                    console.log(`Creating answer for ${userName}`);

                    // First apply codec preferences to the transceivers
                    try {
                        // Get capabilities for video and audio
                        const videoCapabilities = RTCRtpSender.getCapabilities('video');
                        const audioCapabilities = RTCRtpSender.getCapabilities('audio');

                        if (videoCapabilities || audioCapabilities) {
                            const transceivers = pc.getTransceivers();
                            let audioTransceiverFound = false;

                            console.log(`Processing ${transceivers.length} transceivers for answer`);

                            for (const transceiver of transceivers) {
                                if (transceiver.stopped || !transceiver.receiver) continue;

                                const kind = transceiver.receiver.track?.kind;
                                if (!kind) continue;

                                if (kind === 'audio') {
                                    audioTransceiverFound = true;
                                    // Explicitly set direction to sendrecv for audio
                                    transceiver.direction = 'sendrecv';
                                }

                                const capabilities = kind === 'video' ? videoCapabilities : (kind === 'audio' ? audioCapabilities : null);
                                const preferredCodecs = configuration.codecPreferences[kind];

                                if (!capabilities || !preferredCodecs) continue;

                                // Reorder codecs based on preference
                                const codecs = [];

                                // First add the preferred codecs in order
                                for (const codec of preferredCodecs) {
                                    const matchingCodecs = capabilities.codecs.filter(c =>
                                        c.mimeType.toLowerCase().includes(codec.toLowerCase()));
                                    codecs.push(...matchingCodecs);
                                }

                                // Then add any remaining codecs
                                const remainingCodecs = capabilities.codecs.filter(c =>
                                    !codecs.some(preferred => preferred.mimeType === c.mimeType));
                                codecs.push(...remainingCodecs);

                                if (codecs.length > 0) {
                                    try {
                                        transceiver.setCodecPreferences(codecs);
                                        console.log(`Set codec preferences for ${kind} in answer: ${codecs.map(c => c.mimeType).join(', ')}`);
                                    } catch (e) {
                                        console.warn(`Failed to set codec preferences for ${kind} in answer:`, e);
                                    }
                                }
                            }

                            // Ensure audio transceiver exists
                            if (!audioTransceiverFound && localStream && localStream.getAudioTracks().length > 0) {
                                console.log('Adding audio transceiver for answer');
                                const audioTransceiver = pc.addTransceiver('audio', {
                                    direction: 'sendrecv',
                                    streams: [localStream]
                                });

                                if (audioCapabilities && configuration.codecPreferences.audio) {
                                    try {
                                        const codecs = [];
                                        for (const codec of configuration.codecPreferences.audio) {
                                            const matchingCodecs = audioCapabilities.codecs.filter(c =>
                                                c.mimeType.toLowerCase().includes(codec.toLowerCase()));
                                            codecs.push(...matchingCodecs);
                                        }

                                        const remainingCodecs = audioCapabilities.codecs.filter(c =>
                                            !codecs.some(preferred => preferred.mimeType === c.mimeType));
                                        codecs.push(...remainingCodecs);

                                        if (codecs.length > 0) {
                                            audioTransceiver.setCodecPreferences(codecs);
                                        }
                                    } catch (e) {
                                        console.warn('Failed to set codec preferences for audio in answer:', e);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.warn('Error applying codec preferences to answer:', error);
                    }

                    // Now create the answer with audio explicitly requested
                    const answer = await pc.createAnswer({ offerToReceiveAudio: true, offerToReceiveVideo: true });

                    await pc.setLocalDescription(answer);

                    window.signaling.sendAnswer(userId, pc.localDescription);
                } catch (error) {
                    console.error(`Error processing remote offer from ${userName}:`, error);
                }
            };

            // Handle ICE candidates
            pc.onicecandidate = event => {
                if (event.candidate) {
                    window.signaling.sendIceCandidate(userId, event.candidate);
                }
            };

            // Handle ICE connection state changes
            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state with ${userName}: ${pc.iceConnectionState}`);
                const statsDiv = document.getElementById(`stats-${userId}`);

                // Update UI based on ICE state
                if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                    // Start monitoring stats after connection is established
                    startPeerStats(pc, userId);

                    // Update stats display
                    if (statsDiv && statsDiv.textContent.includes('Initializing') || statsDiv.textContent.includes('Connecting')) {
                        statsDiv.textContent = pc.iceConnectionState === 'completed' ?
                            "Connection Established" : "Connected";
                    }

                    // Remove the connecting class
                    const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                    if (videoWrapper) {
                        videoWrapper.classList.remove('connecting');
                    }
                } else if (pc.iceConnectionState === 'failed') {
                    if (statsDiv) statsDiv.textContent = "ICE Connection Failed";
                } else if (pc.iceConnectionState === 'disconnected') {
                    if (statsDiv) statsDiv.textContent = "ICE Disconnected";
                }
            };

            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log(`Connection state with ${userName}: ${pc.connectionState}`);
                const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                const statusIndicator = document.getElementById(`indicator-${userId}`);
                const statsDiv = document.getElementById(`stats-${userId}`);

                if (videoWrapper && statusIndicator) {
                    if (pc.connectionState === 'connected') {
                        statusIndicator.className = 'status-indicator';
                        videoWrapper.classList.remove('connecting');
                        if (statsDiv) statsDiv.textContent = "Connected";

                        // Ensure we start stats monitoring
                        startPeerStats(pc, userId);

                        // Check if this is a reconnection during screen sharing
                        if (videoWrapper.classList.contains('screen-sharing')) {
                            console.log(`Connection restored for ${userName} during screen sharing, ensuring camera overlay...`);

                            // Create a sequence of checks at increasing intervals
                            setTimeout(() => pc.restoreScreenShareView(), 500);
                            setTimeout(() => pc.restoreScreenShareView(), 1500);
                            setTimeout(() => pc.restoreScreenShareView(), 3000);

                            // Also trigger the global checking function
                            setTimeout(() => {
                                if (typeof checkAndRestoreScreenShareOverlays === 'function') {
                                    checkAndRestoreScreenShareOverlays();
                                }
                            }, 2000);
                        }
                    } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                        statusIndicator.className = 'status-indicator error';
                        videoWrapper.classList.add('problem');
                        if (statsDiv) statsDiv.textContent = pc.connectionState === 'disconnected' ? "Disconnected" : "Connection Failed";
                    } else if (pc.connectionState === 'connecting') {
                        videoWrapper.classList.add('connecting');
                        if (statsDiv) statsDiv.textContent = "Connecting...";
                    }
                }
            };

            // Update the ontrack handler to set initial connection state
            pc.ontrack = event => {
                const stream = event.streams[0];
                const tracks = stream.getTracks();

                // Check if we already have a video element for this user
                let videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                let mainVideo, statsDiv, statusIndicator;

                if (!videoWrapper) {
                    // Create new elements with fixed dimensions
                    const elements = createPeerVideoElement(userId, userName, pc);
                    videoWrapper = elements.videoWrapper;
                    mainVideo = elements.mainVideo;
                    statsDiv = elements.statsDiv;
                    statusIndicator = elements.statusIndicator;

                    // Update the stats div with current connection state
                    if (pc.connectionState === 'connected') {
                        statsDiv.textContent = 'Connected';
                        videoWrapper.classList.remove('connecting');
                    } else if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                        statsDiv.textContent = 'ICE Connected';
                        videoWrapper.classList.remove('connecting');
                    }
                } else {
                    mainVideo = document.getElementById(`video-${userId}`);
                }

                // Get all video tracks
                const videoTracks = tracks.filter(t => t.kind === 'video');

                // Check if this is a screen share (2 video tracks)
                if (videoTracks.length === 2) {
                    // Determine which track is screen share based on track settings
                    let screenTrack, cameraTrack;

                    for (const track of videoTracks) {
                        const settings = track.getSettings();
                        // Screen share tracks typically have displaySurface property or larger dimensions
                        if (settings.displaySurface || (settings.width > 1280 && settings.height > 720)) {
                            screenTrack = track;
                        } else {
                            cameraTrack = track;
                        }
                    }

                    // If we couldn't determine which is which, use the first as screen and second as camera
                    if (!screenTrack || !cameraTrack) {
                        screenTrack = videoTracks[0];
                        cameraTrack = videoTracks[1];
                    }

                    // Create screen share stream for main video
                    const screenStream = new MediaStream([screenTrack]);
                    mainVideo.srcObject = screenStream;

                    // Create or update camera overlay
                    let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                    if (!cameraOverlay) {
                        cameraOverlay = document.createElement('div');
                        cameraOverlay.id = `camera-overlay-${userId}`;
                        cameraOverlay.className = 'remote-camera-overlay';

                        const cameraVideo = document.createElement('video');
                        cameraVideo.id = `camera-video-${userId}`;
                        cameraVideo.autoplay = true;
                        cameraVideo.playsInline = true;

                        const nameOverlay = document.createElement('div');
                        nameOverlay.className = 'video-overlay';
                        nameOverlay.textContent = userName;

                        cameraOverlay.appendChild(cameraVideo);
                        cameraOverlay.appendChild(nameOverlay);
                        videoWrapper.appendChild(cameraOverlay);
                    }

                    // Set camera stream - create a fresh stream to ensure it's properly connected
                    const cameraStream = new MediaStream([cameraTrack]);
                    const cameraVideo = document.getElementById(`camera-video-${userId}`);

                    if (cameraVideo) {
                        // If we have an existing camera video element, update it
                        cameraVideo.srcObject = cameraStream;

                        // Ensure it plays
                        cameraVideo.play().catch(e => console.warn(`Failed to play camera video: ${e.message}`));
                    }

                    // Add class to indicate remote camera is attached
                    videoWrapper.classList.add('has-remote-camera');
                    videoWrapper.classList.add('screen-sharing');

                    // Ensure camera overlay is visible with stronger force
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;

                    // Update disabled state for camera
                    if (!cameraTrack.enabled) {
                        cameraOverlay.classList.add('camera-disabled');
                    } else {
                        cameraOverlay.classList.remove('camera-disabled');
                    }

                    // Listen for enabled/disabled state changes
                    cameraTrack.onmute = () => cameraOverlay.classList.add('camera-disabled');
                    cameraTrack.onunmute = () => cameraOverlay.classList.remove('camera-disabled');

                    // Log successful setup
                    console.log(`Successfully set up screen sharing with camera for ${userName}`);

                    // Trigger another check in 1 second to ensure everything is visible
                    setTimeout(() => {
                        if (typeof checkAndRestoreScreenShareOverlays === 'function') {
                            checkAndRestoreScreenShareOverlays();
                        }
                    }, 1000);
                } else {
                    // Regular video call - single video track
                    mainVideo.srcObject = stream;
                    videoWrapper.classList.remove('screen-sharing');

                    // Remove camera overlay if exists
                    const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                    if (cameraOverlay) {
                        cameraOverlay.remove();
                    }
                }

                // Apply settings for low latency playback
                mainVideo.addEventListener('canplay', () => {
                    mainVideo.play().catch(e => console.error('Error playing video:', e));

                    // Update stats when video starts playing
                    const statsDiv = document.getElementById(`stats-${userId}`);
                    if (statsDiv && statsDiv.textContent === 'Initializing...') {
                        statsDiv.textContent = 'Video Playing';
                    }
                });
            };

            // Handle track removal (disconnection/leaving)
            pc.onremovetrack = event => {
                console.log(`Track removed: ${event.track.kind} from ${userName}`);
            };

            // Handle reconnection for screen share with camera overlay
            pc.restoreScreenShareView = () => {
                const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);

                if (videoWrapper && videoWrapper.classList.contains('screen-sharing') && cameraOverlay) {
                    // Ensure camera overlay is visible on reconnection
                    videoWrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.display = 'flex';
                    cameraOverlay.style.visibility = 'visible';
                    cameraOverlay.style.opacity = '1';
                    console.log(`Restored camera overlay for ${userName}`);
                }
            };

            // Add reconnection check when connection state becomes connected
            const originalOnConnectionStateChange = pc.onconnectionstatechange;
            pc.onconnectionstatechange = () => {
                // Call the original handler
                if (originalOnConnectionStateChange) {
                    originalOnConnectionStateChange();
                }

                // Additional logic for reconnection with screen share
                if (pc.connectionState === 'connected') {
                    // Restore screen share view if needed
                    setTimeout(() => {
                        pc.restoreScreenShareView();
                    }, 1000); // Small delay to ensure all streams are processed
                }
            };

            // Store peer connection
            peerConnections[userId] = pc;
            return pc;
        }

        // Helper function to create video elements for peers with consistent styling
        function createPeerVideoElement(userId, userName, pc) {
            console.log(`Creating video element for ${userName} (${userId})`);

            // Create container
            const videoWrapper = document.createElement('div');
            videoWrapper.id = `video-wrapper-${userId}`;
            videoWrapper.className = 'video-wrapper connecting entering';

            // Create video element
            const video = document.createElement('video');
            video.id = `video-${userId}`;
            video.autoplay = true;
            video.playsInline = true;

            // Create name overlay
            const nameOverlay = document.createElement('div');
            nameOverlay.className = 'video-overlay';
            nameOverlay.textContent = userName;

            // Create status indicator
            const statusIndicator = document.createElement('div');
            statusIndicator.id = `indicator-${userId}`;
            statusIndicator.className = 'status-indicator';

            // Create stats overlay with fixed initial content to prevent layout shifts
            const statsOverlay = document.createElement('div');
            statsOverlay.id = `stats-${userId}`;
            statsOverlay.className = 'video-overlay stats';
            statsOverlay.textContent = 'Initializing...';

            // Create reconnection indicator
            const reconnectingIndicator = document.createElement('div');
            reconnectingIndicator.className = 'reconnecting-indicator';

            // Assemble video wrapper
            videoWrapper.appendChild(video);
            videoWrapper.appendChild(nameOverlay);
            videoWrapper.appendChild(statusIndicator);
            videoWrapper.appendChild(statsOverlay);
            videoWrapper.appendChild(reconnectingIndicator);

            // Add to video container
            videoContainer.appendChild(videoWrapper);

            // Remove the entering class after animation completes
            setTimeout(() => {
                videoWrapper.classList.remove('entering');
            }, 600);

            return {
                videoWrapper,
                mainVideo: video,
                statsDiv: statsOverlay,
                statusIndicator
            };
        }

        // Helper function to enforce original m-line order (if needed for debugging)
        function enforceOriginalMLineOrder(sdp, originalOrder) {
            const sections = splitSdpIntoSections(sdp);
            if (sections.length <= 1) return sdp; // Return original if no media sections

            const sessionLevel = sections[0];
            const mediaLines = sections.slice(1);
            const orderedMediaLines = [];

            // First, add media sections in the original order
            originalOrder.forEach(({ kind }) => {
                const mediaSection = mediaLines.find(section => {
                    const mLine = section.split('\r\n')[0];
                    return mLine.startsWith(`m=${kind}`);
                });

                if (mediaSection) {
                    orderedMediaLines.push(mediaSection);
                    mediaLines.splice(mediaLines.indexOf(mediaSection), 1);
                }
            });

            // Add any remaining media sections at the end
            orderedMediaLines.push(...mediaLines);

            // Reconstruct SDP with proper line endings
            return sessionLevel + '\r\n' + orderedMediaLines.join('\r\n') + '\r\n';
        }

        // Helper function to split SDP into sections
        function splitSdpIntoSections(sdp) {
            const lines = sdp.split('\r\n');
            const sections = [];
            let currentSection = [];

            lines.forEach(line => {
                if (line.startsWith('m=')) {
                    if (currentSection.length > 0) {
                        sections.push(currentSection.join('\r\n'));
                        currentSection = [];
                    }
                }
                currentSection.push(line);
            });

            if (currentSection.length > 0) {
                sections.push(currentSection.join('\r\n'));
            }

            return sections;
        }

        // Check for existing participants
        function checkExistingParticipants(roomId) {
            // In a real application, you would query the server
            // For this demo, we'll manually broadcast our presence again
            setTimeout(() => {
                window.signaling.joinRoom(roomId);
            }, 1000);
        }

        // Initialize network monitoring
        function initializeNetworkMonitoring() {
            // Create a connection quality observer
            window.connectionQuality = {
                latencies: [],
                packetsLost: 0,
                lastPacketsTotal: 0,
                jitter: 0,
                bandwidth: 0
            };
        }

        // Start monitoring network statistics
        function startNetworkMonitoring() {
            // Clear any existing interval
            if (statsInterval) {
                clearInterval(statsInterval);
            }

            // Update stats every second
            statsInterval = setInterval(updateNetworkStats, 1000);
        }

        // Start collecting statistics for a specific peer
        function startPeerStats(pc, userId) {
            if (!pc) return;

            // Collect stats every second
            const statsDiv = document.getElementById(`stats-${userId}`);
            const indicator = document.getElementById(`indicator-${userId}`);

            if (statsDiv && indicator) {
                // Clear any existing interval for this peer
                if (pc.statsIntervalId) {
                    clearInterval(pc.statsIntervalId);
                }

                // Initialize with stable content to prevent layout shifts
                if (statsDiv.textContent === 'Initializing...') {
                    statsDiv.textContent = 'Measuring...';
                }

                let lastStats = {
                    latency: 0,
                    packetLoss: 0,
                    jitter: 0
                };

                const getStats = async () => {
                    try {
                        const stats = await pc.getStats();
                        let inboundRtp = null;
                        let remoteOutbound = null;
                        let candidatePair = null;

                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                inboundRtp = report;
                            } else if (report.type === 'remote-outbound-rtp' && report.kind === 'video') {
                                remoteOutbound = report;
                            } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                candidatePair = report;
                            }
                        });

                        if (inboundRtp) {
                            let latency = 0;
                            let jitter = inboundRtp.jitter ? Math.round(inboundRtp.jitter * 1000) : 0;
                            let packetLoss = 0;

                            if (remoteOutbound && remoteOutbound.timestamp && inboundRtp.timestamp) {
                                latency = Math.round(inboundRtp.timestamp - remoteOutbound.timestamp);
                            } else if (candidatePair && candidatePair.currentRoundTripTime) {
                                latency = Math.round(candidatePair.currentRoundTripTime * 1000);
                            }

                            if (inboundRtp.packetsLost !== undefined && inboundRtp.packetsReceived !== undefined) {
                                const totalPackets = inboundRtp.packetsLost + inboundRtp.packetsReceived;
                                if (totalPackets > 0) {
                                    packetLoss = Math.round((inboundRtp.packetsLost / totalPackets) * 100);
                                }
                            }

                            // Only update if values changed significantly to prevent UI flicker
                            const hasSignificantChange =
                                Math.abs(latency - lastStats.latency) > 5 ||
                                Math.abs(packetLoss - lastStats.packetLoss) > 1 ||
                                Math.abs(jitter - lastStats.jitter) > 5;

                            if (hasSignificantChange) {
                                lastStats = { latency, packetLoss, jitter };

                                // Update stats with debounce to prevent flickering
                                if (pc.updateConnectionStats) {
                                    pc.updateConnectionStats({
                                        latency,
                                        packetLoss,
                                        jitter
                                    });
                                }

                                // Update the global status text (debounced)
                                debounceUpdateConnectionStatus(latency, packetLoss);
                            }
                        }
                    } catch (e) {
                        console.error('Error getting stats:', e);
                    }
                };

                // Get stats immediately and then on an interval
                getStats();
                pc.statsIntervalId = setInterval(getStats, 1000);
            }
        }

        // Update network statistics with real measurements if possible
        function updateNetworkStats() {
            const localIndicator = document.querySelector('.video-wrapper.local .status-indicator');

            // Use real stats if available, otherwise simulate
            if (Object.keys(peerConnections).length > 0) {
                const pc = Object.values(peerConnections)[0];

                if (pc && pc.connectionState === 'connected') {
                    pc.getStats().then(stats => {
                        let outboundRtp = null;
                        let candidatePair = null;

                        stats.forEach(report => {
                            if (report.type === 'outbound-rtp' && report.kind === 'video') {
                                outboundRtp = report;
                            } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                candidatePair = report;
                            }
                        });

                        if (candidatePair) {
                            const latency = Math.round(candidatePair.currentRoundTripTime * 1000);
                            let bandwidth = 'Unknown';

                            if (outboundRtp && outboundRtp.bytesSent) {
                                const bytesSent = outboundRtp.bytesSent;

                                if (window.lastBytesSent && window.lastTimestamp) {
                                    const byteDiff = bytesSent - window.lastBytesSent;
                                    const timeDiff = outboundRtp.timestamp - window.lastTimestamp;
                                    const kbps = Math.round((byteDiff * 8) / timeDiff);
                                    bandwidth = `${kbps} kbps`;
                                }

                                window.lastBytesSent = bytesSent;
                                window.lastTimestamp = outboundRtp.timestamp;
                            }

                            // Update local stats
                            localStats.textContent = `Latency: ${latency}ms | BW: ${bandwidth}`;

                            // Update connection status
                            if (latency < 70) {
                                statusText.textContent = `Connected (${latency}ms)`;
                                statusText.className = 'status-text status-good';
                                localIndicator.className = 'status-indicator';
                            } else if (latency < 120) {
                                statusText.textContent = `Connected (${latency}ms)`;
                                statusText.className = 'status-text status-warning';
                                localIndicator.className = 'status-indicator warning';
                            } else {
                                statusText.textContent = `Connected (${latency}ms)`;
                                statusText.className = 'status-text status-bad';
                                localIndicator.className = 'status-indicator error';
                            }

                            return;
                        }
                    }).catch(e => {
                        console.error('Error getting stats:', e);
                        simulateNetworkStats();
                    });
                } else {
                    simulateNetworkStats();
                }
            } else {
                simulateNetworkStats();
            }
        }

        // Fallback to simulation when real stats aren't available
        function simulateNetworkStats() {
            // Simulate better latency for the demo (20-50ms range)
            const latency = Math.floor(Math.random() * (50 - 20 + 1)) + 20;
            localStats.textContent = `Latency: ${latency}ms`;

            // Update connection status based on latency
            const localIndicator = document.querySelector('.video-wrapper.local .status-indicator');

            if (latency < 35) {
                statusText.textContent = `Connected (${latency}ms)`;
                statusText.className = 'status-text status-good';
                localIndicator.className = 'status-indicator';
            } else if (latency < 70) {
                statusText.textContent = `Connected (${latency}ms)`;
                statusText.className = 'status-text status-good';
                localIndicator.className = 'status-indicator';
            } else {
                statusText.textContent = `Connected (${latency}ms)`;
                statusText.className = 'status-text status-warning';
                localIndicator.className = 'status-indicator warning';
            }
        }

        // Add a helper function to update the overall connection status
        function updateConnectionStatus(latency, packetLoss) {
            if (!statusText) return;

            // Format text with consistent length
            const formattedLatency = latency.toString().padStart(3, ' ');

            if (latency < 70 && packetLoss < 2) {
                statusText.textContent = `Connected (${formattedLatency}ms)`;
                statusText.className = 'status-text status-good';
            } else if (latency < 150 && packetLoss < 5) {
                statusText.textContent = `Connected (${formattedLatency}ms)`;
                statusText.className = 'status-text status-warning';
            } else {
                statusText.textContent = `Connected (${formattedLatency}ms)`;
                statusText.className = 'status-text status-bad';
            }
        }

        // Add smooth transitions when the application initializes
        function addSmoothTransitions() {
            const style = document.createElement('style');
            style.textContent = `
                .video-wrapper {
                    transition: all 0.3s ease-out;
                }
                .video-overlay {
                    transition: background-color 0.3s ease-out, color 0.3s ease-out;
                }
                .status-indicator {
                    transition: background-color 0.3s ease-out;
                }
                .status-text {
                    transition: background-color 0.3s ease-out, color 0.3s ease-out;
                }
            `;
            document.head.appendChild(style);
        }

        // Initialize the application
        function initialize() {
            // Initialize DOM references once at startup
            window.domReferences = {
                localVideoInitialized: false,
                ensureReferences: function () {
                    // This will be called when elements are created to ensure references exist
                    const videoEl = document.getElementById('localVideo');
                    const statsEl = document.getElementById('localStats');

                    // Only update references if the elements exist in the DOM
                    if (videoEl) {
                        localVideo = videoEl;
                    }
                    if (statsEl) {
                        localStats = statsEl;
                    }

                    window.domReferences.localVideoInitialized = true;
                }
            };

            // Initial reference setup
            window.domReferences.ensureReferences();

            // Set up event listeners
            joinRoomForm.addEventListener('submit', joinRoom);
            copyRoomIdButton.addEventListener('click', copyRoomId);
            toggleAudioButton.addEventListener('click', toggleAudio);
            toggleVideoButton.addEventListener('click', toggleVideo);
            shareScreenButton.addEventListener('click', toggleScreenShare);

            // Make sure the leave call button has a proper event listener
            if (leaveCallButton) {
                console.log('Setting up leave call button event listener');
                // Remove any existing event listeners to prevent duplicates
                leaveCallButton.removeEventListener('click', leaveCall);
                // Add the event listener
                leaveCallButton.addEventListener('click', function (e) {
                    console.log('Leave call button clicked');
                    e.preventDefault();
                    leaveCall();
                });
            } else {
                console.error('Leave call button not found in the DOM');
            }

            // Initialize network monitoring
            initializeNetworkMonitoring();

            // Add smooth transitions
            addSmoothTransitions();

            // Hide conference screen initially
            conferenceScreen.style.display = 'none';

            // Check if room ID is in URL
            const urlParams = new URLSearchParams(window.location.search);
            const roomIdFromUrl = urlParams.get('room');
            if (roomIdFromUrl) {
                roomIdInput.value = roomIdFromUrl;
            }

            // Add event listeners for DOM changes
            // This ensures our references stay up to date when elements are recreated
            const observer = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        // When elements are added to the DOM, check if we need to update references
                        setTimeout(function () {
                            window.domReferences.ensureReferences();
                        }, 0);
                    }
                });
            });

            // Start observing the document with the configured parameters
            observer.observe(document.body, { childList: true, subtree: true });
        }

        // Initialize the application
        initialize();

        // Add debounce function to prevent too frequent UI updates
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        // Create a debounced version of the updateConnectionStatus function
        const debounceUpdateConnectionStatus = debounce(updateConnectionStatus, 500);

        // Add a function to check and restore screen share camera overlays
        function checkAndRestoreScreenShareOverlays() {
            // Look for all screen sharing video wrappers
            const screenShareWrappers = document.querySelectorAll('.video-wrapper.screen-sharing');

            // If no screen sharing is happening, nothing to do
            if (screenShareWrappers.length === 0) {
                return;
            }

            console.log(`Checking ${screenShareWrappers.length} screen sharing wrappers for camera overlays...`);

            screenShareWrappers.forEach(wrapper => {
                const userId = wrapper.id.replace('video-wrapper-', '');
                let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);

                // Check if we have a peer connection for this user
                const pc = peerConnections[userId];

                if (!cameraOverlay && pc) {
                    console.log(`Camera overlay missing for screen sharing user ${userId}, attempting to recreate it...`);

                    // Attempt to create the missing camera overlay
                    cameraOverlay = createMissingCameraOverlay(userId, wrapper, pc);

                    // Ensure the camera overlay is visible and properly styled
                    wrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;

                    // Also check if the video element inside is working
                    const cameraVideo = document.getElementById(`camera-video-${userId}`);
                    if (cameraVideo && (!cameraVideo.srcObject || !cameraVideo.srcObject.active)) {
                        console.log(`Camera video feed missing for user ${userId}, attempting to restore...`);
                        attemptToRestoreCameraFeed(userId, pc, cameraVideo);
                    }
                } else if (cameraOverlay) {
                    // Ensure the overlay is visible even if it already exists
                    wrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;
                }
            });
        }

        // Call the restore function when room is joined
        window.addEventListener('roomJoined', () => {
            // Give a short delay to allow all connections to establish
            setTimeout(() => {
                // Activate ongoing monitoring for screen shares
                setupScreenShareMonitoring();
            }, 2000);
        });

        // Add a more robust periodic checking mechanism for screen share camera overlays
        function setupScreenShareMonitoring() {
            // Initial check
            checkAndRestoreScreenShareOverlays();

            // Set up a periodic check every 3 seconds
            const monitoringInterval = setInterval(() => {
                // Only run the check if we're in a conference
                if (conferenceScreen.style.display !== 'none') {
                    checkAndRestoreScreenShareOverlays();
                } else {
                    // Clear the interval if we're not in a conference
                    clearInterval(monitoringInterval);
                }
            }, 3000);

            // Store the interval ID so it can be cleared if needed
            window.screenShareMonitoringInterval = monitoringInterval;
        }

        // Enhanced function to check and restore screen share overlays
        function checkAndRestoreScreenShareOverlays() {
            // Look for all screen sharing video wrappers
            const screenShareWrappers = document.querySelectorAll('.video-wrapper.screen-sharing');

            // If no screen sharing is happening, nothing to do
            if (screenShareWrappers.length === 0) {
                return;
            }

            console.log(`Checking ${screenShareWrappers.length} screen sharing wrappers for camera overlays...`);

            screenShareWrappers.forEach(wrapper => {
                const userId = wrapper.id.replace('video-wrapper-', '');
                let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);

                // Check if we have a peer connection for this user
                const pc = peerConnections[userId];

                if (!cameraOverlay && pc) {
                    console.log(`Camera overlay missing for screen sharing user ${userId}, attempting to recreate it...`);

                    // Attempt to create the missing camera overlay
                    cameraOverlay = createMissingCameraOverlay(userId, wrapper, pc);

                    // Ensure the camera overlay is visible and properly styled
                    wrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;

                    // Also check if the video element inside is working
                    const cameraVideo = document.getElementById(`camera-video-${userId}`);
                    if (cameraVideo && (!cameraVideo.srcObject || !cameraVideo.srcObject.active)) {
                        console.log(`Camera video feed missing for user ${userId}, attempting to restore...`);
                        attemptToRestoreCameraFeed(userId, pc, cameraVideo);
                    }
                } else if (cameraOverlay) {
                    // Ensure the overlay is visible even if it already exists
                    wrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;
                }
            });
        }

        // Function to create a missing camera overlay for a screen share
        function createMissingCameraOverlay(userId, videoWrapper, pc) {
            // Get the user name
            const userName = getUserNameFromUserId(userId) || 'User';

            // Create the camera overlay
            const cameraOverlay = document.createElement('div');
            cameraOverlay.id = `camera-overlay-${userId}`;
            cameraOverlay.className = 'remote-camera-overlay';
            cameraOverlay.style.cssText = `
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
                z-index: 20 !important;
            `;

            // Create the camera video element
            const cameraVideo = document.createElement('video');
            cameraVideo.id = `camera-video-${userId}`;
            cameraVideo.autoplay = true;
            cameraVideo.playsInline = true;

            // Create the name overlay
            const nameOverlay = document.createElement('div');
            nameOverlay.className = 'video-overlay';
            nameOverlay.textContent = userName;

            // Add elements to the overlay
            cameraOverlay.appendChild(cameraVideo);
            cameraOverlay.appendChild(nameOverlay);
            videoWrapper.appendChild(cameraOverlay);

            // Add class to indicate remote camera is attached
            videoWrapper.classList.add('has-remote-camera');

            // Try to find camera track from the peer connection
            if (pc && pc.getReceivers) {
                // Look through receivers for a video track that's not the screen share
                let foundCameraTrack = false;
                pc.getReceivers().forEach(receiver => {
                    if (receiver.track && receiver.track.kind === 'video' && !foundCameraTrack) {
                        // Get track settings to determine if it's a camera or screen
                        const settings = receiver.track.getSettings ? receiver.track.getSettings() : {};

                        // This is likely the camera track if it's smaller than typical screen share
                        if (!settings.displaySurface && (!settings.width || settings.width <= 1280)) {
                            // Safe update of the video source with retry mechanism
                            safeUpdateVideoSource(cameraVideo, receiver.track, `restored camera feed for ${userName}`);
                            foundCameraTrack = true;

                            // Set disabled state if track is muted
                            if (!receiver.track.enabled) {
                                cameraOverlay.classList.add('camera-disabled');
                            }
                        }
                    }
                });

                // If we couldn't find a camera track, mark as disabled
                if (!foundCameraTrack) {
                    cameraOverlay.classList.add('camera-disabled');
                }
            }

            return cameraOverlay;
        }

        // Function to try to restore a camera feed for an existing overlay
        function attemptToRestoreCameraFeed(userId, pc, cameraVideo) {
            if (pc && pc.getReceivers) {
                // Get all video tracks from the peer connection
                const videoReceivers = pc.getReceivers().filter(r =>
                    r.track && r.track.kind === 'video');

                // Log all tracks for debugging
                videoReceivers.forEach((receiver, index) => {
                    const settings = receiver.track.getSettings ? receiver.track.getSettings() : {};
                    console.log(`Track ${index} for user ${userId}: width=${settings.width}, height=${settings.height}, displaySurface=${settings.displaySurface}`);
                });

                if (videoReceivers.length >= 2) {
                    // If we have 2+ video tracks, the smaller one is likely the camera
                    let cameraTrack = null;

                    for (const receiver of videoReceivers) {
                        const settings = receiver.track.getSettings ? receiver.track.getSettings() : {};
                        // This is likely the camera track if it's smaller
                        if (!settings.displaySurface && (!settings.width || settings.width <= 1280)) {
                            cameraTrack = receiver.track;
                            break;
                        }
                    }

                    // If we still couldn't determine, use the second video track
                    if (!cameraTrack && videoReceivers.length >= 2) {
                        cameraTrack = videoReceivers[1].track;
                    }

                    if (cameraTrack) {
                        // Safe update of the video source with retry mechanism
                        safeUpdateVideoSource(cameraVideo, cameraTrack, `restored camera feed for user ${userId}`);

                        // Update disabled state
                        const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                        if (cameraOverlay) {
                            if (!cameraTrack.enabled) {
                                cameraOverlay.classList.add('camera-disabled');
                            } else {
                                cameraOverlay.classList.remove('camera-disabled');
                            }
                        }

                        // Also ensure the main video is showing the screen share, not the camera
                        const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                        if (videoWrapper && videoWrapper.classList.contains('screen-sharing')) {
                            const mainVideo = document.getElementById(`video-${userId}`);
                            if (mainVideo) {
                                const nonCameraTracks = videoReceivers
                                    .filter(r => r.track && r.track.id !== cameraTrack.id)
                                    .map(r => r.track);

                                if (nonCameraTracks.length > 0) {
                                    console.log(`Also updating main video for ${userId} to show screen content`);
                                    const screenStream = new MediaStream([nonCameraTracks[0]]);
                                    mainVideo.srcObject = screenStream;
                                }
                            }
                        }

                        return true;
                    }
                } else if (videoReceivers.length === 1) {
                    // If we only have one track, check if it's a misplaced screen share
                    const track = videoReceivers[0].track;
                    const settings = track.getSettings ? track.getSettings() : {};

                    // Verify if we need to swap screen share and camera video
                    const videoWrapper = document.getElementById(`video-wrapper-${userId}`);
                    const mainVideo = document.getElementById(`video-${userId}`);

                    if (videoWrapper && mainVideo && videoWrapper.classList.contains('screen-sharing')) {
                        // If it looks like a screen share track, make sure it's in the main video
                        if (settings.displaySurface || (settings.width > 1280 && settings.height > 720)) {
                            console.log(`Found screen share track, ensuring it's in the main video for ${userId}`);
                            const screenStream = new MediaStream([track]);
                            mainVideo.srcObject = screenStream;
                        }
                    }
                }
            }

            return false;
        }

        // Helper function to get a user name from user ID
        function getUserNameFromUserId(userId) {
            // Try to find the username in video overlays
            const overlays = document.querySelectorAll('.video-overlay');
            for (const overlay of overlays) {
                const wrapper = overlay.closest('.video-wrapper');
                if (wrapper && wrapper.id === `video-wrapper-${userId}`) {
                    return overlay.textContent;
                }
            }
            return null;
        }

        // Add touch event handlers for better mobile responsiveness
        toggleAudioButton.addEventListener('touchstart', function (e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.add('touch-active'); // Visual feedback
        }, { passive: false });

        toggleAudioButton.addEventListener('touchend', function (e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.remove('touch-active');
            toggleAudio(); // Call the toggle function
        }, { passive: false });

        toggleVideoButton.addEventListener('touchstart', function (e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.add('touch-active'); // Visual feedback
        }, { passive: false });

        toggleVideoButton.addEventListener('touchend', function (e) {
            e.preventDefault(); // Prevent default touch behavior
            this.classList.remove('touch-active');
            toggleVideo(); // Call the toggle function
        }, { passive: false });

        // Also add touch events for the other buttons for consistency
        shareScreenButton.addEventListener('touchstart', function (e) {
            e.preventDefault();
            this.classList.add('touch-active');
        }, { passive: false });

        shareScreenButton.addEventListener('touchend', function (e) {
            e.preventDefault();
            this.classList.remove('touch-active');
            toggleScreenShare();
        }, { passive: false });

        leaveCallButton.addEventListener('touchstart', function (e) {
            e.preventDefault();
            this.classList.add('touch-active');
        }, { passive: false });

        leaveCallButton.addEventListener('touchend', function (e) {
            e.preventDefault();
            this.classList.remove('touch-active');
            leaveCall();
        }, { passive: false });

        // Add device detection on page load
        document.addEventListener('DOMContentLoaded', function () {
            // Add device-specific classes to HTML element
            const htmlElement = document.documentElement;

            if (isMobileDevice()) {
                htmlElement.classList.add('mobile');

                if (isIOSDevice()) {
                    htmlElement.classList.add('ios');
                    // Hide screen share button on iOS since it's not supported
                    const shareScreenButton = document.getElementById('shareScreen');
                    if (shareScreenButton) {
                        shareScreenButton.style.display = 'none';
                    }
                } else if (isAndroidDevice()) {
                    htmlElement.classList.add('android');
                }
            } else {
                htmlElement.classList.add('desktop');
            }

            // Initialize dropdowns with default options without requesting permissions
            micSelect.innerHTML = '<option value="">Select microphone</option>';
            cameraSelect.innerHTML = '<option value="">Select camera</option>';
        });

        // Function to enumerate and populate available audio input devices
        async function updateAudioDevices() {
            try {
                // Add loading state
                micSelect.classList.add('loading');

                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputDevices = devices.filter(device => device.kind === 'audioinput');

                // Clear existing options
                micSelect.innerHTML = '';

                if (audioInputDevices.length === 0 || audioInputDevices.every(device => !device.label)) {
                    // No devices or no labels (no permissions) - show default option
                    const option = document.createElement('option');
                    option.value = '';
                    option.text = 'Select microphone';
                    micSelect.appendChild(option);
                    micSelect.disabled = true;
                } else {
                    // Add available microphones
                    audioInputDevices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Microphone ${micSelect.options.length + 1}`;
                        micSelect.appendChild(option);
                    });

                    micSelect.disabled = false;

                    // Select the current device if one is active
                    if (currentMicrophoneId) {
                        micSelect.value = currentMicrophoneId;
                    }

                    // If no microphone is selected but we have options, select the first one
                    if (!micSelect.value && micSelect.options.length > 0) {
                        micSelect.selectedIndex = 0;
                        currentMicrophoneId = micSelect.value;
                    }
                }
            } catch (error) {
                console.error('Error enumerating audio devices:', error);
                micSelect.innerHTML = '<option value="">Error loading microphones</option>';
                micSelect.disabled = true;
            } finally {
                // Remove loading state
                micSelect.classList.remove('loading');
            }
        }

        // Function to switch microphone
        async function switchMicrophone(deviceId) {
            try {
                // Get new audio stream with selected device
                const newStream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: { exact: deviceId } }
                });

                const newAudioTrack = newStream.getAudioTracks()[0];

                if (newAudioTrack) {
                    // Store the new device ID
                    currentMicrophoneId = deviceId;

                    // Get the current mute state from the UI
                    const isMuted = toggleAudioButton.classList.contains('active');

                    // Set the new track's enabled state to match the UI
                    newAudioTrack.enabled = !isMuted;

                    // Replace the audio track in the local stream
                    const oldAudioTrack = localStream.getAudioTracks()[0];
                    if (oldAudioTrack) {
                        oldAudioTrack.stop();
                        localStream.removeTrack(oldAudioTrack);
                    }
                    localStream.addTrack(newAudioTrack);

                    // Replace the track in all peer connections
                    Object.values(peerConnections).forEach(pc => {
                        const senders = pc.getSenders();
                        const audioSender = senders.find(sender => sender.track && sender.track.kind === 'audio');
                        if (audioSender) {
                            audioSender.replaceTrack(newAudioTrack);
                        }
                    });

                    console.log(`Switched to microphone: ${deviceId}, muted state: ${isMuted}`);
                }
            } catch (error) {
                console.error('Error switching microphone:', error);
                showNotification('Failed to switch microphone. Please try again.', 'error', 5000);
            }
        }

        // Add event listener for microphone selection
        micSelect.addEventListener('change', () => {
            const selectedDeviceId = micSelect.value;
            if (selectedDeviceId) {
                switchMicrophone(selectedDeviceId);
            }
        });

        // Listen for device changes
        navigator.mediaDevices.addEventListener('devicechange', () => {
            updateAudioDevices();
        });

        // Enhanced version of track handling for new participants and reconnections
        function handleTrack(event, pc, userId, userName, videoWrapper, mainVideo) {
            console.log(`Track added from ${userName}: ${event.track.kind}, track ID: ${event.track.id}`);

            // Create a stream from the track
            const stream = event.streams[0] || new MediaStream([event.track]);

            // Handle video tracks
            if (event.track.kind === 'video') {
                // Get all video tracks from the stream and from previous receivers
                const streamVideoTracks = stream.getVideoTracks();
                const allVideoTracks = [...streamVideoTracks];

                // Get tracks from all receivers to handle case where tracks arrive separately
                if (pc.getReceivers) {
                    pc.getReceivers().forEach(receiver => {
                        if (receiver.track &&
                            receiver.track.kind === 'video' &&
                            !allVideoTracks.some(t => t.id === receiver.track.id)) {
                            allVideoTracks.push(receiver.track);
                        }
                    });
                }

                console.log(`Total video tracks from ${userName}: ${allVideoTracks.length}`);

                // Log detailed information about track for debugging
                if (event.track.getSettings) {
                    const settings = event.track.getSettings();
                    console.log(`Track settings for ${userName}: width=${settings.width}, height=${settings.height}, displaySurface=${settings.displaySurface}`);
                }

                // Mark this wrapper as potentially having screen share for future track arrivals
                const isLikelyScreenShare = event.track.getSettings &&
                    (event.track.getSettings().displaySurface ||
                        (event.track.getSettings().width > 1280 && event.track.getSettings().height > 720));

                if (isLikelyScreenShare) {
                    videoWrapper.dataset.possibleScreenShare = 'true';
                    console.log(`Marking ${userName}'s video wrapper as possible screen share - track appears to be screen content`);

                    // Immediately update the main video with this track if it looks like a screen share
                    const screenStream = new MediaStream([event.track]);
                    mainVideo.srcObject = screenStream;
                    videoWrapper.classList.add('screen-sharing');
                }

                // Store the track in a temporary collection for later completion when both tracks arrive
                if (!window.pendingVideoTracks) {
                    window.pendingVideoTracks = {};
                }

                if (!window.pendingVideoTracks[userId]) {
                    window.pendingVideoTracks[userId] = [];
                }

                // Add this track if not already in the collection
                if (!window.pendingVideoTracks[userId].some(t => t.id === event.track.id)) {
                    window.pendingVideoTracks[userId].push(event.track);
                    console.log(`Added track to pending collection for ${userName}, now has ${window.pendingVideoTracks[userId].length} tracks`);
                }

                // When we have 2 or more video tracks, it's likely screen sharing + camera
                if (allVideoTracks.length >= 2 || window.pendingVideoTracks[userId].length >= 2) {
                    // Get all available tracks from our pending collection
                    const videoTracks = window.pendingVideoTracks[userId].length >= 2 ?
                        window.pendingVideoTracks[userId] : allVideoTracks;

                    // Determine which track is screen share based on track settings
                    let screenTrack, cameraTrack;

                    for (const track of videoTracks) {
                        const settings = track.getSettings ? track.getSettings() : {};
                        // Screen share tracks typically have displaySurface property or larger dimensions
                        if (settings.displaySurface || (settings.width > 1280 && settings.height > 720)) {
                            screenTrack = track;
                        } else {
                            cameraTrack = track;
                        }
                    }

                    // If we couldn't determine which is which, use the first as screen and second as camera
                    if (!screenTrack || !cameraTrack) {
                        // Check if we have a screen share designation in our dataset
                        if (videoWrapper.dataset.possibleScreenShare === 'true') {
                            // Try to find the track that's most likely the screen share
                            // Screen shares typically have higher resolution
                            let maxResolution = 0;
                            let maxResolutionTrackIndex = 0;

                            videoTracks.forEach((track, index) => {
                                if (track.getSettings) {
                                    const settings = track.getSettings();
                                    const resolution = (settings.width || 0) * (settings.height || 0);
                                    if (resolution > maxResolution) {
                                        maxResolution = resolution;
                                        maxResolutionTrackIndex = index;
                                    }
                                }
                            });

                            screenTrack = videoTracks[maxResolutionTrackIndex];
                            cameraTrack = videoTracks.find((track, index) => index !== maxResolutionTrackIndex);

                            console.log(`Using resolution-based detection for ${userName}: identified screen and camera tracks`);
                        } else {
                            screenTrack = videoTracks[0];
                            cameraTrack = videoTracks.length > 1 ? videoTracks[1] : null;
                        }
                    }

                    // Create screen share stream for main video
                    if (screenTrack) {
                        console.log(`Setting screen share track for ${userName} as main video`);
                        const screenStream = new MediaStream([screenTrack]);
                        mainVideo.srcObject = screenStream;
                        videoWrapper.classList.add('screen-sharing');
                    }

                    // Create or update camera overlay
                    let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                    if (!cameraOverlay) {
                        cameraOverlay = document.createElement('div');
                        cameraOverlay.id = `camera-overlay-${userId}`;
                        cameraOverlay.className = 'remote-camera-overlay';

                        const cameraVideo = document.createElement('video');
                        cameraVideo.id = `camera-video-${userId}`;
                        cameraVideo.autoplay = true;
                        cameraVideo.playsInline = true;

                        const nameOverlay = document.createElement('div');
                        nameOverlay.className = 'video-overlay';
                        nameOverlay.textContent = userName;

                        cameraOverlay.appendChild(cameraVideo);
                        cameraOverlay.appendChild(nameOverlay);
                        videoWrapper.appendChild(cameraOverlay);
                    }

                    // Set camera stream if we have a camera track
                    if (cameraTrack) {
                        console.log(`Setting camera track for ${userName} in overlay`);
                        const cameraVideo = document.getElementById(`camera-video-${userId}`);

                        if (cameraVideo) {
                            // Safe update of the video source with retry mechanism
                            safeUpdateVideoSource(cameraVideo, cameraTrack, `camera video for ${userName}`);
                        }

                        // If camera is enabled, remove disabled class
                        if (cameraTrack.enabled) {
                            cameraOverlay.classList.remove('camera-disabled');
                        } else {
                            cameraOverlay.classList.add('camera-disabled');
                        }
                    } else {
                        // No camera track yet, mark as disabled
                        cameraOverlay.classList.add('camera-disabled');
                    }

                    // Add class to indicate remote camera is attached
                    videoWrapper.classList.add('has-remote-camera');

                    // Ensure camera overlay is visible with stronger force
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;

                    // Listen for enabled/disabled state changes if we have a camera track
                    if (cameraTrack) {
                        cameraTrack.onmute = () => cameraOverlay.classList.add('camera-disabled');
                        cameraTrack.onunmute = () => cameraOverlay.classList.remove('camera-disabled');
                    }

                    // Log successful setup
                    console.log(`Successfully set up screen sharing with camera for ${userName}`);

                    // Trigger another check in 1 second to ensure everything is visible
                    setTimeout(() => {
                        if (typeof checkAndRestoreScreenShareOverlays === 'function') {
                            checkAndRestoreScreenShareOverlays();
                        }
                    }, 1000);
                } else if (allVideoTracks.length === 1) {
                    // Single track - could be regular video or screen share without camera
                    const track = allVideoTracks[0];
                    const settings = track.getSettings ? track.getSettings() : {};

                    // If this looks like a screen share track but we're missing the camera track
                    if (settings.displaySurface || (settings.width > 1280 && settings.height > 720) ||
                        videoWrapper.dataset.possibleScreenShare === 'true') {
                        console.log(`Detected screen share from ${userName} but camera track is missing. Setting as main video and creating placeholder overlay.`);

                        // Set the screen share as the main video
                        mainVideo.srcObject = stream;
                        videoWrapper.classList.add('screen-sharing');
                        videoWrapper.dataset.possibleScreenShare = 'true';

                        // Create a placeholder camera overlay that will show "Camera Off"
                        let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                        if (!cameraOverlay) {
                            cameraOverlay = document.createElement('div');
                            cameraOverlay.id = `camera-overlay-${userId}`;
                            cameraOverlay.className = 'remote-camera-overlay camera-disabled';

                            const cameraVideo = document.createElement('video');
                            cameraVideo.id = `camera-video-${userId}`;
                            cameraVideo.autoplay = true;
                            cameraVideo.playsInline = true;

                            const nameOverlay = document.createElement('div');
                            nameOverlay.className = 'video-overlay';
                            nameOverlay.textContent = userName;

                            cameraOverlay.appendChild(cameraVideo);
                            cameraOverlay.appendChild(nameOverlay);
                            videoWrapper.appendChild(cameraOverlay);
                        }

                        // Ensure overlay is visible
                        videoWrapper.classList.add('has-remote-camera');
                        cameraOverlay.style.cssText = `
                            display: flex !important;
                            visibility: visible !important;
                            opacity: 1 !important;
                            z-index: 20 !important;
                        `;

                        // We'll keep the original ontrack handler to catch additional tracks
                        const originalOnTrack = pc.ontrack;

                        // Register for track additions - in case camera is added later
                        pc.ontrack = (e) => {
                            // Call the original handler first
                            if (originalOnTrack && originalOnTrack !== pc.ontrack) {
                                originalOnTrack.call(pc, e);
                            }

                            // Check if this is a new video track that might be the camera
                            if (e.track.kind === 'video' && e.track.id !== track.id) {
                                console.log(`Detected late camera track from ${userName}`);

                                // Add to pending tracks
                                if (!window.pendingVideoTracks[userId].some(t => t.id === e.track.id)) {
                                    window.pendingVideoTracks[userId].push(e.track);
                                }

                                // Find camera video element
                                const cameraVideo = document.getElementById(`camera-video-${userId}`);
                                if (cameraVideo) {
                                    // Safe update of the video source with retry mechanism
                                    safeUpdateVideoSource(cameraVideo, e.track, `late camera track for ${userName}`);
                                    cameraOverlay.classList.remove('camera-disabled');

                                    // Update track event handlers
                                    e.track.onmute = () => cameraOverlay.classList.add('camera-disabled');
                                    e.track.onunmute = () => cameraOverlay.classList.remove('camera-disabled');

                                    console.log(`Late camera track connected for ${userName}`);
                                }
                            }
                        };
                    } else {
                        // Regular video call - single video track
                        console.log(`Setting regular video for ${userName}`);
                        mainVideo.srcObject = stream;
                        videoWrapper.classList.remove('screen-sharing');

                        // Remove camera overlay if exists
                        const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                        if (cameraOverlay) {
                            cameraOverlay.remove();
                        }
                    }
                } else {
                    // No video tracks detected
                    mainVideo.srcObject = stream;
                    console.log(`No video tracks detected for ${userName}`);
                }

                // Apply settings for low latency playback
                mainVideo.addEventListener('canplay', () => {
                    mainVideo.play().catch(e => console.error('Error playing video:', e));

                    // Update stats when video starts playing
                    const statsDiv = document.getElementById(`stats-${userId}`);
                    if (statsDiv && statsDiv.textContent === 'Initializing...') {
                        statsDiv.textContent = 'Video Playing';
                    }
                });
            }
        }

        // Helper function to safely update video source with retry
        function safeUpdateVideoSource(videoElement, track, logContext) {
            try {
                // Create a new stream with just this track
                const stream = new MediaStream([track]);

                // Check if the video element needs a source update
                const currentTrackId = videoElement.srcObject?.getVideoTracks()[0]?.id;
                if (currentTrackId !== track.id) {
                    // Set source to the new stream
                    videoElement.srcObject = stream;

                    // Try to play with retry logic
                    const playWithRetry = (retryCount = 0) => {
                        videoElement.play().catch(error => {
                            console.warn(`Failed to play ${logContext} (attempt ${retryCount + 1}):`, error);

                            // Retry a few times with increasing delay
                            if (retryCount < 3) {
                                setTimeout(() => {
                                    playWithRetry(retryCount + 1);
                                }, 500 * (retryCount + 1));
                            }
                        });
                    };

                    // Add canplay event handler before starting play
                    videoElement.addEventListener('canplay', function onCanPlay() {
                        // Remove this handler after first trigger to avoid duplicates
                        videoElement.removeEventListener('canplay', onCanPlay);

                        // Start play with retry
                        playWithRetry();
                    }, { once: true });

                    console.log(`Updated video source for ${logContext}`);
                }
            } catch (error) {
                console.error(`Error updating video source for ${logContext}:`, error);
            }
        }

        // Notification system for device permissions
        const notificationSystem = {
            container: null,

            init() {
                // Create notification container if it doesn't exist
                if (!this.container) {
                    this.container = document.createElement('div');
                    this.container.id = 'notification-container';
                    this.container.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        z-index: 9999;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                        max-width: 400px;
                    `;
                    document.body.appendChild(this.container);
                }
            },

            show(message, type = 'info', duration = 5000) {
                this.init();

                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.style.cssText = `
                    padding: 12px 24px;
                    border-radius: 8px;
                    background: ${this.getBackgroundColor(type)};
                    color: white;
                    font-size: 14px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                    opacity: 0;
                    transform: translateX(100%);
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    margin-bottom: 8px;
                `;

                // Add icon based on type
                const icon = document.createElement('span');
                icon.innerHTML = this.getIcon(type);
                icon.style.cssText = `
                    width: 20px;
                    height: 20px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                const messageText = document.createElement('span');
                messageText.textContent = message;
                messageText.style.flex = '1';

                notification.appendChild(icon);
                notification.appendChild(messageText);

                // Add close button
                const closeButton = document.createElement('button');
                closeButton.innerHTML = '×';
                closeButton.style.cssText = `
                    background: none;
                    border: none;
                    color: white;
                    font-size: 20px;
                    cursor: pointer;
                    padding: 0;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0.8;
                    transition: opacity 0.2s;
                `;
                closeButton.addEventListener('mouseover', () => closeButton.style.opacity = '1');
                closeButton.addEventListener('mouseout', () => closeButton.style.opacity = '0.8');
                closeButton.onclick = () => this.hide(notification);

                notification.appendChild(closeButton);
                this.container.appendChild(notification);

                // Trigger animation
                requestAnimationFrame(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateX(0)';
                });

                // Auto hide after duration
                if (duration > 0) {
                    setTimeout(() => this.hide(notification), duration);
                }

                return notification;
            },

            hide(notification) {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => notification.remove(), 300);
            },

            getBackgroundColor(type) {
                const colors = {
                    success: '#4caf50',
                    error: '#f44336',
                    warning: '#ff9800',
                    info: '#2196f3'
                };
                return colors[type] || colors.info;
            },

            getIcon(type) {
                const icons = {
                    success: '<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>',
                    error: '<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>',
                    warning: '<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 2L1 21h22L12 2zm0 3.99L19.53 19H4.47L12 5.99zM11 16h2v2h-2zm0-6h2v4h-2z"/></svg>',
                    info: '<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>'
                };
                return icons[type] || icons.info;
            }
        };

        // Function to show notifications
        function showNotification(message, type = 'info', duration = 5000) {
            return notificationSystem.show(message, type, duration);
        }

        // Add host management functions
        function handleHostChange(data) {
            const { oldHostId, newHostId, newHostName, permanent } = data;

            // Update UI to reflect host change
            document.querySelectorAll('.video-wrapper').forEach(wrapper => {
                const userId = wrapper.getAttribute('data-user-id');
                const overlay = wrapper.querySelector('.video-overlay');

                if (userId === oldHostId) {
                    overlay.textContent = overlay.textContent.replace(' (Host)', '');
                }
                if (userId === newHostId) {
                    overlay.textContent = `${newHostName} (Host)`;
                }
            });

            // Show notification about host change
            const message = permanent ?
                `${newHostName} is now the host (previous host left)` :
                `${newHostName} is temporarily the host`;
            showNotification(message, permanent ? 'info' : 'warning', 5000);

            // Update local host status if we're the new host
            if (newHostId === window.signaling?.userId) {
                window.signaling.isHost = true;
                enableHostControls();
            } else if (oldHostId === window.signaling?.userId) {
                window.signaling.isHost = false;
                disableHostControls();
            }
        }

        function enableHostControls() {
            // Add host-specific controls
            const controlsContainer = document.querySelector('.meet-controls');
            if (!controlsContainer.querySelector('#hostControls')) {
                const hostControls = document.createElement('div');
                hostControls.id = 'hostControls';
                hostControls.className = 'host-controls';
                hostControls.innerHTML = `
                    <button class="meet-button" id="muteAllButton" title="Mute all participants">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                            <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                            <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                        </svg>
                    </button>
                    <button class="meet-button" id="removeAllButton" title="Remove all participants">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                            <path d="M14 8c0-2.21-1.79-4-4-4S6 5.79 6 8s1.79 4 4 4 4-1.79 4-4zm-2 0c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zM2 18v2h16v-2c0-2.66-5.33-4-8-4s-8 1.34-8 4zm2 0c.2-.71 3.3-2 6-2 2.69 0 5.77 1.28 6 2H4zm13-8h6v2h-6z"/>
                        </svg>
                    </button>
                `;
                controlsContainer.appendChild(hostControls);

                // Add event listeners for host controls
                document.getElementById('muteAllButton').addEventListener('click', () => {
                    broadcastHostCommand('mute-all');
                    showNotification('All participants have been muted', 'info', 3000);
                });

                document.getElementById('removeAllButton').addEventListener('click', () => {
                    if (confirm('Are you sure you want to remove all participants?')) {
                        broadcastHostCommand('remove-all');
                        showNotification('All participants have been removed', 'info', 3000);
                    }
                });
            }
        }

        function disableHostControls() {
            const hostControls = document.getElementById('hostControls');
            if (hostControls) {
                hostControls.remove();
            }
        }

        function broadcastHostCommand(command, targetUserId = null) {
            if (!window.signaling?.isHost) return;

            window.signaling.send({
                type: 'host-command',
                command,
                targetUserId,
                roomId: window.signaling.roomId
            });
        }

        // Enhanced function to safely update video sources with retry mechanism
        function safeUpdateVideoSource(videoElement, track, description) {
            let retryCount = 0;
            const maxRetries = 3;

            function attemptUpdate() {
                try {
                    const stream = new MediaStream([track]);
                    videoElement.srcObject = stream;

                    // Return a promise that resolves when the video starts playing
                    return new Promise((resolve, reject) => {
                        const playTimeout = setTimeout(() => {
                            reject(new Error('Video play timeout'));
                        }, 5000);

                        videoElement.onplaying = () => {
                            clearTimeout(playTimeout);
                            resolve();
                        };

                        videoElement.play().catch(error => {
                            clearTimeout(playTimeout);
                            reject(error);
                        });
                    });
                } catch (error) {
                    return Promise.reject(error);
                }
            }

            function retry() {
                retryCount++;
                console.log(`Retry ${retryCount} for ${description}`);

                if (retryCount <= maxRetries) {
                    return attemptUpdate().catch(error => {
                        console.warn(`Attempt ${retryCount} failed for ${description}:`, error);
                        // Exponential backoff
                        return new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000))
                            .then(retry);
                    });
                } else {
                    console.error(`Failed to update video source for ${description} after ${maxRetries} attempts`);
                    return Promise.reject(new Error('Max retries exceeded'));
                }
            }

            return attemptUpdate().catch(retry);
        }

        // Enhanced function to attempt to restore camera feed
        async function attemptToRestoreCameraFeed(userId, pc, cameraVideo) {
            console.log(`Attempting to restore camera feed for user ${userId}`);

            // Get all video receivers from the peer connection
            const videoReceivers = pc.getReceivers().filter(receiver =>
                receiver.track && receiver.track.kind === 'video');

            if (videoReceivers.length >= 2) {
                // We have multiple video tracks, try to identify the camera track
                let cameraTrack = null;

                for (const receiver of videoReceivers) {
                    const settings = receiver.track.getSettings();
                    // Camera tracks typically have smaller dimensions and no displaySurface
                    if (!settings.displaySurface && (!settings.width || settings.width <= 1280)) {
                        cameraTrack = receiver.track;
                        break;
                    }
                }

                if (cameraTrack) {
                    try {
                        await safeUpdateVideoSource(cameraVideo, cameraTrack, `restored camera feed for user ${userId}`);

                        // Update disabled state
                        const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                        if (cameraOverlay) {
                            if (!cameraTrack.enabled) {
                                cameraOverlay.classList.add('camera-disabled');
                            } else {
                                cameraOverlay.classList.remove('camera-disabled');
                            }

                            // Set up track state monitors
                            cameraTrack.onmute = () => cameraOverlay.classList.add('camera-disabled');
                            cameraTrack.onunmute = () => cameraOverlay.classList.remove('camera-disabled');
                            cameraTrack.onended = () => {
                                console.log(`Camera track ended for ${userId}, attempting recovery...`);
                                setTimeout(() => attemptToRestoreCameraFeed(userId, pc, cameraVideo), 1000);
                            };
                        }

                        console.log(`Successfully restored camera feed for user ${userId}`);
                        return true;
                    } catch (error) {
                        console.error(`Failed to restore camera feed for user ${userId}:`, error);
                        return false;
                    }
                }
            }

            // If we couldn't find a camera track, mark as disabled
            const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
            if (cameraOverlay) {
                cameraOverlay.classList.add('camera-disabled');
            }

            return false;
        }

        // Enhanced function to check and restore screen share overlays
        function checkAndRestoreScreenShareOverlays() {
            // Look for all screen sharing video wrappers
            const screenShareWrappers = document.querySelectorAll('.video-wrapper.screen-sharing');

            // If no screen sharing is happening, nothing to do
            if (screenShareWrappers.length === 0) {
                return;
            }

            console.log(`Checking ${screenShareWrappers.length} screen sharing wrappers for camera overlays...`);

            screenShareWrappers.forEach(wrapper => {
                const userId = wrapper.id.replace('video-wrapper-', '');
                let cameraOverlay = document.getElementById(`camera-overlay-${userId}`);

                // Check if we have a peer connection for this user
                const pc = peerConnections[userId];

                if (!cameraOverlay && pc) {
                    console.log(`Camera overlay missing for screen sharing user ${userId}, attempting to recreate it...`);

                    // Attempt to create the missing camera overlay
                    cameraOverlay = createMissingCameraOverlay(userId, wrapper, pc);

                    if (cameraOverlay) {
                        // Set up mutation observer to detect if overlay is removed
                        const observer = new MutationObserver((mutations) => {
                            mutations.forEach((mutation) => {
                                if (mutation.type === 'childList' &&
                                    mutation.removedNodes.length > 0 &&
                                    Array.from(mutation.removedNodes).some(node =>
                                        node.id === `camera-overlay-${userId}`)) {
                                    console.log(`Camera overlay was removed for ${userId}, recreating...`);
                                    observer.disconnect();
                                    setTimeout(() => checkAndRestoreScreenShareOverlays(), 100);
                                }
                            });
                        });

                        observer.observe(wrapper, {
                            childList: true,
                            subtree: true
                        });
                    }
                }

                if (cameraOverlay) {
                    // Ensure the camera overlay is visible and properly styled
                    wrapper.classList.add('has-remote-camera');
                    cameraOverlay.style.cssText = `
                        display: flex !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 20 !important;
                    `;

                    // Also check if the video element inside is working
                    const cameraVideo = document.getElementById(`camera-video-${userId}`);
                    if (cameraVideo && (!cameraVideo.srcObject || !cameraVideo.srcObject.active)) {
                        console.log(`Camera video feed missing for user ${userId}, attempting to restore...`);
                        attemptToRestoreCameraFeed(userId, pc, cameraVideo);
                    }
                }
            });
        }

        // Set up periodic monitoring with dynamic interval
        function setupScreenShareMonitoring() {
            let checkInterval = 3000; // Start with 3 seconds
            let consecutiveSuccesses = 0;
            let consecutiveFailures = 0;

            function adjustInterval() {
                if (consecutiveSuccesses >= 5) {
                    // If everything's stable, gradually increase the interval
                    checkInterval = Math.min(checkInterval * 1.5, 10000); // Cap at 10 seconds
                    consecutiveSuccesses = 0;
                } else if (consecutiveFailures >= 2) {
                    // If we're having issues, check more frequently
                    checkInterval = Math.max(checkInterval / 2, 1000); // Floor at 1 second
                    consecutiveFailures = 0;
                }
            }

            function monitoringCheck() {
                const screenShareWrappers = document.querySelectorAll('.video-wrapper.screen-sharing');
                let hadIssues = false;

                screenShareWrappers.forEach(wrapper => {
                    const userId = wrapper.id.replace('video-wrapper-', '');
                    const cameraOverlay = document.getElementById(`camera-overlay-${userId}`);
                    const cameraVideo = cameraOverlay ? document.getElementById(`camera-video-${userId}`) : null;

                    if (!cameraOverlay || (cameraVideo && (!cameraVideo.srcObject || !cameraVideo.srcObject.active))) {
                        hadIssues = true;
                    }
                });

                if (hadIssues) {
                    consecutiveFailures++;
                    consecutiveSuccesses = 0;
                    checkAndRestoreScreenShareOverlays();
                } else {
                    consecutiveSuccesses++;
                    consecutiveFailures = 0;
                }

                adjustInterval();

                // Schedule next check if still in conference
                if (conferenceScreen.style.display !== 'none') {
                    setTimeout(monitoringCheck, checkInterval);
                }
            }

            // Start monitoring
            monitoringCheck();
        }

        // Add touch event handling
        document.addEventListener('DOMContentLoaded', function () {
            // Touch event handler setup
            function setupTouchHandlers() {
                let touchTimeout;
                const TOUCH_DURATION = 3000; // Show overlay for 3 seconds after touch

                function handleTouch(element) {
                    // Remove active class from all elements
                    document.querySelectorAll('.touch-active').forEach(el => {
                        el.classList.remove('touch-active');
                    });

                    // Add active class to touched element
                    element.classList.add('touch-active');

                    // Clear any existing timeout
                    clearTimeout(touchTimeout);

                    // Set new timeout to remove active class
                    touchTimeout = setTimeout(() => {
                        element.classList.remove('touch-active');
                    }, TOUCH_DURATION);
                }

                // Delegate touch events at the container level
                const videoContainer = document.getElementById('videoContainer');
                if (videoContainer) {
                    videoContainer.addEventListener('touchstart', (e) => {
                        const videoWrapper = e.target.closest('.video-wrapper');
                        const cameraOverlay = e.target.closest('.camera-overlay, .remote-camera-overlay');

                        if (videoWrapper) {
                            handleTouch(videoWrapper);
                        }
                        if (cameraOverlay) {
                            handleTouch(cameraOverlay);
                            e.stopPropagation(); // Prevent triggering parent video wrapper
                        }
                    }, { passive: true });
                }

                // Handle room ID touch
                const currentRoomId = document.getElementById('currentRoomId');
                if (currentRoomId) {
                    currentRoomId.addEventListener('touchstart', () => {
                        handleTouch(currentRoomId);
                    }, { passive: true });
                }
            }

            // Call setup when DOM is loaded
            setupTouchHandlers();

            // Also call setup when joining a room
            window.addEventListener('roomJoined', setupTouchHandlers);
        });

        // Notification Manager
        const NotificationManager = {
            container: null,
            activeNotifications: new Set(),
            queue: [],
            maxNotifications: 3,

            init() {
                this.container = document.getElementById('notification-container');
                if (!this.container) {
                    this.container = document.createElement('div');
                    this.container.id = 'notification-container';
                    document.body.insertBefore(this.container, document.body.firstChild);
                }
            },

            show(message, type = 'info', duration = 5000) {
                // Check for duplicates
                const notificationKey = `${message}-${type}`;
                if (this.activeNotifications.has(notificationKey)) {
                    return; // Skip duplicate notification
                }

                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;

                // Add icon based on type
                const iconSvg = this.getIconForType(type);

                notification.innerHTML = `
                    <div class="notification-icon">${iconSvg}</div>
                    <div class="notification-content">${message}</div>
                    <button class="notification-close" aria-label="Close notification">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                    </button>
                `;

                // Add to active notifications
                this.activeNotifications.add(notificationKey);

                // Handle close button
                const closeButton = notification.querySelector('.notification-close');
                closeButton.addEventListener('click', () => {
                    this.remove(notification, notificationKey);
                });

                // Check if we need to queue
                if (this.container.children.length >= this.maxNotifications) {
                    this.queue.push({ notification, notificationKey, duration });
                    return;
                }

                this.addToContainer(notification, notificationKey, duration);
            },

            addToContainer(notification, notificationKey, duration) {
                this.container.appendChild(notification);

                // Trigger reflow for animation
                notification.offsetHeight;
                notification.classList.add('visible');

                // Auto remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        this.remove(notification, notificationKey);
                    }, duration);
                }
            },

            remove(notification, notificationKey) {
                if (!notification.isConnected) return;

                notification.classList.remove('visible');

                notification.addEventListener('transitionend', () => {
                    notification.remove();
                    this.activeNotifications.delete(notificationKey);

                    // Process queue
                    if (this.queue.length > 0 && this.container.children.length < this.maxNotifications) {
                        const next = this.queue.shift();
                        this.addToContainer(next.notification, next.notificationKey, next.duration);
                    }
                }, { once: true });
            },

            getIconForType(type) {
                switch (type) {
                    case 'success':
                        return `<svg viewBox="0 0 24 24" fill="none" stroke="#34a853" stroke-width="2">
                            <path d="M20 6L9 17l-5-5"/>
                        </svg>`;
                    case 'error':
                        return `<svg viewBox="0 0 24 24" fill="none" stroke="#ea4335" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M15 9l-6 6M9 9l6 6"/>
                        </svg>`;
                    case 'warning':
                        return `<svg viewBox="0 0 24 24" fill="none" stroke="#fbbc05" stroke-width="2">
                            <path d="M12 9v4M12 16h.01"/>
                            <path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/>
                        </svg>`;
                    default: // info
                        return `<svg viewBox="0 0 24 24" fill="none" stroke="#4285f4" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 16v-4M12 8h.01"/>
                        </svg>`;
                }
            }
        };

        // Initialize notification manager
        NotificationManager.init();

        // Replace existing showNotification function
        function showNotification(message, type = 'info', duration = 5000) {
            NotificationManager.show(message, type, duration);
        }

        // Replace existing showParticipantNotification function
        function showParticipantNotification(message, type = 'info', duration = 5000) {
            NotificationManager.show(message, type, duration);
        }

        // Function to enumerate and populate available camera devices
        async function updateCameraDevices() {
            try {
                // Add loading state
                cameraSelect.classList.add('loading');

                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoInputDevices = devices.filter(device => device.kind === 'videoinput');

                // Clear existing options
                cameraSelect.innerHTML = '';

                if (videoInputDevices.length === 0 || videoInputDevices.every(device => !device.label)) {
                    // No devices or no labels (no permissions) - show default option
                    const option = document.createElement('option');
                    option.value = '';
                    option.text = 'Select camera';
                    cameraSelect.appendChild(option);
                    cameraSelect.disabled = true;
                } else {
                    // Add available cameras
                    videoInputDevices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Camera ${cameraSelect.options.length + 1}`;
                        cameraSelect.appendChild(option);
                    });

                    cameraSelect.disabled = false;

                    // Select the current device if one is active
                    if (currentCameraId) {
                        cameraSelect.value = currentCameraId;
                    }

                    // If no camera is selected but we have options, select the first one
                    if (!cameraSelect.value && cameraSelect.options.length > 0) {
                        cameraSelect.selectedIndex = 0;
                        currentCameraId = cameraSelect.value;
                    }
                }
            } catch (error) {
                console.error('Error enumerating camera devices:', error);
                cameraSelect.innerHTML = '<option value="">Error loading cameras</option>';
                cameraSelect.disabled = true;
            } finally {
                // Remove loading state
                cameraSelect.classList.remove('loading');
            }
        }

        // Function to switch camera
        async function switchCamera(deviceId) {
            try {
                // Get new video stream with selected device
                const newStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        deviceId: { exact: deviceId },
                        ...mediaConstraints.video
                    }
                });

                const newVideoTrack = newStream.getVideoTracks()[0];

                if (newVideoTrack) {
                    // Store the new device ID
                    currentCameraId = deviceId;

                    // Get the current enabled state from the UI
                    const isDisabled = toggleVideoButton.classList.contains('active');

                    // Set the new track's enabled state to match the UI
                    newVideoTrack.enabled = !isDisabled;

                    // Replace the video track in the local stream
                    const oldVideoTrack = localStream.getVideoTracks()[0];
                    if (oldVideoTrack) {
                        oldVideoTrack.stop();
                        localStream.removeTrack(oldVideoTrack);
                    }
                    localStream.addTrack(newVideoTrack);

                    // Update local video
                    if (localVideo) {
                        localVideo.srcObject = localStream;
                    }

                    // Replace the track in all peer connections
                    Object.values(peerConnections).forEach(pc => {
                        const senders = pc.getSenders();
                        const sender = senders.find(s => s.track && s.track.kind === 'video');
                        if (sender) {
                            sender.replaceTrack(newVideoTrack);
                        }
                    });

                    showNotification('Camera switched successfully', 'success', 3000);
                }
            } catch (error) {
                console.error('Error switching camera:', error);
                showNotification('Failed to switch camera', 'error', 5000);
            }
        }

        // Add event listener for camera selection change
        cameraSelect.addEventListener('change', () => {
            const selectedDeviceId = cameraSelect.value;
            if (selectedDeviceId && selectedDeviceId !== currentCameraId) {
                switchCamera(selectedDeviceId);
            }
        });

        // Update the DOMContentLoaded event handler to initialize camera devices
        document.addEventListener('DOMContentLoaded', function () {
            // Add device-specific classes to HTML element
            const htmlElement = document.documentElement;

            if (isMobileDevice()) {
                htmlElement.classList.add('mobile');

                if (isIOSDevice()) {
                    htmlElement.classList.add('ios');
                    // Hide screen share button on iOS since it's not supported
                    const shareScreenButton = document.getElementById('shareScreen');
                    if (shareScreenButton) {
                        shareScreenButton.style.display = 'none';
                    }
                } else if (isAndroidDevice()) {
                    htmlElement.classList.add('android');
                }
            } else {
                htmlElement.classList.add('desktop');
            }

            // Initialize dropdowns with default options without requesting permissions
            micSelect.innerHTML = '<option value="">Select microphone</option>';
            cameraSelect.innerHTML = '<option value="">Select camera</option>';
        });

        // Function to switch between front and back cameras on mobile
        async function switchMobileCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length < 2) {
                    showNotification('No alternative camera found', 'warning', 3000);
                    return;
                }

                // Find current camera
                const currentTrack = localStream.getVideoTracks()[0];
                const currentSettings = currentTrack ? currentTrack.getSettings() : {};
                const currentDeviceId = currentSettings.deviceId;

                // Find the next camera to switch to
                let nextDeviceId;
                const currentIndex = videoDevices.findIndex(device => device.deviceId === currentDeviceId);
                if (currentIndex === -1 || currentIndex === videoDevices.length - 1) {
                    nextDeviceId = videoDevices[0].deviceId;
                } else {
                    nextDeviceId = videoDevices[currentIndex + 1].deviceId;
                }

                // Add switching animation
                const switchButton = document.getElementById('switchCamera');
                switchButton.classList.add('switching');

                // Switch to the next camera
                await switchCamera(nextDeviceId);

                // Remove switching animation
                setTimeout(() => {
                    switchButton.classList.remove('switching');
                }, 300);

            } catch (error) {
                console.error('Error switching mobile camera:', error);
                showNotification('Failed to switch camera', 'error', 5000);
            }
        }

        // Add touch event listeners for the switch camera button
        const switchCameraButton = document.getElementById('switchCamera');
        if (switchCameraButton) {
            switchCameraButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                this.classList.add('touch-active');
            }, { passive: false });

            switchCameraButton.addEventListener('touchend', function(e) {
                e.preventDefault();
                this.classList.remove('touch-active');
                switchMobileCamera();
            }, { passive: false });

            // Also add click event for testing on desktop
            switchCameraButton.addEventListener('click', switchMobileCamera);
        }
    </script>
</body>

</html>